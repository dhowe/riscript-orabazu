{"version":3,"sources":["../src/riscript.js","../src/tokens.js","../src/parser.js","../src/visitor.js","../src/grammar.js","../src/index.js"],"names":["he","Query","Lexer","createToken","getTokens","v2Compatible","Symbols","Escaped","k","v","escapeRegex","PENDING_GATE_PATTERN","ExitGate","Gate","PendingGate","EnterGate","OC","CC","OR","ELSE","EQ","TF","OS","CS","SYM","Entity","Weight","Raw","s","CstParser","RiScriptParser","allTokens","opts","cst","$","Tokens","t","BaseVisitor","riScript","o","cstNode","param","name","location","RiScriptVisitor","context","ctx","count","types","exprs","c","mingoQuery","raw","e","resolvedOps","unresolvedOps","operands","sym","result","resolved","isStatic","isUser","value","info","ident","type","image","original","symbol","msg","lookup","rawGate","gateResult","choiceKey","decision","orExpr","options","excluded","restored","tfs","transforms","lhs","rhs","wexprs","wexpr","expr","weight","mult","index","excludes","valid","x","selected","txs","i","tx","obj","madeCast","num","table","allResolved","key","val","target","transform","dyns","stats","args","decode","VowelRE","RegexEscape","HtmlEntities","RiQuery","scripting","condition","len","stack","keys","currentObj","ele","_RiScript","script","Constants","tokens","anysym","open","close","lexResult","input","last","endingBreak","rawQuery","str","tag","g","deferredGate","deferredContext","reject","slashEscapesToEntities","lines","eqIdx","opens","charCount","closes","line","text","unescapeRegexProperty","res","parts","escaped","urp","first","phones","quotify","chr","hash","strHash","RiScript","__publicField","replaceAll","escapeRegExp","string","match","replacement","RiGrammar","rules","rg","def","incoming","parseJSON","self","replacer","space","lb","start","rule","json","src_default"],"mappings":"wKAAA,OAAOA,MAAQ,KACf,OAAS,SAAAC,MAAa,QACtB,OAAS,SAAAC,MAAa,aCFtB,OAAS,eAAAC,MAAmB,aAE5B,SAASC,EAAUC,EAAc,CAE/B,IAAIC,EAAU,CACZ,GAAI,IACJ,KAAM,KACN,QAAS,IACT,OAAQ,IACR,OAAQ,IACR,UAAW,IACX,WAAY,IACZ,aAAc,KACd,YAAa,IACb,aAAc,GAChB,EAkBA,OAAO,OAAOA,EAASD,EAhBP,CACd,YAAa,IACb,aAAc,IACd,YAAa,IACb,aAAc,IACd,aAAc,IAChB,EAEgB,CACd,YAAa,IACb,aAAc,IACd,YAAa,IACb,aAAc,IACd,aAAc,GAChB,CAE2D,EAE3D,IAAME,EAAU,CAAC,EACjB,OAAO,QAAQD,CAAO,EAAE,QAAQ,CAAC,CAACE,EAAGC,CAAC,IAAM,CAAEF,EAAQC,CAAC,EAAIE,EAAYD,CAAC,CAAE,CAAC,EAE3E,IAAME,EAAuB,IAAI,OAAO,GAAGJ,EAAQ,2BAA2B,EAE9EA,EAAQ,QAAU,OAAO,OAAOA,CAAO,EAAE,KAAK,EAAE,EAAE,QAAQ,QAAS,EAAE,EACrED,EAAQ,gBAAkB,IAAI,OAAOK,EAAqB,OAAQ,GAAG,EAErE,IAAMC,EAAWT,EAAY,CAC3B,KAAM,WACN,QAAS,IAAI,OAAO,OAAOI,EAAQ,YAAY,EAC/C,SAAU,EACZ,CAAC,EAEKM,EAAOV,EAAY,CACvB,KAAM,OACN,QAAS,IAAI,OAAO,KAAKI,EAAQ,cAAc,CACjD,CAAC,EAEKO,EAAcX,EAAY,CAC9B,KAAM,cACN,QAASQ,CACX,CAAC,EAEKI,EAAYZ,EAAY,CAC5B,KAAM,YACN,QAAS,IAAI,OAAO,GAAGI,EAAQ,eAAe,EAC9C,UAAW,WACb,CAAC,EAGKS,EAAKb,EAAY,CAAE,KAAM,KAAM,QAAS,IAAI,OAAOI,EAAQ,YAAc,MAAM,CAAE,CAAC,EAClFU,EAAKd,EAAY,CAAE,KAAM,KAAM,QAAS,IAAI,OAAO,OAAOI,EAAQ,cAAc,CAAE,CAAC,EACnFW,EAAKf,EAAY,CAAE,KAAM,KAAM,QAAS,UAAW,CAAC,EACpDgB,EAAOhB,EAAY,CAAE,KAAM,OAAQ,QAAS,YAAa,CAAC,EAC1DiB,EAAKjB,EAAY,CAAE,KAAM,KAAM,QAAS,SAAU,CAAC,EACnDkB,EAAKlB,EAAY,CAAE,KAAM,KAAM,QAAS,oCAAqC,CAAC,EAC9EmB,EAAKnB,EAAY,CAAE,KAAM,KAAM,QAAS,IAAI,OAAO,GAAGI,EAAQ,iBAAiB,CAAE,CAAC,EAClFgB,EAAKpB,EAAY,CAAE,KAAM,KAAM,QAAS,IAAI,OAAO,OAAOI,EAAQ,cAAc,CAAE,CAAC,EACnFiB,EAAMrB,EAAY,CAAE,KAAM,MAAO,QAAS,IAAI,OAAO,IAAII,EAAQ,UAAUA,EAAQ,sBAAsB,CAAE,CAAC,EAE5GkB,EAAStB,EAAY,CAAE,KAAM,SAAU,QAAS,+CAAgD,CAAC,EACjGuB,EAASvB,EAAY,CAAE,KAAM,SAAU,QAAS,IAAI,OAAO,OAAOI,EAAQ,gBAAgBA,EAAQ,kBAAkB,CAAE,CAAC,EACvHoB,EAAMxB,EAAY,CAAE,KAAM,MAAO,QAAS,IAAI,OAAO,KAAKI,EAAQ,WAAW,CAAE,CAAC,EAatF,MAAO,CAAE,OARS,CAChB,MAAO,CACL,OALe,CAACkB,EAAQC,EAAQP,EAAMH,EAAIC,EAAIC,EAAIE,EAAII,EAAKH,EAAIC,EAAIC,EAAIT,EAAaa,EAAKZ,CAAS,EAMlG,UALa,CAACF,EAAMD,CAAQ,CAM9B,EACA,YAAa,QACf,EAE4B,UAAW,CAAE,QAAAN,EAAS,QAAAC,CAAQ,CAAE,CAC9D,CAEA,SAASG,EAAYkB,EAAG,CACtB,OAAOA,EAAE,QAAQ,yBAA0B,MAAM,CACnD,CC/FA,OAAS,aAAAC,MAAiB,aAE1B,IAAMC,EAAN,cAA6BD,CAAU,CAErC,YAAYE,EAAW,CACrB,MAAMA,EAAW,CAAE,qBAAsB,MAAO,CAAC,EACjD,KAAK,UAAY,CAAC,SAAU,SAAU,SAAU,SAAU,QAAS,OAAQ,QAAQ,EACnF,KAAK,WAAW,CAClB,CAEA,MAAMC,EAAM,CACV,KAAK,MAAQA,EAAK,OAElB,IAAIC,EAAM,KAAK,OAAO,EACtB,GAAI,KAAK,OAAO,OAAS,EAAG,MAAM,MAC/B;AAAA,EAAgB,KAAK,OAAO,CAAC,EAAE,OAAO,EACzC,OAAOA,CACT,CAEA,YAAa,CAEX,IAAMC,EAAI,KAAMC,EAAS,KAAK,UAE9BD,EAAE,KAAK,SAAU,IAAM,CACrBA,EAAE,KAAK,IAAMA,EAAE,QAAQA,EAAE,IAAI,CAAC,CAChC,CAAC,EAEDA,EAAE,KAAK,QAAS,IAAM,CACpBA,EAAE,QAAQC,EAAO,WAAW,EAC5BD,EAAE,KAAK,IAAMA,EAAE,QAAQC,EAAO,EAAE,CAAC,CACnC,CAAC,EAEDD,EAAE,KAAK,SAAU,IAAM,CACrBA,EAAE,QAAQC,EAAO,MAAM,CACzB,CAAC,EAEDD,EAAE,KAAK,OAAQ,IAAM,CACnBA,EAAE,QAAQC,EAAO,SAAS,EAC1BD,EAAE,KAAK,IAAMA,EAAE,QAAQC,EAAO,IAAI,CAAC,EACnCD,EAAE,QAAQC,EAAO,QAAQ,CAC3B,CAAC,EAEDD,EAAE,KAAK,SAAU,IAAM,CACrBA,EAAE,QAAQC,EAAO,EAAE,EACnBD,EAAE,QAAQ,IAAMA,EAAE,QAAQA,EAAE,IAAI,CAAC,EACjCA,EAAE,QAAQC,EAAO,GAAG,EACpBD,EAAE,QAAQ,IAAM,CACdA,EAAE,QAAQC,EAAO,EAAE,EACnBD,EAAE,QAAQA,EAAE,IAAI,CAClB,CAAC,EACDA,EAAE,QAAQC,EAAO,EAAE,CACrB,CAAC,EAEDD,EAAE,KAAK,SAAU,IAAM,CACrBA,EAAE,QAAQC,EAAO,GAAG,EACpBD,EAAE,QAAQC,EAAO,EAAE,EACnBD,EAAE,QAAQA,EAAE,IAAI,CAClB,CAAC,EAEDA,EAAE,KAAK,SAAU,IAAM,CACrBA,EAAE,QAAQC,EAAO,GAAG,EACpBD,EAAE,KAAK,IAAMA,EAAE,QAAQC,EAAO,EAAE,CAAC,CACnC,CAAC,EAEDD,EAAE,KAAK,SAAU,IAAM,CACrBA,EAAE,QAAQA,EAAE,OAAO,CACrB,CAAC,EAEDA,EAAE,KAAK,SAAU,IAAM,CACrBA,EAAE,QAAQA,EAAE,OAAO,CACrB,CAAC,EAEDA,EAAE,KAAK,UAAW,IAAM,CACtBA,EAAE,SAAS,CACT,IAAKC,EAAO,GACZ,IAAK,IAAMD,EAAE,QAAQA,EAAE,KAAK,CAC9B,CAAC,CACH,CAAC,EAGDA,EAAE,KAAK,SAAU,IAAM,CACrBA,EAAE,QAAQC,EAAO,EAAE,EACnBD,EAAE,QAAQ,IAAMA,EAAE,QAAQA,EAAE,IAAI,CAAC,EACjCA,EAAE,QAAQA,EAAE,MAAM,EAKlBA,EAAE,QAAQ,IAAM,CACdA,EAAE,QAAQC,EAAO,IAAI,EACrBD,EAAE,QAAQA,EAAE,MAAM,CACpB,CAAC,EACDA,EAAE,QAAQC,EAAO,EAAE,EACnBD,EAAE,KAAK,IAAMA,EAAE,QAAQC,EAAO,EAAE,CAAC,CACnC,CAAC,EAEDD,EAAE,KAAK,QAAS,IAAM,CACpBA,EAAE,KAAK,IAAM,CACXA,EAAE,GAAG,CACH,CAAE,IAAK,IAAMA,EAAE,QAAQA,EAAE,IAAI,CAAE,EAC/B,CAAE,IAAK,IAAMA,EAAE,QAAQC,EAAO,MAAM,CAAE,CACxC,CAAC,CACH,CAAC,CACH,CAAC,EAEDD,EAAE,KAAK,OAAQ,IAAM,CACnBA,EAAE,aAAa,IAAMA,EAAE,QAAQA,EAAE,IAAI,CAAC,CACxC,CAAC,EAEDA,EAAE,KAAK,OAAQ,IAAM,CACnBA,EAAE,GAAG,KAAK,UAAU,IAAIE,IAAM,CAAE,IAAK,IAAMF,EAAE,QAAQA,EAAEE,CAAC,CAAC,CAAE,EAAE,CAAC,CAChE,CAAC,EAEDF,EAAE,KAAK,OAAQ,IAAM,CACnBA,EAAE,QAAQC,EAAO,GAAG,CACtB,CAAC,EAED,KAAK,oBAAoB,CAC3B,CACF,ECvHA,IAAME,EAAN,KAAkB,CAChB,YAAYC,EAAU,CACpB,KAAK,MAAQ,EAEb,KAAK,KAAO,GACZ,KAAK,UAAY,GACjB,KAAK,UAAYA,EACjB,KAAK,mBAAqB,GAC1B,KAAK,SAAW,KAAK,UAAU,WACjC,CAEA,UAAUC,EAAG,CACX,OAAQ,OAAOA,GAAM,WAClB,WAAYA,GAAM,SAAUA,GAAK,aAAcA,GAAK,aAAcA,EACvE,CAEA,MAAMC,EAASC,EAAO,CAIpB,GAHI,MAAM,QAAQD,CAAO,IACvBA,EAAUA,EAAQ,CAAC,GAEjB,OAAOA,EAAY,IACrB,OAEF,GAAI,CAAC,KAAK,UAAUA,CAAO,EACzB,MAAM,MAAM,gCAAkC,KAAK,UAAUA,CAAO,CAAC,EAGvE,GAAM,CAAE,KAAAE,EAAM,SAAAC,CAAS,EAAIH,EAO3B,GALA,KAAK,SAAW,KAAK,MAAM,UACzBG,EAAS,YACTA,EAAS,UAAY,CACvB,EAEI,OAAO,KAAKD,CAAI,GAAM,WACxB,MAAM,MAAM,kDACPA,aAAgB,OAAO,KAAKA,CAAI,MAAM,KAAK,UAAU,KAAKA,CAAI,CAAC,GAAG,EAGzE,OAAI,KAAK,WAAa,CAAC,qBAAqB,KAAKA,CAAI,IACnD,KAAK,MAAQA,EAAO,KAEf,KAAKA,CAAI,EAAEF,EAAQ,SAAUC,CAAK,CAC3C,CAEA,iBAAkB,CAElB,CACF,EAEMG,EAAN,cAA8BP,CAAY,CACxC,YAAYC,EAAUO,EAAU,CAAC,EAAG,CAClC,MAAMP,CAAQ,EACd,KAAK,QAAUO,EAEf,KAAK,MAAQ,EACb,KAAK,QAAU,CAAC,EAChB,KAAK,WAAa,GAClB,KAAK,QAAU,KAAK,UAAU,QAC9B,KAAK,QAAU,KAAK,UAAU,QAG9B,KAAK,QAAU,CAAC,EAChB,KAAK,SAAW,CAAC,EACjB,KAAK,aAAe,CAAC,EACrB,KAAK,eAAiB,IAAI,IAE1B,KAAK,gBAAgB,CACvB,CAEA,MAAMb,EAAO,CAAC,EAAG,CAIf,GAHA,KAAK,MAAQA,EAAK,MAClB,KAAK,MAAQA,EAAK,MAClB,KAAK,QAAUA,EAAK,QAChB,CAACA,EAAK,IAAK,MAAM,MAAM,QAAQ,EACnC,OAAO,MAAM,MAAMA,EAAK,GAAG,CAC7B,CAEA,OAAOc,EAAK,CACV,KAAK,MAAQ,EACb,IAAMC,EAAQD,EAAI,KAAOA,EAAI,KAAK,OAAS,EAG3C,GAFA,KAAK,MAAM,SAAU,IAAM,KAAK,SAAS,YAAY,KAAK,KAAK,EAC3D,QAAUC,EAAQ,gBAAgB,EAClC,CAACA,EAAO,MAAO,GACnB,GAAI,OAAO,KAAKD,CAAG,EAAE,SAAW,EAAG,MAAM,MAAM,sBAAsB,EACrE,OAAO,KAAK,MAAMA,EAAI,IAAI,CAC5B,CAEA,KAAKA,EAAK,CAER,IAAME,EAAQ,OAAO,KAAKF,CAAG,EAC7B,GAAIE,EAAM,SAAW,EAAG,MAAM,MAAM,iBAAmBA,EAAM,MAAM,EACnE,IAAMC,EAAQH,EAAI,KAAK,IAAKI,GAAM,KAAK,MAAMA,CAAC,CAAC,EAE/C,QAAS,EAAI,EAAG,EAAID,EAAM,OAAS,EAAG,IAElCA,EAAM,CAAC,EAAE,SAAW,GACpBA,EAAM,EAAI,CAAC,EAAE,SAAS,GAAG,GACzBA,EAAM,EAAI,CAAC,EAAE,WAAW,GAAG,IAE3BA,EAAM,EAAI,CAAC,EAAIA,EAAM,EAAI,CAAC,EAAE,UAAU,CAAC,GAG3C,OAAOA,EAAM,KAAK,EAAE,CACtB,CAEA,MAAMH,EAAK,CACT,KAAK,MAAM,OAAO,CACpB,CAEA,KAAKA,EAAK,CAGR,GAAIA,EAAI,KAAK,SAAW,EAAG,MAAM,MAAM,iBAAmBA,EAAI,IAAI,EAElE,IAAIK,EACEC,EAAMN,EAAI,KAAK,CAAC,EAAE,MACxB,GAAI,CACFK,EAAa,KAAK,UAAU,OAAOC,CAAG,CACxC,OAASC,EAAP,CACA,GAAI,CAAC,KAAK,mBACR,MAAM,MAAM,sBAAsBD;AAAA;AAAA,eAAyBC,GAAG,EAEhE,MAAI,CAAC,KAAK,UAAU,KAAK,QAAU,CAAC,KAAK,UAAU,QACjD,QAAQ,KAAK,kCAAkCD;AAAA,EAAUC,CAAC,EAErD,CAAE,SAAU,QAAS,CAC9B,CAEA,IAAMC,EAAc,CAAC,EACfC,EAAgB,CAAC,EACjBC,EAAWL,EAAW,SAAS,EAyBrC,GAxBAK,EAAS,QAASC,GAAQ,CACxB,GAAI,CAAE,OAAAC,EAAQ,SAAAC,EAAU,SAAAC,EAAU,OAAAC,CAAO,EAAI,KAAK,aAAaJ,CAAG,EAE9D,OAAOC,GAAW,aAEpBA,EAASA,EAAO,KAAK,EACrBC,EAAW,CAAC,KAAK,UAAU,YAAYD,CAAM,GAE3C,OAAOA,EAAW,KAAe,CAACC,EACpCJ,EAAc,KAAKE,CAAG,GAGlBG,EACF,KAAK,QAAQH,CAAG,EAAIC,EACXG,EACT,KAAK,QAAQJ,CAAG,EAAIC,EAEpB,KAAK,SAASD,CAAG,EAAIC,EAGvBJ,EAAYG,CAAG,EAAIC,EAEvB,CAAC,EAGC,OAAO,KAAKJ,CAAW,EAAE,OAASC,EAAc,SAChDC,EAAS,OACP,MAAM,MAAM,kBAAkB,EAGlC,GAAID,EAAc,OAAU,MAAO,CAAE,SAAU,QAAS,SAAUA,CAAc,EAEhF,IAAIG,EAASP,EAAW,KAAKG,CAAW,EACxC,MAAI,CAACI,GAAU,KAAK,WAAWJ,CAAW,IACxCI,EAASP,EAAW,KAAKG,CAAW,GAG/B,CAAE,SAAUI,EAAS,SAAW,QAAS,CAClD,CAEA,OAAOZ,EAAKd,EAAM,CAChB,IAAMyB,EAAMX,EAAI,IAAI,CAAC,EAAE,MACnBgB,EACAC,EACEC,EAAQP,EAAI,QAAQ,KAAK,UAAU,YAAa,EAAE,EAGxD,GAFiBA,EAAI,WAAW,KAAK,QAAQ,MAAM,EAGjDK,EAAQ,KAAK,MAAMhB,EAAI,IAAI,EACvB,KAAK,UAAU,YAAYgB,CAAK,GAClC,KAAK,QAAQE,CAAK,EAAIF,EACtBA,EAAQ,KAAK,iBAAiBE,EAAOlB,EAAI,GAAIgB,CAAK,IAElD,KAAK,QAAQE,CAAK,EAAIF,EACtB,KAAK,eAAe,OAAOE,CAAK,EAChC,KAAK,OACH,QAAQ,IAAI,qBAAsBP,EAChC,KAAK,eAAe,OAChB,KAAK,UAAU,KAAK,cAAc,EAClC,EACN,GAEJM,EAAO,GAAGN,OAAS,KAAK,SAAS,YAAYK,CAAK,eAClC9B,GAAM,OAAS,WAAa,SACvC,CACL,IAAME,EAAI,KAGV4B,EAAQ,IAAM5B,EAAE,MAAMY,EAAI,IAAI,EAC9BiB,EAAO,GAAGN,oBAAwBzB,GAAM,OAAS,WAAa,IAK9D,KAAK,SAASgC,CAAK,EAAIF,EAEzB,YAAK,MAAM,SAAUC,CAAI,EAElBD,CACT,CAEA,OAAOhB,EAAK,CACV,OAAIA,EAAI,GACN,KAAK,OAAOA,EAAK,CAAE,OAAQ,EAAK,CAAC,EAEjC,KAAK,OAAOA,EAAK,CAAE,OAAQ,EAAK,CAAC,EAE5B,EACT,CAEA,KAAKA,EAAK,CACR,IAAIY,EACEV,EAAQ,OAAO,KAAKF,CAAG,EAC7B,GAAIE,EAAM,SAAW,EAAG,MAAM,MAAM,iBAAmBA,CAAK,EAC5D,YAAK,UAAU,OAAO,UAAU,QAASiB,GAAS,CAChD,IAAMpB,EAAUC,EAAImB,CAAI,EACxB,GAAIpB,EAAS,CACX,GAAIA,EAAQ,SAAW,EACrB,MAAM,MAAMoB,EAAO,mBAAqBnB,EAAImB,CAAI,EAAE,MAAM,EAG1DP,EAAS,KAAK,MAAMb,EAAQ,CAAC,CAAC,EAElC,CAAC,EAGG,OAAOa,GAAW,aACpBA,EAASA,EAAO,KAAK,GAEhBA,CACT,CAEA,KAAKZ,EAAK,CACR,GAAIA,EAAI,IAAI,SAAW,EAAG,MAAM,MAAM,kBAAkB,EACxD,GAAI,OAAO,KAAKA,CAAG,EAAE,SAAW,EAAG,MAAM,MAAM,kBAAkB,EACjE,IAAMoB,EAAQpB,EAAI,IAAI,CAAC,EAAE,MACzB,YAAK,MAAM,OAAQ,KAAK,SAAS,YAAY,IAAMoB,EAAQ,GAAG,CAAC,EACxDA,CACT,CAEA,OAAOpB,EAAK,CACV,OAAO,KAAK,QACd,CAEA,OAAOA,EAAKd,EAAM,CAChB,GAAIc,EAAI,IAAI,SAAW,EAAG,MAAM,MAAM,oBAAoB,EAE1D,IAAMqB,EAAW,KAAK,SAChBC,EAAStB,EAAI,IAAI,CAAC,EAAE,MACpBkB,EAAQI,EAAO,QAAQ,KAAK,UAAU,YAAa,EAAE,EAI3D,GAFA,KAAK,WAAa,KAAK,YAAYtB,EAAI,EAAE,EAErC,KAAK,eAAe,IAAIkB,CAAK,EAC/B,YAAK,MAAM,SAAU,GAAGI,gBAAqB,EACtCD,EAIT,GAAI,CAAE,OAAAT,EAAQ,SAAAE,EAAU,OAAAC,EAAQ,SAAAF,CAAS,EAAI,KAAK,aAAaK,CAAK,EAEpE,GAAI,CAACJ,GAAYQ,EAAO,WAAW,KAAK,QAAQ,MAAM,GAChD,CAAC,KAAK,UAAU,SAAS,KAAKA,CAAM,EACtC,MAAM,MAAM,uCAAuCJ,SAC7C,KAAK,QAAQ,SAASA,oBAAwBA,IAAQ,EAUhE,GANI,OAAON,GAAW,aAEpBA,EAASA,EAAO,KAAK,EACrBC,EAAW,CAAC,KAAK,UAAU,YAAYD,CAAM,GAG3C,KAAK,aAAeE,GAAYC,GAAS,CAC3C,KAAK,WAAa,GAClB,IAAMQ,EAAM,kCAAoCT,EAC5C,kBAAoBQ,EAAS,2BAC/B,KAAK,QAAQ,QAAUJ,EAAQ,MAC7B,uBAAyBA,EAAQ,8BACnC,KAAK,QAAQ,QAAUA,EAAQ,kBACjC,MAAM,MAAMK,CAAG,EAGjB,GAAI,OAAOX,EAAW,IAEpB,YAAK,MAAM,SAAUU,EAAS,QAAUD,EAAW,SACjD,KAAK,gBAAgB,EAAG,aAAcnC,GAAM,OAAS,WAAa,EAAE,EAC/DmC,EAGT,IAAIJ,EAAOI,EAAW,QAAUT,EAAS,KAAO1B,GAAM,OAAS,YAAc,IAG7E,OAAI,OAAO0B,GAAW,UAAY,CAACC,GAC7BC,GACF,KAAK,eAAe,IAAII,CAAK,EAC7BN,EAAS,KAAK,iBAAiBM,EAAOlB,EAAI,GAAIY,CAAM,EACpD,KAAK,MAAM,UAAW,GAAGS,QAAeT,oBAAyBM,IAAQ,IAErElB,EAAI,KAAIY,EAAS,KAAK,kBAAkBA,EAAQZ,EAAI,EAAE,GAC1D,KAAK,MAAM,SAAUiB,CAAI,GAEpBL,IAGLE,IAEF,KAAK,QAAQI,CAAK,EAAIN,GAGpBZ,EAAI,KACNY,EAAS,KAAK,gBAAgBA,EAAQZ,EAAI,EAAE,EAC5CiB,GAAQ,QAAUL,EAAS,IAGvB,KAAK,aAAYK,GAAQ,gBAG/B,KAAK,MAAM,SAAUA,CAAI,EAGrB,KAAK,eAAe,IAAIC,CAAK,IAC/B,KAAK,OAAS,QAAQ,IAAI,uBAAwBJ,EAAW,IAAM,KAAOI,EACxE,KAAK,eAAe,OAAS,KAAK,UAAU,KAAK,cAAc,EAAI,EAAE,EACvE,KAAK,eAAe,OAAOA,CAAK,GAElC,KAAK,WAAa,GAEXN,EACT,CAEA,MAAMZ,EAAK,CACT,KAAK,MAAM,QAAS,KAAK,QAAQ,EAEjC,IAAMqB,EAAW,KAAK,SAChBH,EAAQG,EAAS,QAAQ,KAAK,QAAQ,aAAc,EAAE,EACtDG,EAAS,KAAK,aAAaN,CAAK,EAEtC,GAAI,CAACM,EACH,MAAM,MAAM,oBAAsBH,EAAW,YAC3C,KAAK,UAAU,OAAO,KAAK,KAAK,YAAY,CAAC,CAAC,EAalD,OAVwBG,EAAO,SAAS,KAAM/B,GAAM,CAClD,GAAI,CAAE,OAAAmB,EAAQ,SAAAC,CAAS,EAAI,KAAK,aAAapB,CAAC,EAC9C,OAAI,OAAOmB,GAAW,aAEpBA,EAASA,EAAO,KAAK,EACrBC,EAAW,CAAC,KAAK,UAAU,YAAYD,CAAM,GAExC,OAAOA,EAAW,KAAe,CAACC,CAC3C,CAAC,EAE2BQ,EAEb,KAAK,OAAOG,EAAO,eAAe,CAEnD,CAEA,KAAKxB,EAAK,CAER,OAAO,KAAK,MAAMA,EAAI,IAAI,EAAE,KAAK,CACnC,CAEA,OAAOA,EAAKd,EAAM,CAChB,IAAME,EAAI,KAAK,QACXqC,EAASC,EACPL,EAAW,KAAK,SAClBJ,EAAOI,EACLM,EAAY,KAAK,SAAS,YAAYN,EAAW,KAAO,KAAK,SAASrB,CAAG,CAAC,EAEhF,GAAI,CAAC,KAAK,YAAc,KAAK,YAAYA,EAAI,EAAE,EAC7C,MAAM,MAAM,+DAAiEqB,CAAQ,EAGvF,IAAIO,EAAW,SACf,GAAI1C,GAAM,YACR0C,EAAW,iBAEP5B,EAAI,OAENyB,EAAUzB,EAAI,KAAK,CAAC,EAAE,SAAS,KAAK,CAAC,EAAE,MACvC0B,EAAa,KAAK,MAAM1B,EAAI,IAAI,EAChC4B,EAAWF,EAAW,SACtBT,GAAQ;AAAA,WAAcQ,QAAcG,IAAa,QAC7CA,EAAS,YAAY,EACrB,SAASxC,EAAE,eAAeuC,QACvB,KAAK,gBAAgB,KAG1BD,GACEA,EAAW,WAAa,QAC1B,YAAK,aAAaC,CAAS,EAAI,CAC7B,gBAAiB3B,EACjB,SAAU0B,EAAW,QACvB,EACO,GAAGtC,EAAE,eAAeuC,IAKjC,GAAIC,IAAa,UAAY,EAAE,WAAY5B,GACzC,MAAO,GAGT,IAAM6B,EAAS7B,EAAI4B,CAAQ,IAAI,CAAC,GAAG,UAAU,UAAU,CAAC,EAClDE,EAAU,KAAK,aAAaD,CAAM,EACxC,GAAI,CAACC,EAAS,MAAM,MAAM,yBAA2BT,CAAQ,EAE7D,IAAIL,EAAQ,KACNe,EAAW,CAAC,EACdC,EAAW,GACf,KAAOhB,IAAU,MAAM,CAIrB,GAHAA,EAAQ,KAAK,OAAOc,EAASC,CAAQ,EAAE,MAGnC,KAAK,UAAU,YAAYf,CAAK,EAAG,CACjChB,EAAI,KAAIgB,EAAQ,KAAK,kBAAkBA,EAAOhB,EAAI,EAAE,GACxDgC,EAAW,GACX,MAOF,GAHIhC,EAAI,KAAIgB,EAAQ,KAAK,gBAAgBA,EAAOhB,EAAI,EAAE,GAGlD,KAAK,YAAcgB,IAAU,KAAK,QAAQW,CAAS,EAAG,CACxD,KAAK,MAAM,gBAAiBX,EAAQ,aAAa,EACjDe,EAAS,KAAKf,CAAK,EACnBA,EAAQ,KACR,UAIJ,OAAKgB,IAAU,KAAK,QAAQL,CAAS,EAAIX,GAElCA,CACT,CAIA,YAAYiB,EAAK,CACf,IAAMC,EAAa,KAAK,SAAS,gBAAgBD,CAAG,EACpD,OAAIC,EAAW,OACNA,EAAW,SAAS,IAAI,GAAKA,EAAW,SAAS,UAAU,EAE7D,EACT,CAEA,aAAahB,EAAO,CAClB,IAAIJ,EAAW,GACXC,EAAS,GACTH,EAEJ,GAAIM,EAAM,SAAW,EACnB,MAAO,CAAE,OAAQ,GAAI,SAAU,GAAM,SAAAJ,EAAU,OAAAC,CAAO,EAIxDH,EAAS,KAAK,SAASM,CAAK,EACxB,OAAON,EAAW,MAIpBA,EAAS,KAAK,QAAQM,CAAK,EACvB,OAAON,EAAW,MACpBE,EAAW,KAIX,OAAOF,EAAW,MAGpBA,EAAS,KAAK,QAAQM,CAAK,EACvB,OAAON,EAAW,IACpBG,EAAS,GAGTH,EAAS,KAAK,QAAQ,KAAK,QAAQ,QAAUM,CAAK,GAStD,IAAML,EAAW,CAAC,KAAK,UAAU,YAAYD,CAAM,EAEnD,MAAO,CAAE,OAAAA,EAAQ,SAAAE,EAAU,OAAAC,EAAQ,SAAAF,CAAS,CAC9C,CAEA,iBAAiBK,EAAOe,EAAKrB,EAAQ,CACnC,IAAMxB,EAAI,KAAK,QACT+C,EAAM/C,EAAE,OAAS8B,EACjBkB,EAAM,KAAK,kBAAkBxB,EAAQqB,CAAG,EAC9C,OAAArB,EAASxB,EAAE,aAAe+C,EAAM,IAAMC,GAAOhD,EAAE,aACxCwB,CACT,CAEA,SAASZ,EAAK,CACZ,GAAI,CAACA,EAAI,IAAM,CAACA,EAAI,GAAG,OAAQ,MAAM,MAAM,gBAAgB,EAC3D,OAAOA,EAAI,GAAG,CAAC,EAAE,YAAc,IAAMA,EAAI,GAAG,CAAC,EAAE,SACjD,CAEA,aAAaA,EAAK,CAChB,IAAM8B,EAAU,CAAC,EACjB,GAAI9B,GAAOA,GAAK,UAAU,MAAO,CAC/B,IAAMqC,EAASrC,EAAI,SAAS,MAC5B,QAAS,EAAI,EAAG,EAAIqC,EAAO,OAAQ,IAAK,CACtC,IAAMC,EAAQD,EAAO,CAAC,EAChBE,EAAOD,EAAM,SAAS,KAC5B,GAAIC,GAAQA,EAAK,QAAU,EAAK,MAAM,MAAM,wBAA0BA,EAAK,MAAM,EAEjF,IAAMC,EAASF,EAAM,SAAS,OAC9B,GAAIE,EAAQ,CACV,GAAIA,EAAO,QAAU,EAAK,MAAM,MAAM,mBAAqBA,EAAO,MAAM,EACxE,IAAIC,EAAO,EACX,GAAI,CACFA,EAAO,SACL,KAAK,QAAQ,aAAa,OACtBD,EAAO,CAAC,EAAE,MAAM,KAAK,EAAE,MAAM,EAAG,EAAE,EAClCA,EAAO,CAAC,EAAE,MAAM,KAAK,EAAE,MAAM,CAAC,CACpC,CACF,MAAE,CACA,QAAQ,IAAI,OAASC,CAAI,CAC3B,CACA,MAAM,KAAK,CAAE,OAAQA,CAAK,EAAG,IAAMX,EAAQ,KAAKS,CAAI,CAAC,OAErDT,EAAQ,KAAKS,GAAQ,EAAE,GAI7B,OAAOT,CACT,CAEA,aAAaA,EAASH,EAAW,CAI/B,KAAOG,EAAQ,QAAqB,CAClC,GAAM,CAAE,MAAAY,EAAO,MAAA1B,CAAM,EAAI,KAAK,OAAOc,CAAO,EAC5C,GAAId,IAAU,KAAK,QAAQW,CAAS,EAAG,OAAOX,EAE9Cc,EAAQ,OAAOY,EAAO,CAAC,EAEzB,MAAM,MAAM,sBAAsB,CACpC,CAEA,OAAOZ,EAASa,EAAW,CAAC,EAAG,CAC7B,GAAI,CAACb,GAAW,CAACA,EAAQ,OACvB,MAAM,MAAM,4BAA4B,EAG1C,IAAMc,EAAQd,EAAQ,OAAQe,GAAM,CAACF,EAAS,SAASE,CAAC,CAAC,EACzD,GAAI,CAACD,EAAM,OACT,MAAM,MAAM,kCAAkC,EAGhD,IAAMF,EAAQ,KAAK,UAAU,KAAK,MAAME,EAAM,MAAM,EAEhD5B,EAAQ,GAAU8B,EAAWF,EAAMF,CAAK,EAE5C,OAAI,OAAOI,GAAa,SACtB,KAAK,MAAM,cAAe,IAAI,GAG9B,KAAK,KAAO,UAAY,KAAK,KAC7B9B,EAAQ,KAAK,MAAM8B,CAAQ,GAGzB,OAAO9B,GAAU,WAAUA,EAAQA,EAAM,KAAK,GAE3C,CAAE,MAAA0B,EAAO,MAAA1B,CAAM,CACxB,CAEA,gBAAgBA,EAAO+B,EAAK,CACtB,KAAK,SAAW,QAAQ,IAAI,kBAAmB,KAAK,UAAU,GAAG,SAAS,CAAC,EAC/E,QAASC,EAAI,EAAGA,EAAID,EAAI,OAAQC,IAC9BhC,EAAQ,KAAK,eAAeA,EAAO+B,EAAIC,CAAC,CAAC,EAE3C,OAAOhC,CACT,CAGA,kBAAkBA,EAAO+B,EAAK,CAC5B,OAAI,OAAO/B,GAAU,WACN,IAAI,OACf,IAAM,KAAK,QAAQ,YAAc,KAAO,KAAK,QAAQ,aAAe,GACtE,EACU,KAAKA,CAAK,IAElBA,EAAQ,KAAK,QAAQ,YAAcA,EAAQ,KAAK,QAAQ,cAEtD+B,GACFA,EAAI,QAASE,GAAQjC,GAASiC,EAAG,KAAM,EAErC,KAAK,SAAS,QAAQ,IAAI,qBAAsBjC,CAAK,GAEpDA,CACT,CAEA,WAAWkC,EAAK,CACd,IAAIC,EAAW,GACf,cAAO,QAAQD,CAAG,EAAE,QAAQ,CAAC,CAACxF,EAAGC,CAAC,IAAM,CACtC,IAAMyF,EAAM,WAAWzF,CAAC,EACnB,MAAMyF,CAAG,IACZD,EAAW,GACXD,EAAIxF,CAAC,EAAI0F,EAEb,CAAC,EACMD,CACT,CAEA,kBAAkBE,EAAO,CACvB,IAAIC,EAAc,GAClB,cAAO,QAAQD,CAAK,EAAE,QAAQ,CAAC,CAACE,EAAKC,CAAG,IAAM,CACvC,KAAK,UAAU,YAAYA,CAAG,IACjCF,EAAc,GAElB,CAAC,EACMA,CACT,CAEA,eAAeG,EAAQC,EAAW,CAChC,IAAMtC,EAAQsC,EAAU,MACpB9C,EACEN,EAAMmD,EAASrC,EACf6B,EAAK7B,EAAM,UAAU,CAAC,EAAE,QAAQ,QAAS,EAAE,EAGjD,OAAI,OAAO,KAAK,SAAS6B,CAAE,GAAM,WAC/BrC,EAAS,KAAK,SAASqC,CAAE,EAAEQ,CAAM,EAG1B,OAAO,KAAK,QAAQR,CAAE,GAAM,WACnCrC,EAAS,KAAK,QAAQqC,CAAE,EAAEQ,CAAM,EAGzB,OAAO,KAAK,QAAQR,CAAE,GAAM,WACnCrC,EAAS,KAAK,QAAQqC,CAAE,EAAEQ,CAAM,EAIzB,OAAO,KAAK,SAAS,WAAWR,CAAE,GAAM,WAC/CrC,EAAS,KAAK,SAAS,WAAWqC,CAAE,EAAEQ,CAAM,EAGrC,OAAOA,EAAOR,CAAE,GAAM,WAC7BrC,EAAS6C,EAAOR,CAAE,EAAE,EAGhBQ,EAAO,eAAeR,CAAE,EAC1BrC,EAAS6C,EAAOR,CAAE,GAEd,CAAC,KAAK,UAAU,KAAK,QAAU,CAAC,KAAK,UAAU,QACjD,QAAQ,KAAK,gCAAkC3C,CAAG,EAKpDM,EAASN,EAAI,QAAQ,QAAS,cAAc,GAI5C,KAAK,OAAS,QAAQ,IAAI,GAAG,KAAK,QAAQ,gBAAgBA,SAAWM,IAAS,EAE3EA,CACT,CAEA,iBAAkB,CAChB,IAAM+C,EAAO,CAAC,EACRC,EAAQ,CAAC,EACf,cAAO,QAAQ,KAAK,UAAY,CAAC,CAAC,EAAE,QAClC,CAAC,CAAClG,EAAGC,CAAC,IAAOgG,EAAK,IAAIjG,IAAI,EAAIC,CAChC,EACA,OAAO,QAAQ,KAAK,SAAW,CAAC,CAAC,EAAE,QACjC,CAAC,CAACD,EAAGC,CAAC,IAAOiG,EAAM,IAAIlG,IAAI,EAAIC,CACjC,EACO,KAAK,UAAU,CAAE,GAAG,KAAK,QAAS,GAAGiG,EAAO,GAAGD,CAAK,EAAG,CAACjG,EAAGC,IAChE,OAAOA,GAAM,WAAa,eAAiBA,CAC7C,EAAE,QAAQ,KAAM,EAAE,CACpB,CAEA,UAAUqD,EAAO+B,EAAK,CACpB,OAAO/B,EAAQ+B,EAAI,IAAKE,GAAOA,EAAG,MAAM,QAAQ,KAAM,EAAE,EAAI,IAAI,EAAE,KAAK,EAAE,CAC3E,CAEA,MAAMnE,KAAM+E,EAAM,CACZ,KAAK,QACH,KAAK,MAAQ/E,IAAM,WACrBA,EAAI,KAAK,KAAK,QAAQ,MAAO,EAAE,GAEjC,QAAQ,IAAI,EAAE,KAAK,MAAO,IAAIA,KAAM,GAAG+E,CAAI,EAC3C,KAAK,KAAO,GAEhB,CAEA,SAAU,CACR,MAAO,IAAI,QAAQ,KAAK,MAAQ,IAAI,OAAS,CAAC,CAChD,CACF,EHlrBA,GAAM,CAAE,OAAAC,CAAO,EAAI5G,EACb6G,EAAU,UACVC,EAAc,OACdC,EAAe,iDAEfC,EAAN,cAAsB/G,CAAM,CAC1B,YAAYgH,EAAWC,EAAWtC,EAAS,CACzC,GAAI,OAAOsC,GAAc,SAAU,CACjC,IAAI9D,EAAM8D,EACVA,EAAYD,EAAU,UAAUC,CAAS,EAG3C,MAAMA,EAAWtC,CAAO,CAC1B,CAEA,KAAKoB,EAAK,CACR,QAASF,EAAI,EAAGqB,EAAM,KAAK,SAAS,OAAQrB,EAAIqB,EAAKrB,IACnD,GAAI,CAAC,KAAK,SAASA,CAAC,EAAEE,CAAG,EAAG,MAAO,GAErC,MAAO,EACT,CAEA,UAAW,CACT,IAAMoB,EAAQ,CAAC,KAAK,SAAS,EACvBC,EAAO,IAAI,IACjB,KAAOD,GAAO,OAAS,GAAG,CACxB,IAAME,EAAaF,EAAM,IAAI,EAC7B,OAAO,KAAKE,CAAU,EAAE,QAASjB,GAAQ,CACvC,IAAMvC,EAAQwD,EAAWjB,CAAG,EAEvBA,EAAI,WAAW,GAAG,GAAGgB,EAAK,IAAIhB,CAAG,EAClC,OAAOvC,GAAU,UAAYA,IAAU,OAC5B,MAAM,QAAQA,CAAK,EAAIA,EAAQ,CAACA,CAAK,GAC7C,QAASyD,GAAQH,EAAM,KAAKG,CAAG,CAAC,CAEzC,CAAC,EAEH,OAAO,MAAM,KAAKF,CAAI,CACxB,CACF,EAEMG,EAAN,KAAe,CAOb,OAAO,SAASC,EAAQ5E,EAASb,EAAO,CAAC,EAAG,CAC1C,OAAO,IAAIwF,EAAS,EAAE,SAASC,EAAQ5E,EAASb,CAAI,CACtD,CAEA,YAAYA,EAAO,CAAC,EAAG,CACrB,KAAK,QAAU,EACf,KAAK,aAAeA,EAAK,gBAAkB,EAC3C,GAAM,CAAE,UAAA0F,EAAW,OAAAC,CAAO,EAAIvH,EAAU,KAAK,YAAY,EACzD,KAAK,QAAUsH,EAAU,QACzB,KAAK,QAAUA,EAAU,QAEzB,IAAME,EAASF,EAAU,QAAQ,OAASA,EAAU,QAAQ,QACtDG,EAAOH,EAAU,QAAQ,YACzBI,EAAQJ,EAAU,QAAQ,aAEhC,KAAK,YAAc,IAAI,OAAO,KAAKE,qCAA2C,GAAG,EACjF,KAAK,YAAc,IAAI,OAAO,KAAKA,kCAAuC,EAC1E,KAAK,aAAe,IAAI,OAAO,IAAMC,EAAO,KAAOA,EAAOC,EAAQ,KAAOA,EAAQ,GAAG,EAEpF,KAAK,UAAY,IAAI,OAAO,IAAI,KAAK,QAAQ,QAAQ,QAAQ,IAAK,EAAE,IAAI,EACxE,KAAK,WAAa,IAAI,OAAO,KAAK,QAAQ,aAAe,UAAW,GAAG,EACvE,KAAK,aAAe,6CACpB,KAAK,YAAc,IAAI,OAAO,IAAIF,IAAS,EAE3C,KAAK,OAAS,GACd,KAAK,MAAQ,IAAI1H,EAAMyH,CAAM,EAC7B,KAAK,OAAS,IAAI7F,EAAe6F,CAAM,EACvC,KAAK,KAAO3F,EAAK,MAAQ,CACvB,QAAS,EACT,MAAQxB,GAAM,KAAK,MAAM,KAAK,OAAO,EAAIA,CAAC,CAC5C,CACF,CAEA,IAAIwB,EAAM,CACR,GAAI,CAACA,EAAK,MAAO,MAAM,MAAM,UAAU,EACvC,IAAM+F,EAAY,KAAK,MAAM,SAAS/F,EAAK,KAAK,EAChD,GAAI+F,EAAU,OAAO,OACnB,cAAQ,MAAM,UAAY/F,EAAK,MAAQ;AAAA,EAAM+F,EAAU,OAAO,CAAC,EAAE,OAAO,EAClE,MAAM,YAAcA,EAAU,OAAO,CAAC,EAAE,OAAO,EAEnD/F,EAAK,OAAO,KAAK,YAAY+F,EAAU,MAAM,EACjD/F,EAAK,OAAS+F,EAAU,MAE1B,CAEA,MAAM/F,EAAM,CACVA,EAAK,IAAM,KAAK,OAAO,MAAMA,CAAI,CACnC,CAEA,MAAMA,EAAM,CACV,OAAO,KAAK,QAAQ,MAAMA,CAAI,CAChC,CAEA,cAAcA,EAAO,CAAC,EAAG,CACvB,YAAK,IAAIA,CAAI,EACb,KAAK,MAAMA,CAAI,EACR,KAAK,MAAMA,CAAI,CACxB,CAEA,SAASyF,EAAQ5E,EAASb,EAAO,CAAC,EAAG,CACnC,GAAI,OAAOyF,GAAW,SACpB,MAAM,MAAM,6CAA+C,OAAOA,CAAM,EAE1E,OAAAzF,EAAK,MAAQyF,EACbzF,EAAK,QAAU,IAAIY,EAAgB,KAAMC,CAAO,EACzC,KAAK,UAAUb,CAAI,CAC5B,CAEA,UAAUA,EAAM,CACd,GAAM,CAAE,MAAAgG,CAAM,EAAIhG,EAIdiG,EAAMC,EAAc,SAAS,KAAKF,CAAK,EAEvC3C,EAAO,KAAK,SAAS2C,EAAOhG,CAAI,EACpC,GAAI,CAACqD,EAAM,MAAO,GAOlB,GALIrD,EAAK,OAAO,QAAQ,IAAI;AAAA,WAAcwF,EAAS,YAAYQ,CAAK,IAAI,EACpEhG,EAAK,OAASgG,IAAU3C,GAC1B,QAAQ,IAAI,YAAYmC,EAAS,YAAYnC,CAAI,IAAI,EAGnD,CAACrD,EAAK,QAAS,MAAM,MAAM,YAAY,EAC3C,KAAK,QAAUA,EAAK,QACpB,OAAOA,EAAK,QAEZ,QAAS8D,EAAI,EAAGT,IAAS4C,GAAQnC,GAAK,KACpCmC,EAAO5C,EAEHrD,EAAK,OAAO,QAAQ,IAAI,IAAI,OAAO,EAAE,EAAI,SAAW8D,EAAI,IAAM,IAAI,OAAO,EAAE,CAAC,EAEhF9D,EAAK,MAAQqD,EACbA,EAAO,KAAK,cAAcrD,CAAI,EAE1BA,EAAK,OACP,QAAQ,IAAI,UAAU8D,UAAe0B,EAAS,YAAYnC,CAAI,UAClD,KAAK,QAAQ,gBAAgB,GAAG,EAI1C,EAAArD,EAAK,SAAW,CAAC,KAAK,YAAYqD,CAAI,IAdFS,IAcxC,CAIF,MAAI,CAAC,KAAK,QAAU,CAAC,KAAK,KAAK,QACzB,KAAK,YAAY,KAAKT,EAAK,QAAQ0B,EAAc,EAAE,CAAC,GACtD,QAAQ,KAAK,mCAAqC1B,EAAK,QAAQ,MAAO,KAAK,EAAI,IAAI,EAIhF,KAAK,UAAUA,EAAMrD,CAAI,GAAKkG,EAAc;AAAA,EAAO,GAC5D,CAEA,OAAOC,EAAUnG,EAAM,CACrB,OAAO,IAAIgF,EAAQ,KAAMmB,EAAUnG,CAAI,CACzC,CAEA,YAAY2F,EAAQ,CAClB,IAAI/F,EAAI+F,EAAO,OAAO,CAACS,EAAKhG,IAAM,CAChC,GAAI,CAAE,KAAAM,CAAK,EAAIN,EAAE,UACbiG,EAAM3F,EACV,OAAI2F,IAAQ,SAAQA,EAAMb,EAAS,YAAYpF,EAAE,MAAO,CAAC,GACrDiG,IAAQ,QAAOA,EAAM,OAASjG,EAAE,MAAQ,KACxCiG,IAAQ,OAAMA,EAAM,MAAQjG,EAAE,MAAQ,KACnCgG,EAAMC,EAAM,IACrB,EAAG,EAAE,EACF,MAAM,EAAG,EAAE,EACd,QAAQ,IAAI;AAAA,YAAiBzG,EAAI,eAC/B,KAAK,QAAQ,gBAAgB,CAAC,CAClC,CAEA,UAAUoG,EAAOhG,EAAM,CACrB,GAAI,OAAOgG,GAAU,SAAU,MAAO,GAMtC,IAAItE,EAHUkD,EAAOoB,CAAK,EAGL,QAAQ,KAAK,aAAc,GAAG,EAAE,QAAQ,SAAU,EAAE,EAIzE,MADY,CAAC,GAAGtE,EAAO,SAAS,KAAK,QAAQ,eAAe,CAAC,EACvD,QAAS4E,GAAM,CACnB,GAAI,CAACA,GAAK,CAACA,EAAE,CAAC,GAAK,CAACA,EAAE,CAAC,EAAG,MAAM,MAAM,aAAeA,CAAC,EACtD,IAAIC,EAAe,KAAK,QAAQ,aAAaD,EAAE,CAAC,CAAC,EAC7C,CAAE,gBAAAE,EAAiB,SAAAhF,CAAS,EAAI+E,EACpC,GAAI,CAAC/E,EAAS,OAAQ,MAAM,MAAM,aAAa,EAC/C,IAAIiF,EAAS,KAAK,QAAQ,OAAOD,EAAiB,CAAE,YAAa,EAAK,CAAC,EAEvE9E,EAASA,EAAO,QAAQ4E,EAAE,CAAC,EAAGG,CAAM,EAChCzG,EAAK,OAAO,QAAQ,IAAI,KAAOsG,EAAE,CAAC,EAAI,MAAQG,CAAM,CAC1D,CAAC,EAEGzG,EAAK,OAAO,QAAQ,IAAI;AAAA,UAAa0B,IAAS,EAE7C1B,EAAK,kBAER,KAAK,QAAQ,QAAU,OACvB,KAAK,QAAQ,SAAW,QAGnB0B,CACT,CAEA,SAAS+D,EAAQzF,EAAM,CACrB,GAAI,OAAOyF,GAAW,SAAU,MAAO,GAEvC,IAAMvF,EAAI,KAAK,QAEX8F,EAAQP,EACP,KAAK,eAERO,EAAQA,EAAM,QAAQ,mBAAoB,MAAM,GAGlDA,EAAQA,EAAM,QAAQ,uBAAwB,EAAE,EAChDA,EAAQA,EAAM,QAAQ,uBAAwB,EAAE,EAChDA,EAAQA,EAAM,QAAQ,KAAK,WAAY,EAAE,EACzCA,EAAQU,EAAuBV,CAAK,EAEpC,IAAItE,EAAS,GACTiF,EAAQX,EAAM,MAAM,OAAO,EAC/B,QAASlC,EAAI,EAAGA,EAAI6C,EAAM,OAAQ7C,IAEhC,GAAiC,KAAK,YAAY,KAAK6C,EAAM7C,CAAC,CAAC,EAAG,CAEhE,IAAI8C,EAAQD,EAAM7C,CAAC,EAAE,QAAQ,GAAG,EAChC,GAAI8C,EAAQ,EAAG,MAAM,MAAM,gCAAkCD,EAAM7C,CAAC,CAAC,EACrE,IAAIb,EAAM0D,EAAM7C,CAAC,EAAE,UAAU,EAAG8C,CAAK,EACnC1D,EAAMyD,EAAM7C,CAAC,EAAE,UAAU8C,EAAQ,CAAC,EAChCC,EAAQC,EAAU5D,EAAKhD,EAAE,WAAW,EACpC6G,EAASD,EAAU5D,EAAKhD,EAAE,YAAY,EAC1C,KAAO2G,EAAQE,GAAQ,CACrB,IAAIC,EAAOL,EAAM,EAAE7C,CAAC,EACpBZ,GAAO;AAAA,EAAO8D,EACdH,GAASC,EAAUE,EAAM9G,EAAE,WAAW,EACtC6G,GAAUD,EAAUE,EAAM9G,EAAE,YAAY,EAE1CwB,GAAUxB,EAAE,aAAe+C,EAAM,IAAMC,GAAOhD,EAAE,kBAEhDwB,GAAUiF,EAAM7C,CAAC,EACbA,EAAI6C,EAAM,OAAS,IAAGjF,GAAU;AAAA,GAIxC,OAAOA,CACT,CAKA,UAAUuF,EAAM,CACd,IAAMC,EAAyBD,GAAS,CAEtC,IAAIE,EAAMF,EACV,GACE,OAAOA,GAAS,UAChBA,EAAK,WAAWnC,CAAW,GAC3BmC,EAAK,SAASnC,CAAW,EACzB,CACA,IAAIsC,EAAQH,EAAK,MAAMnC,CAAW,EAClC,GAAIsC,EAAM,SAAW,EAAG,MAAM,MAAM,2BAA2B,EAC/DD,EAAM,IAAI,OAAOC,EAAM,CAAC,EAAGA,EAAM,CAAC,CAAC,EAErC,OAAOD,CACT,EACIE,EAAU7B,EAAS,iBAAiByB,CAAI,EACzC,QAAQ,KAAK,YAAa,OAAO,EACjC,QAAQ,KAAM,GAAG,EAIhBvF,EAAS,KAAK,MAAM2F,CAAO,EAC7BC,EAAMJ,EACR,cAAO,KAAKxF,CAAM,EAAE,QAASlD,GAAOkD,EAAOlD,CAAC,EAAI8I,EAAI5F,EAAOlD,CAAC,CAAC,CAAE,EACxDkD,CACT,CAEA,YAAY9B,EAAG,CAEb,IAAI8B,EAAS,GAGb,MAFiB,kBAAkB,KAAK,OAAO9B,CAAC,IAEhC8B,EAAS,KAAK,UAAU,KAAK9B,EAAE,SAAS,CAAC,GAClD8B,CACT,CAMA,OAAO,UAAU9B,EAAG,CAClB,GAAI,CAACA,GAAK,CAACA,EAAE,OAAQ,MAAO,GAE5B,IAAI2H,EAAQ3H,EAAE,MAAM,KAAK,EAAE,CAAC,EAE5B,GAAI,CAAC4F,EAAS,MAAM,OAClB,OAAKA,EAAS,aAAa,SACzB,QAAQ,KAAK,yCAAyC,EACtDA,EAAS,aAAa,OAAS,KAGzB,cAAc,KAAK+B,CAAK,EAAI,MAAQ,MAAQ3H,EAGtD,IAAI4H,EAAShC,EAAS,KAAK,OAAO+B,EAAO,CAAE,OAAQ,EAAK,CAAC,EAGzD,OACGC,GAAUA,EAAO,QAAU3C,EAAQ,KAAK2C,EAAO,CAAC,CAAC,EAAI,MAAQ,MAAQ5H,CAE1E,CAGA,OAAO,WAAWA,EAAG,CACnB,OAAOA,EAAIA,EAAE,CAAC,EAAE,YAAY,EAAIA,EAAE,UAAU,CAAC,EAAI,EACnD,CAGA,OAAO,UAAUA,EAAG,CAClB,OAAOA,EAAIA,EAAE,YAAY,EAAI,EAC/B,CAGA,OAAO,QAAQA,EAAG,CAChB,MAAO,WAAaA,GAAK,IAAM,SACjC,CAGA,OAAO,UAAUA,EAAG,CAClB,OAAK4F,EAAS,MAAM,UAObA,EAAS,KAAK,UAAU5F,CAAC,GANzB4F,EAAS,aAAa,UACzBA,EAAS,aAAa,QAAU,GAChC,QAAQ,KAAK,8CAA8C,GAEtD5F,EAAE,SAAS,GAAG,EAAIA,EAAIA,EAAI,IAGrC,CAGA,OAAO,SAASA,EAAG,CACjB,OAAOA,CACT,CAIA,OAAO,gBAAgBiE,EAAK,CAC1B,OAAOA,GAAOA,EAAI,OACdA,EAAI,IAAKE,GAAOA,EAAG,MAAM,QAAQ,eAAgB,EAAE,EAAG,CAAC,CAAC,EACxD,CAAC,CACP,CAEA,OAAO,YAAYnE,EAAG6H,EAAS,CAC7B,GAAI,OAAO7H,GAAM,SAAU,OAAOA,EAClC,IAAIQ,EAAIR,EAAE,QAAQ,SAAU,KAAK,EACjC,OAAO6H,GAAW,CAACrH,EAAE,OAAS,IAAMA,EAAI,IAAMA,CAChD,CAEA,OAAO,iBAAiB6G,EAAM,CAC5B,OAAOA,EAAK,QACV,2BACA,IAAInC,MAAgBA,MAAgBA,IACtC,CACF,CAEA,OAAO,YAAYlF,EAAG,CACpB,IAAI8H,EACFC,EAAO,EACT,QAAS7D,EAAI,EAAGA,EAAIlE,EAAE,OAAQkE,IAC5B4D,EAAM9H,EAAE,WAAWkE,CAAC,EACpB6D,GAAQA,GAAQ,GAAKA,EAAOD,EAC5BC,GAAQ,EAEV,IAAIC,EAAUD,EAAK,SAAS,EAC5B,OAAOA,EAAO,EAAIC,EAAQ,QAAQ,IAAK,GAAG,EAAIA,CAChD,CACF,EAzVMC,EAANrC,EACEsC,EADID,EACG,QAAQ7C,GAEf8C,EAHID,EAGG,UAAU,sBAEjBC,EALID,EAKG,eAAe,CAAE,QAAS,GAAO,OAAQ,EAAM,GAwVxDA,EAAS,WAAa,CACpB,QAASA,EAAS,QAClB,UAAWA,EAAS,UACpB,WAAYA,EAAS,WACrB,UAAWA,EAAS,UACpB,UAAWA,EAAS,UAGpB,SAAUA,EAAS,SAGnB,IAAKA,EAAS,UACd,GAAIA,EAAS,SACb,IAAKA,EAAS,WACd,IAAKA,EAAS,WACd,GAAIA,EAAS,UACb,GAAIA,EAAS,QACb,EAAGA,EAAS,SACd,EAIA,SAASnB,EAAuB9G,EAAG,CACjC,OAAAA,EAAImI,EAAWnI,EAAG,MAAO,QAAQ,EACjCA,EAAImI,EAAWnI,EAAG,MAAO,QAAQ,EACjCA,EAAImI,EAAWnI,EAAG,MAAO,QAAQ,EACjCA,EAAImI,EAAWnI,EAAG,MAAO,QAAQ,EACjCA,EAAImI,EAAWnI,EAAG,MAAO,QAAQ,EACjCA,EAAImI,EAAWnI,EAAG,MAAO,QAAQ,EACjCA,EAAImI,EAAWnI,EAAG,MAAO,UAAU,EACnCA,EAAImI,EAAWnI,EAAG,MAAO,OAAO,EAChCA,EAAImI,EAAWnI,EAAG,MAAO,QAAQ,EACjCA,EAAImI,EAAWnI,EAAG,MAAO,UAAU,EAC5BA,CACT,CACA,SAASoI,EAAaC,EAAQ,CAC5B,OAAOA,EAAO,QAAQ,sBAAuB,MAAM,CACrD,CACA,SAASF,EAAW3B,EAAK8B,EAAOC,EAAa,CAC3C,OAAO/B,EAAI,QAAQ,IAAI,OAAO4B,EAAaE,CAAK,EAAG,GAAG,EAAG,IAAMC,CAAW,CAC5E,CACA,SAASrB,EAAUV,EAAKlF,EAAG,CACzB,IAAIH,EAAQ,EACZ,QAAS+C,EAAI,EAAGA,EAAIsC,EAAI,OAAQtC,IAC1BsC,EAAItC,CAAC,IAAM5C,GAAGH,IAEpB,OAAOA,CACT,CI5cA,IAAMqH,EAAN,KAAgB,CAEd,YAAYC,EAAQ,CAAC,EAAGxH,EAAU,CAAC,EAAG,CACpC,GAAI,OAAOwH,GAAU,SACnB,MAAM,MAAM,sCAAwC,OAAOA,CAAK,EAGlE,KAAK,UAAY,IAAIR,EACrB,KAAK,QAAUhH,EACf,KAAK,SAASwH,CAAK,CACrB,CAEA,OAAO,OAAOA,EAAOxH,EAASb,EAAM,CAClC,OAAO,IAAIoI,EAAUC,EAAOxH,CAAO,EAAE,OAAOb,CAAI,CAClD,CAEA,cAAe,CACb,OAAO6H,EAAS,aAAa,GAAG,SAAS,CAC3C,CACA,iBAAkB,CAChB,OAAOA,EAAS,gBAAgB,GAAG,SAAS,CAC9C,CACA,eAAgB,CACd,OAAOA,EAAS,UAClB,CAEA,OAAOS,EAAI,CACT,OAAOA,EAAG,OAAO,IAAM,KAAK,OAAO,CACrC,CAEA,OAAOtI,EAAO,CAAC,EAAG,CAChB,GAAI,YAAaA,EACf,MAAM,MAAM,+DAA+D,EAI7E,OAAAA,EAAK,QAAUA,EAAK,SAAW,IAAI6H,EAAS,QAAQ,KAAK,SAAS,EAClE7H,EAAK,QAAQ,QAAU,KAAK,SAAW,CAAC,EACxCA,EAAK,MAAQ,KAAK,UAAUA,CAAI,EAGzB,KAAK,UAAU,UAAUA,CAAI,CACtC,CAEA,QAAQU,EAAM6H,EAAK,CACjB,KAAK,cAAc7H,EAAM6H,CAAG,EAC5B,KAAK,MAAM7H,CAAI,EAAI6H,CACrB,CAEA,SAASF,EAAO,CACd,GAAI,OAAOA,EAAU,IAAa,MAAM,MAAM,iBAAiB,EAC/D,KAAK,MAAQ,CAAC,EACd,IAAIG,EAAW,OAAOH,GAAU,SAAWI,EAAUJ,CAAK,EAAIA,EAC1DK,EAAO,KACX,OAAO,QAAQF,CAAQ,EAAE,QAASnH,GAAMqH,EAAK,QAAQ,GAAGrH,CAAC,CAAC,CAC5D,CAEA,WAAWX,EAAM,CACXA,KAAQ,KAAK,OACf,OAAO,KAAK,MAAMA,CAAI,CAE1B,CAEA,QAAS,CACP,OAAO,KAAK,UAAU,KAAK,MAAO,GAAG,SAAS,CAChD,CAEA,SAASV,EAAO,CAAC,EAAG,CAClB,IAAI2I,EAAW3I,EAAK,UAAY,EAC5B4I,EAAQ5I,EAAK,OAAS,EACtB6I,EAAK7I,GAAM,UACXmH,EAAM,KAAK,OAAOwB,EAAUC,CAAK,EACrC,OAAIC,IAAI1B,EAAMA,EAAI,QAAQ,MAAO0B,CAAE,GAC5B1B,CACT,CAEA,OAAO,SAASf,EAAKpG,EAAM,CACzB,OAAO,IAAIoI,EAAU,KAAK,MAAMhC,CAAG,EAAGpG,CAAI,CAC5C,CAMA,UAAUA,EAAM,CACd,IAAIyF,EAAS,GACXqD,EAAQ9I,EAAK,OAAS,QACpB,CAAE,QAAA1B,CAAQ,EAAI,KAAK,UAUvB,GARIwK,EAAM,WAAWxK,EAAQ,OAAO,IAClCwK,EAAQA,EAAM,UAAUxK,EAAQ,QAAQ,MAAM,GAG5CwK,EAAM,WAAWxK,EAAQ,MAAM,IACjCwK,EAAQA,EAAM,UAAUxK,EAAQ,OAAO,MAAM,GAG3C,EAAEwK,KAAS,KAAK,OAASxK,EAAQ,OAASwK,KAAS,KAAK,OAC1D,MAAM,MAAM,UAAYA,EAAQ,wBAAwB,EAG1D,cAAO,QAAQ,KAAK,KAAK,EAAE,QAAQ,CAAC,CAACpI,EAAMqI,CAAI,EAAGjF,IAAM,CACtD,KAAOpD,EAAK,WAAWpC,EAAQ,OAAO,GACpCoC,EAAOA,EAAK,UAAU,CAAC,EAEpBA,EAAK,WAAWpC,EAAQ,MAAM,IACjCoC,EAAOpC,EAAQ,QAAUoC,GAGtB,KAAK,UAAU,aAAa,KAAKqI,CAAI,IAExCA,EAAOzK,EAAQ,YAAcyK,EAAOzK,EAAQ,cAG9CmH,GAAU,GAAG/E,KAAQqI;AAAA,CACvB,CAAC,EAEG/I,EAAK,OAAO,QAAQ,IAAI;AAAA,EAAeyF,EAAO,QAAQ,QAAS,KAAK,CAAC,EAEzEA,GAAU,GAAGnH,EAAQ,UAAUwK,IACxBrD,CACT,CAEA,cAAc/E,EAAM6H,EAAK,CACvB,GAAI,OAAO7H,GAAS,UAAYA,EAAK,SAAW,EAC9C,MAAM,MAAM,wBAAwB,EAGtC,GAAI,OAAO6H,EAAQ,IACjB,MAAM,MAAM,uBAAyB7H,CAAI,EAE3C,GAAI,CAAE,QAAApC,CAAQ,EAAI,KAAK,UAEvB,GAAIoC,EAAK,WAAWpC,EAAQ,OAAO,EACjC,MAAAoC,EAAOA,EAAK,UAAUpC,EAAQ,QAAQ,MAAM,EACtC,MACJ,yEAEEA,EAAQ,OACRoC,EACA,0BACAA,EACA,IACJ,CAEJ,CACF,EAEA,SAAS+H,EAAUO,EAAM,CACvB,GAAI,OAAOA,GAAS,SAClB,GAAI,CACF,OAAO,KAAK,MAAMA,CAAI,CACxB,MAAE,CACA,MAAM,MACJ;AAAA,EAEEA,CACJ,CACF,CAEJ,CC9JAnB,EAAS,QAAUO,EACnBP,EAAS,QAAUjH,EAEnB,IAAOqI,GAAQpB","sourcesContent":["import he from 'he';\nimport { Query } from 'mingo';\nimport { Lexer } from 'chevrotain';\n\nimport { getTokens } from './tokens.js';\nimport { RiScriptParser } from './parser.js';\nimport { RiScriptVisitor } from './visitor.js';\n\n/*\n  Specification:\n    script: expr+\n    expr: (atom)+\n    wexpr: (atom)+ weight\n    symbol: SYM transform*\n    assign: SYM EQ expr transform*\n    gate: @mingo@\n    silent: { gate? expr }\n    atom: (choice | symbol | text | silent) weight?\n    choice: [ gate? ( expr | wexpr ) (OR  (expr | wexpr ) )* else? ] transform*\n    else: ELSE expr\n    raw: Raw\n*/\n\n// TODO: integrate with rita, test node-packages, linting, coverage?\n\nconst { decode } = he;\nconst VowelRE = /[aeiou]/;\nconst RegexEscape = '_RE_';\nconst HtmlEntities = /&([a-z0-9]+|#[0-9]{1,6}|#x[0-9a-fA-F]{1,6});/gi;\n\nclass RiQuery extends Query {\n  constructor(scripting, condition, options) {\n    if (typeof condition === 'string') {\n      let raw = condition; // eslint-disable-line\n      condition = scripting.parseJSOL(condition);\n      // console.log('RAW: ', raw, 'parsed', condition);\n    }\n    super(condition, options);\n  }\n\n  test(obj) {\n    for (let i = 0, len = this.compiled.length; i < len; i++) {\n      if (!this.compiled[i](obj)) return false;\n    }\n    return true;\n  }\n\n  operands() {\n    const stack = [this.condition];\n    const keys = new Set();\n    while (stack?.length > 0) {\n      const currentObj = stack.pop();\n      Object.keys(currentObj).forEach((key) => {\n        const value = currentObj[key];\n        // console.log(`key: ${ key }, value: ${ value } `);\n        if (!key.startsWith('$')) keys.add(key);\n        if (typeof value === 'object' && value !== null) {\n          const eles = Array.isArray(value) ? value : [value];\n          eles.forEach((ele) => stack.push(ele));\n        }\n      });\n    }\n    return Array.from(keys);\n  }\n}\n\nclass RiScript {\n  static Query = RiQuery;\n\n  static VERSION = '[VI]{version}[/VI]';\n\n  static RiTaWarnings = { plurals: false, phones: false };\n\n  static evaluate(script, context, opts = {}) {\n    return new RiScript().evaluate(script, context, opts);\n  }\n\n  constructor(opts = {}) { // private ?\n    this.visitor = 0; // created in evaluate() or passed in here\n    this.v2Compatible = opts.compatibility === 2;\n    const { Constants, tokens } = getTokens(this.v2Compatible);\n    this.Escaped = Constants.Escaped;\n    this.Symbols = Constants.Symbols;\n\n    const anysym = Constants.Escaped.STATIC + Constants.Escaped.DYNAMIC;\n    const open = Constants.Escaped.OPEN_CHOICE;\n    const close = Constants.Escaped.CLOSE_CHOICE;\n\n    this.JSOLIdentRE = new RegExp(`([${anysym}]?[A-Za-z_0-9][A-Za-z_0-9]*)\\\\s*:`, 'g');\n    this.RawAssignRE = new RegExp(`^[${anysym}][A-Za-z_0-9][A-Za-z_0-9]*\\\\s*=`);\n    this.ChoiceWrapRE = new RegExp('^' + open + '[^' + open + close + ']*' + close + '$');\n\n    this.SpecialRE = new RegExp(`[${this.Escaped.SPECIAL.replace('&', '')}]`);\n    this.ContinueRE = new RegExp(this.Escaped.CONTINUATION + '\\\\r?\\\\n', 'g');\n    this.WhitespaceRE = /[\\u00a0\\u2000-\\u200b\\u2028-\\u2029\\u3000]+/g;\n    this.AnySymbolRE = new RegExp(`[${anysym}]`); // added\n\n    this.silent = false;\n    this.lexer = new Lexer(tokens);\n    this.parser = new RiScriptParser(tokens);\n    this.RiTa = opts.RiTa || {\n      VERSION: 0,\n      randi: (k) => Math.floor(Math.random() * k),\n    }\n  }\n\n  lex(opts) {\n    if (!opts.input) throw Error('no input');\n    const lexResult = this.lexer.tokenize(opts.input);\n    if (lexResult.errors.length) {\n      console.error('Input: ' + opts.input + '\\n', lexResult.errors[0].message);\n      throw Error('[LEXING] ' + lexResult.errors[0].message);\n    }\n    if (opts.trace) this.printTokens(lexResult.tokens);\n    opts.tokens = lexResult.tokens;\n    // return lexResult;\n  }\n\n  parse(opts) {\n    opts.cst = this.parser.parse(opts);\n  }\n\n  visit(opts) {\n    return this.visitor.start(opts);\n  }\n\n  lexParseVisit(opts = {}) {\n    this.lex(opts);\n    this.parse(opts);\n    return this.visit(opts);\n  }\n\n  evaluate(script, context, opts = {}) {\n    if (typeof script !== 'string') {\n      throw Error('RiScript.evaluate() expects a string, got ' + typeof script);\n    }\n    opts.input = script;\n    opts.visitor = new RiScriptVisitor(this, context);\n    return this._evaluate(opts);\n  }\n\n  _evaluate(opts) {\n    const { input } = opts;\n\n    // opts.onepass = true; // TMP\n\n    let last, endingBreak = /\\r?\\n$/.test(input); // keep\n\n    let expr = this.preParse(input, opts);\n    if (!expr) return '';\n\n    if (opts.trace) console.log(`\\nInput:  '${RiScript._escapeText(input)}'`);\n    if (opts.trace && input !== expr) {\n      console.log(`Parsed: '${RiScript._escapeText(expr)}'`);\n    }\n\n    if (!opts.visitor) throw Error('no visitor');\n    this.visitor = opts.visitor;\n    delete opts.visitor; // remind me why\n\n    for (let i = 1; expr !== last && i <= 10; i++) {\n      last = expr;\n\n      if (opts.trace) console.log('-'.repeat(20) + ' Pass#' + i + ' ' + '-'.repeat(20));\n\n      opts.input = expr;\n      expr = this.lexParseVisit(opts); // do it\n\n      if (opts.trace) {\n        console.log(`Result(${i}) -> \"` + `${RiScript._escapeText(expr)}\"`\n          + ` ctx=${this.visitor.lookupsToString()}`);\n      }\n\n      // end if no more riscript\n      if (opts.onepass || !this.isParseable(expr)) break;\n    }\n\n    // check for unresolved symbols ([$#]) after removing HTML entities\n    if (!this.silent && !this.RiTa.SILENT) {\n      if (this.AnySymbolRE.test(expr.replace(HtmlEntities, ''))) {\n        console.warn('[WARN] Unresolved symbol(s) in \"' + expr.replace(/\\n/g, '\\\\n') + '\" ');\n      }\n    }\n\n    return this.postParse(expr, opts) + (endingBreak ? '\\n' : '');\n  }\n\n  _query(rawQuery, opts) {\n    return new RiQuery(this, rawQuery, opts);\n  }\n\n  printTokens(tokens) {\n    let s = tokens.reduce((str, t) => {\n      let { name } = t.tokenType;\n      let tag = name;\n      if (tag === 'TEXT') tag = RiScript._escapeText(t.image, 1);\n      if (tag === 'SYM') tag = 'sym(' + t.image + ')';\n      if (tag === 'TX') tag = 'tx(' + t.image + ')';\n      return str + tag + ', ';\n    }, '')\n      .slice(0, -2);\n    console.log('\\nTokens: [ ' + s + ' ]  Context:',\n      this.visitor.lookupsToString());\n  }\n\n  postParse(input, opts) {\n    if (typeof input !== 'string') return '';\n\n    // replace html entities\n    let decoded = decode(input);\n\n    // clean up whitespace, linebreaks\n    let result = decoded.replace(this.WhitespaceRE, ' ').replace(/\\r?\\n$/, '');\n\n    // handle unresolved gates\n    let gates = [...result.matchAll(this.Symbols.PENDING_GATE_RE)];\n    gates.forEach((g) => {\n      if (!g || !g[0] || !g[1]) throw Error('bad gate: ' + g);\n      let deferredGate = this.visitor.pendingGates[g[1]];\n      let { deferredContext, operands } = deferredGate;\n      if (!operands.length) throw Error('no operands');\n      let reject = this.visitor.choice(deferredContext, { forceReject: true });\n\n      result = result.replace(g[0], reject);\n      if (opts.trace) console.log('  ' + g[0] + '-> ' + reject);\n    });\n\n    if (opts.trace) console.log(`\\nFinal: '${result}'`);\n\n    if (!opts.preserveLookups) {\n      // reset lookups unless preserveLookups=true (for testing only)\n      this.visitor.statics = undefined;\n      this.visitor.dynamics = undefined;\n    }\n\n    return result;\n  }\n\n  preParse(script, opts) {\n    if (typeof script !== 'string') return '';\n\n    const $ = this.Symbols;\n\n    let input = script;\n    if (!this.v2Compatible) {\n      // handle parenthesized weights ??\n      input = input.replace(/\\((\\s*\\d+\\s*)\\)/g, '^$1^');\n    }\n\n    input = input.replace(/\\/\\*[^]*?(\\r?\\n)?\\//g, ''); // multi-line comments\n    input = input.replace(/\\/\\/[^\\n]+(\\r?\\n|$)/g, ''); // single-line comments\n    input = input.replace(this.ContinueRE, ''); // line continuations\n    input = slashEscapesToEntities(input); // double-backslashed escapes\n\n    let result = '';\n    let lines = input.split(/\\r?\\n/);\n    for (let i = 0; i < lines.length; i++) {\n      // special-case: handle assignments alone on a line\n      if (/*!opts.noAddedSilence && */ this.RawAssignRE.test(lines[i])) {\n        // a very convoluted way of preserving line-breaks inside groups\n        let eqIdx = lines[i].indexOf('=');\n        if (eqIdx < 0) throw Error('invalid state: no assigment: ' + lines[i]);\n        let lhs = lines[i].substring(0, eqIdx),\n          rhs = lines[i].substring(eqIdx + 1);\n        let opens = charCount(rhs, $.OPEN_CHOICE);\n        let closes = charCount(rhs, $.CLOSE_CHOICE);\n        while (opens > closes) {\n          let line = lines[++i];\n          rhs += '\\n' + line;\n          opens += charCount(line, $.OPEN_CHOICE);\n          closes += charCount(line, $.CLOSE_CHOICE);\n        }\n        result += $.OPEN_SILENT + (lhs + '=' + rhs) + $.CLOSE_SILENT;\n      } else {\n        result += lines[i];\n        if (i < lines.length - 1) result += '\\n';\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Parses a mingo query into JSON format\n   */\n  parseJSOL(text) {\n    const unescapeRegexProperty = (text) => {\n      // TODO: why do we need this?\n      let res = text;\n      if (\n        typeof text === 'string' &&\n        text.startsWith(RegexEscape) &&\n        text.endsWith(RegexEscape)\n      ) {\n        let parts = text.split(RegexEscape);\n        if (parts.length !== 4) throw Error('invalid regex in unescape');\n        res = new RegExp(parts[1], parts[2]);\n      }\n      return res;\n    };\n    let escaped = RiScript._escapeJSONRegex(text)\n      .replace(this.JSOLIdentRE, '\"$1\":')\n      .replace(/'/g, '\"');\n\n    // console.log(\"escaped: '\"+escaped+\"'\");\n\n    let result = JSON.parse(escaped),\n      urp = unescapeRegexProperty;\n    Object.keys(result).forEach((k) => (result[k] = urp(result[k])));\n    return result;\n  }\n\n  isParseable(s) {\n    // conservatively assume non-string/numbers are always parseable\n    let result = true;\n    let isStrOrNum = /(string|number)/.test(typeof s);\n    // if a string or num, test for special chars\n    if (isStrOrNum) result = this.SpecialRE.test(s.toString());\n    return result;\n  }\n\n  // ========================= statics ===============================\n\n\n  // Default transform that adds an article\n  static articlize(s) {\n    if (!s || !s.length) return '';\n\n    let first = s.split(/\\s+/)[0];\n\n    if (!RiScript.RiTa?.phones) {\n      if (!RiScript.RiTaWarnings.phones) {\n        console.warn('[WARN] Install RiTa for proper phonemes');\n        RiScript.RiTaWarnings.phones = true;\n      }\n      // first.startsWith('a') ? 'an ' : 'a ') + s;\n      return (/^[aeiou].*/i.test(first) ? 'an ' : 'a ') + s;\n    }\n\n    let phones = RiScript.RiTa.phones(first, { silent: true });\n\n    // could still be original word if no phones found\n    return (\n      (phones && phones.length && VowelRE.test(phones[0]) ? 'an ' : 'a ') + s\n    );\n  }\n\n  // Default transform that capitalizes the first character\n  static capitalize(s) {\n    return s ? s[0].toUpperCase() + s.substring(1) : '';\n  }\n\n  // Default transform that capitalizes the string\n  static uppercase(s) {\n    return s ? s.toUpperCase() : '';\n  }\n\n  // Default transform that wraps the string in (smart) quotes.\n  static quotify(s) {\n    return '&#8220;' + (s || '') + '&#8221;';\n  }\n\n  // Default transform that pluralizes a string (requires RiTa)\n  static pluralize(s) {\n    if (!RiScript.RiTa?.pluralize) {\n      if (!RiScript.RiTaWarnings.plurals) {\n        RiScript.RiTaWarnings.plurals = true;\n        console.warn('[WARN] Install RiTa for proper pluralization');\n      }\n      return s.endsWith('s') ? s : s + 's';\n    }\n    return RiScript.RiTa.pluralize(s);\n  }\n\n  // Default no-op transform\n  static identity(s) {\n    return s;\n  }\n\n  // static helpers\n\n  static _transformNames(txs) {\n    return txs && txs.length\n      ? txs.map((tx) => tx.image.replace(/(^\\.|\\(\\)$)/g, ''), [])\n      : [];\n  }\n\n  static _escapeText(s, quotify) {\n    if (typeof s !== 'string') return s;\n    let t = s.replace(/\\r?\\n/g, '\\\\n');\n    return quotify || !t.length ? \"'\" + t + \"'\" : t;\n  }\n\n  static _escapeJSONRegex(text) {\n    return text.replace(\n      /\\/([^/]+?)\\/([igmsuy]*)/g,\n      `\"${RegexEscape}$1${RegexEscape}$2${RegexEscape}\"`\n    );\n  }\n\n  static _stringHash(s) {\n    let chr,\n      hash = 0;\n    for (let i = 0; i < s.length; i++) {\n      chr = s.charCodeAt(i);\n      hash = (hash << 5) - hash + chr;\n      hash |= 0; // Convert to 32bit integer\n    }\n    let strHash = hash.toString();\n    return hash < 0 ? strHash.replace('-', '0') : strHash;\n  }\n}\n\n////////////////////// STATIC PROPS ///////////////////////\n\nRiScript.transforms = {\n  quotify: RiScript.quotify,\n  pluralize: RiScript.pluralize,\n  capitalize: RiScript.capitalize,\n  articlize: RiScript.articlize,\n  uppercase: RiScript.uppercase,\n\n  // sequences\n  norepeat: RiScript.identity,\n\n  // aliases\n  art: RiScript.articlize,\n  nr: RiScript.identity,\n  cap: RiScript.capitalize,\n  ucf: RiScript.capitalize, // deprecated?\n  uc: RiScript.uppercase,\n  qq: RiScript.quotify,\n  s: RiScript.pluralize,\n};\n\n///////////////////////// FUNCTIONS /////////////////////////\n\nfunction slashEscapesToEntities(s) {\n  s = replaceAll(s, '\\\\(', '&lpar;');\n  s = replaceAll(s, '\\\\)', '&rpar;');\n  s = replaceAll(s, '\\\\[', '&lsqb;');\n  s = replaceAll(s, '\\\\]', '&rsqb;');\n  s = replaceAll(s, '\\\\{', '&lcqb;');\n  s = replaceAll(s, '\\\\}', '&rcqb;');\n  s = replaceAll(s, '\\\\@', '&commat;');\n  s = replaceAll(s, '\\\\#', '&num;');\n  s = replaceAll(s, '\\\\|', ' &vert');\n  s = replaceAll(s, '\\\\=', ' &equals');\n  return s;\n}\nfunction escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\nfunction replaceAll(str, match, replacement) {\n  return str.replace(new RegExp(escapeRegExp(match), 'g'), () => replacement);\n}\nfunction charCount(str, c) {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === c) count++;\n  }\n  return count;\n}\n\nexport { RiScript };","import { createToken } from \"chevrotain\"\n\nfunction getTokens(v2Compatible) {\n\n  let Symbols = {\n    OR: '|',\n    ELSE: '||',\n    DYNAMIC: '$',\n    STATIC: '#',\n    ENTITY: '&',\n    OPEN_GATE: '@',\n    CLOSE_GATE: '@',\n    PENDING_GATE: '@@',\n    OPEN_SILENT: '{',\n    CLOSE_SILENT: '}',\n  };\n\n  let v2Symbols = {\n    OPEN_CHOICE: '(',\n    CLOSE_CHOICE: ')',\n    OPEN_WEIGHT: '[',\n    CLOSE_WEIGHT: ']',\n    CONTINUATION: '\\\\',\n  };\n\n  let v3Symbols = {\n    OPEN_CHOICE: '[',\n    CLOSE_CHOICE: ']',\n    OPEN_WEIGHT: '^', // also allows (int), eg. (3)\n    CLOSE_WEIGHT: '^',\n    CONTINUATION: '~',\n  };\n\n  Object.assign(Symbols, v2Compatible ? v2Symbols : v3Symbols);\n\n  const Escaped = {};\n  Object.entries(Symbols).forEach(([k, v]) => { Escaped[k] = escapeRegex(v) });\n\n  const PENDING_GATE_PATTERN = new RegExp(`${Escaped.PENDING_GATE}([0-9]{9,11})`)\n\n  Escaped.SPECIAL = Object.values(Escaped).join('').replace(/[<>]/g, ''); // allow <>& for html \n  Symbols.PENDING_GATE_RE = new RegExp(PENDING_GATE_PATTERN.source, 'g'); // for unresolved gates\n\n  const ExitGate = createToken({\n    name: \"ExitGate\",\n    pattern: new RegExp(`\\\\s*${Escaped.CLOSE_GATE}`),\n    pop_mode: true\n  });\n\n  const Gate = createToken({\n    name: \"Gate\",\n    pattern: new RegExp(`[^${Escaped.CLOSE_GATE}]+`)\n  });\n\n  const PendingGate = createToken({\n    name: \"PendingGate\",\n    pattern: PENDING_GATE_PATTERN\n  });\n\n  const EnterGate = createToken({\n    name: \"EnterGate\",\n    pattern: new RegExp(`${Escaped.OPEN_GATE}\\\\s*`),\n    push_mode: \"gate_mode\"\n  });\n\n  \n  const OC = createToken({ name: \"OC\", pattern: new RegExp(Escaped.OPEN_CHOICE + '\\\\s*') });\n  const CC = createToken({ name: \"CC\", pattern: new RegExp(`\\\\s*${Escaped.CLOSE_CHOICE}`) });\n  const OR = createToken({ name: \"OR\", pattern: /\\s*\\|\\s*/ });\n  const ELSE = createToken({ name: \"ELSE\", pattern: /\\s*\\|\\|\\s*/ });\n  const EQ = createToken({ name: \"EQ\", pattern: /\\s*=\\s*/ });\n  const TF = createToken({ name: \"TF\", pattern: /\\.[A-Za-z_0-9][A-Za-z_0-9]*(\\(\\))?/ });\n  const OS = createToken({ name: \"OS\", pattern: new RegExp(`${Escaped.OPEN_SILENT}\\\\s*`) });\n  const CS = createToken({ name: \"CS\", pattern: new RegExp(`\\\\s*${Escaped.CLOSE_SILENT}`) });\n  const SYM = createToken({ name: \"SYM\", pattern: new RegExp(`[${Escaped.DYNAMIC}${Escaped.STATIC}][A-Za-z_0-9]*`) });\n\n  const Entity = createToken({ name: \"Entity\", pattern: /&([a-z0-9]+|#[0-9]{1,6}|#x[0-9a-fA-F]{1,6});/i });\n  const Weight = createToken({ name: \"Weight\", pattern: new RegExp(`\\\\s*${Escaped.OPEN_WEIGHT}.+${Escaped.CLOSE_WEIGHT}\\\\s*`) });\n  const Raw = createToken({ name: \"Raw\", pattern: new RegExp(`[^${Escaped.SPECIAL}]+`) });\n\n  const normalMode = [Entity, Weight, ELSE, OC, CC, OR, EQ, SYM, TF, OS, CS, PendingGate, Raw, EnterGate];\n  const gateMode = [Gate, ExitGate];\n\n  const multiMode = {\n    modes: {\n      normal: normalMode,\n      gate_mode: gateMode\n    },\n    defaultMode: 'normal'\n  };\n\n  return { tokens: multiMode, Constants: { Symbols, Escaped } };\n}\n\nfunction escapeRegex(s) {\n  return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n}\n\n// console.log(getTokens().tokens.modes.normal.map(t => t.name));\n\nexport { getTokens };","\nimport { CstParser } from \"chevrotain\"\n\nclass RiScriptParser extends CstParser {\n\n  constructor(allTokens) {\n    super(allTokens, { nodeLocationTracking: \"full\" });\n    this.atomTypes = ['silent', 'assign', 'symbol', 'choice', 'pgate', 'text', 'entity'];\n    this.buildRules();\n  }\n\n  parse(opts) {\n    this.input = opts.tokens; // superclass member (do not change)\n    \n    let cst = this.script();\n    if (this.errors.length > 0) throw Error\n      (\"[PARSING]\\n\" + this.errors[0].message);\n    return cst;\n  }\n\n  buildRules() {\n\n    const $ = this, Tokens = this.tokensMap;\n\n    $.RULE(\"script\", () => {\n      $.MANY(() => $.SUBRULE($.expr));\n    });\n\n    $.RULE(\"pgate\", () => {\n      $.CONSUME(Tokens.PendingGate);\n      $.MANY(() => $.CONSUME(Tokens.TF));\n    });\n\n    $.RULE(\"entity\", () => {\n      $.CONSUME(Tokens.Entity);\n    });\n\n    $.RULE(\"gate\", () => {\n      $.CONSUME(Tokens.EnterGate);\n      $.MANY(() => $.CONSUME(Tokens.Gate));\n      $.CONSUME(Tokens.ExitGate);\n    });\n\n    $.RULE(\"silent\", () => {\n      $.CONSUME(Tokens.OS);\n      $.OPTION1(() => $.SUBRULE($.gate));\n      $.CONSUME(Tokens.SYM);\n      $.OPTION2(() => {\n        $.CONSUME(Tokens.EQ);\n        $.SUBRULE($.expr);\n      });\n      $.CONSUME(Tokens.CS);\n    });\n\n    $.RULE(\"assign\", () => {\n      $.CONSUME(Tokens.SYM);\n      $.CONSUME(Tokens.EQ);\n      $.SUBRULE($.expr);\n    });\n\n    $.RULE(\"symbol\", () => {\n      $.CONSUME(Tokens.SYM);\n      $.MANY(() => $.CONSUME(Tokens.TF));\n    });\n\n    $.RULE(\"accept\", () => {\n      $.SUBRULE($.or_expr);\n    });\n\n    $.RULE(\"reject\", () => {\n      $.SUBRULE($.or_expr);\n    });\n\n    $.RULE(\"or_expr\", () => {\n      $.MANY_SEP({\n        SEP: Tokens.OR,\n        DEF: () => $.SUBRULE($.wexpr)\n      });\n    });\n\n    // choice: (LP (wexpr OR)* wexpr RP) transform*;\n    $.RULE(\"choice\", () => {\n      $.CONSUME(Tokens.OC)\n      $.OPTION1(() => $.SUBRULE($.gate));\n      $.SUBRULE($.accept)\n      // $.MANY_SEP({\n      //   SEP: Tokens.OR,\n      //   DEF: () => $.SUBRULE($.wexpr)\n      // });\n      $.OPTION2(() => {\n        $.CONSUME(Tokens.ELSE);\n        $.SUBRULE($.reject)\n      });\n      $.CONSUME(Tokens.CC);\n      $.MANY(() => $.CONSUME(Tokens.TF));\n    });\n\n    $.RULE(\"wexpr\", () => {\n      $.MANY(() => {\n        $.OR([\n          { ALT: () => $.SUBRULE($.expr) },\n          { ALT: () => $.CONSUME(Tokens.Weight) },\n        ])\n      });\n    });\n\n    $.RULE(\"expr\", () => {\n      $.AT_LEAST_ONE(() => $.SUBRULE($.atom));\n    });\n\n    $.RULE(\"atom\", () => {\n      $.OR(this.atomTypes.map(t => ({ ALT: () => $.SUBRULE($[t]) })));\n    });\n\n    $.RULE(\"text\", () => {\n      $.CONSUME(Tokens.Raw);\n    });\n\n    this.performSelfAnalysis(); // keep\n  }\n}\n\nexport { RiScriptParser };","\nclass BaseVisitor {\n  constructor(riScript) {\n    this.input = 0;\n\n    this.path = '';\n    this.tracePath = true;\n    this.scripting = riScript;\n    this.warnOnInvalidGates = false;\n    this.RiScript = this.scripting.constructor; // class hack\n  }\n\n  isCstNode(o) {\n    return (typeof o === 'object' &&\n      ('accept' in o || ('name' in o && 'location' in o && 'children' in o)));\n  }\n\n  visit(cstNode, param) {\n    if (Array.isArray(cstNode)) {\n      cstNode = cstNode[0];\n    }\n    if (typeof cstNode === 'undefined') {\n      return undefined;\n    }\n    if (!this.isCstNode(cstNode)) {\n      throw Error('Non-cstNode passed to visit: ' + JSON.stringify(cstNode));\n    }\n\n    const { name, location } = cstNode;\n\n    this.nodeText = this.input.substring(\n      location.startOffset,\n      location.endOffset + 1\n    );\n\n    if (typeof this[name] !== 'function') {\n      throw Error('BaseVisitor.visit: expecting function for this[' +\n        `${name}], found ${typeof this[name]}: ${JSON.stringify(this[name])}`);\n    }\n\n    if (this.tracePath && !/(expr|atom|silent)/.test(name)) {\n      this.path += name + '.';\n    }\n    return this[name](cstNode.children, param);\n  }\n\n  validateVisitor() {\n    /* no-op */\n  }\n}\n\nclass RiScriptVisitor extends BaseVisitor {\n  constructor(riScript, context = {}) {\n    super(riScript); // stored as global RiScript (TODO)\n    this.context = context;\n\n    this.trace = 0;\n    this.choices = {};\n    this.isNoRepeat = false;\n    this.symbols = this.scripting.Symbols;\n    this.escaped = this.scripting.Escaped;\n\n    // lookups\n    this.statics = {};\n    this.dynamics = {};\n    this.pendingGates = {};\n    this.pendingSymbols = new Set();\n\n    this.validateVisitor(); // keep\n  }\n\n  start(opts = {}) {\n    this.input = opts.input;\n    this.trace = opts.trace;\n    this.traceTx = opts.traceTx;\n    if (!opts.cst) throw Error('no cst');\n    return super.visit(opts.cst);\n  }\n\n  script(ctx) {\n    this.order = 0;\n    const count = ctx.expr ? ctx.expr.length : 0;\n    this.print('script', \"'\" + this.RiScript._escapeText(this.input)\n      + \"' :: \" + count + ' expression(s)');\n    if (!count) return '';\n    if (Object.keys(ctx).length !== 1) throw Error('script: invalid expr');\n    return this.visit(ctx.expr);\n  }\n\n  expr(ctx) {\n    // this.print('expr', ctx);\n    const types = Object.keys(ctx);\n    if (types.length !== 1) throw Error('invalid expr: ' + types.length);\n    const exprs = ctx.atom.map((c) => this.visit(c));\n    // handle special cases of the form: \"not [quite|] far enough\"\n    for (let i = 1; i < exprs.length - 1; i++) {\n      if (\n        exprs[i].length === 0 &&\n        exprs[i - 1].endsWith(' ') &&\n        exprs[i + 1].startsWith(' ')\n      ) {\n        exprs[i + 1] = exprs[i + 1].substring(1);\n      }\n    }\n    return exprs.join('');\n  }\n\n  wexpr(ctx) {\n    this.print('wexpr');\n  }\n\n  gate(ctx) {\n    // returns { decision: [accept | reject] } or { decision: 'defer', operands: [] }\n\n    if (ctx.Gate.length !== 1) throw Error('Invalid gate: ' + ctx.Gate);\n\n    let mingoQuery;\n    const raw = ctx.Gate[0].image;\n    try {\n      mingoQuery = this.scripting._query(raw);\n    } catch (e) {\n      if (!this.warnOnInvalidGates) {\n        throw Error(`Invalid gate[2]: \"@${raw}@\"\\n\\nRootCause -> ${e}`);\n      }\n      if (!this.scripting.RiTa.SILENT && !this.scripting.silent) {\n        console.warn(`[WARN] Ignoring invalid gate: @${raw}@\\n`, e);\n      }\n      return { decision: 'accept' };\n    }\n\n    const resolvedOps = {};\n    const unresolvedOps = [];\n    const operands = mingoQuery.operands();\n    operands.forEach((sym) => {\n      let { result, resolved, isStatic, isUser } = this.checkContext(sym);\n\n      if (typeof result === 'function') {\n        // while {} ?\n        result = result.call(); // call it\n        resolved = !this.scripting.isParseable(result);\n      }\n      if (typeof result === 'undefined' || !resolved) {\n        unresolvedOps.push(sym);\n      } else {\n        // add to appropriate context\n        if (isStatic) {\n          this.statics[sym] = result;\n        } else if (isUser) {\n          this.context[sym] = result;\n        } else {\n          this.dynamics[sym] = result;\n        }\n        // store resolved result\n        resolvedOps[sym] = result;\n      }\n    });\n\n    if (\n      Object.keys(resolvedOps).length + unresolvedOps.length !==\n      operands.length\n    ) { throw Error('invalid operands'); }\n\n    // if we have unresolved operands, return them (and defer)\n    if (unresolvedOps.length) { return { decision: 'defer', operands: unresolvedOps }; }\n\n    let result = mingoQuery.test(resolvedOps); // do test\n    if (!result && this.castValues(resolvedOps)) {\n      result = mingoQuery.test(resolvedOps); // redo test after casting\n    }\n\n    return { decision: result ? 'accept' : 'reject' };\n  }\n\n  assign(ctx, opts) {\n    const sym = ctx.SYM[0].image;\n    let value;\n    let info;\n    const ident = sym.replace(this.scripting.AnySymbolRE, '');\n    const isStatic = sym.startsWith(this.symbols.STATIC);\n\n    if (isStatic) {\n      value = this.visit(ctx.expr);\n      if (this.scripting.isParseable(value)) {\n        this.statics[ident] = value; // store in lookup table ??\n        value = this.inlineAssignment(ident, ctx.TF, value);\n      } else {\n        this.statics[ident] = value; // store in lookup table\n        this.pendingSymbols.delete(ident); // no longer pending\n        this.trace &&\n          console.log('  [pending.delete]', sym,\n            this.pendingSymbols.length\n              ? JSON.stringify(this.pendingSymbols)\n              : ''\n          );\n      }\n      info = `${sym} = ${this.RiScript._escapeText(value)}` +\n        ` [#static] ${opts?.silent ? '{silent}' : ''}`;\n    } else {\n      const $ = this;\n\n      // dynamic: store as func to be resolved later, perhaps many times\n      value = () => $.visit(ctx.expr);\n      info = `${sym} = <f*:pending>` + (opts?.silent ? '{silent}' : '');\n\n      // NOTE: this function may contain a choice, which needs to be handled\n      // when called from a symbol with a norepeat transform (??) TODO: test\n\n      this.dynamics[ident] = value; // store in lookup table\n    }\n    this.print('assign', info);\n\n    return value;\n  }\n\n  silent(ctx) {\n    if (ctx.EQ) {\n      this.assign(ctx, { silent: true });\n    } else {\n      this.symbol(ctx, { silent: true });\n    }\n    return '';\n  }\n\n  atom(ctx) {\n    let result;\n    const types = Object.keys(ctx);\n    if (types.length !== 1) throw Error('invalid atom: ' + types);\n    this.scripting.parser.atomTypes.forEach((type) => {\n      const context = ctx[type];\n      if (context) {\n        if (context.length !== 1) {\n          throw Error(type + ': bad length -> ' + ctx[type].length);\n        }\n        // console.log(type + ':', context[0]);\n        result = this.visit(context[0]);\n      }\n    });\n\n    // pending function, call it\n    if (typeof result === 'function') {\n      result = result.call();\n    }\n    return result;\n  }\n\n  text(ctx) {\n    if (ctx.Raw.length !== 1) throw Error('[1] invalid text');\n    if (Object.keys(ctx).length !== 1) throw Error('[2] invalid text');\n    const image = ctx.Raw[0].image;\n    this.print('text', this.RiScript._escapeText(\"'\" + image + \"'\"));\n    return image;\n  }\n\n  entity(ctx) {\n    return this.nodeText;\n  }\n\n  symbol(ctx, opts) {\n    if (ctx.SYM.length !== 1) throw Error('[1] invalid symbol');\n\n    const original = this.nodeText;\n    const symbol = ctx.SYM[0].image;\n    const ident = symbol.replace(this.scripting.AnySymbolRE, '');\n\n    this.isNoRepeat = this.hasNoRepeat(ctx.TF);\n\n    if (this.pendingSymbols.has(ident)) {\n      this.print('symbol', `${symbol} [is-pending]`);\n      return original;\n    }\n\n    // lookup: result is either a value, a function, or undef\n    let { result, isStatic, isUser, resolved } = this.checkContext(ident);\n\n    if (!isStatic && symbol.startsWith(this.symbols.STATIC)) {\n      if (!this.scripting.EntityRE.test(symbol)) {\n        throw Error(`Attempt to refer to dynamic symbol '${ident}' as` +\n          ` ${this.symbols.STATIC}${ident}, did you mean $${ident}?`);\n      }\n    }\n\n    if (typeof result === 'function') {\n      // while {} ?\n      result = result.call(); // call it\n      resolved = !this.scripting.isParseable(result);\n    }\n\n    if (this.isNoRepeat && (isStatic || isUser)) {\n      this.isNoRepeat = false;\n      const msg = 'Attempt to call norepeat() on ' + (isStatic\n        ? \"static symbol '\" + symbol + \"'. Did you mean to use '\" +\n        this.symbols.DYNAMIC + ident + \"' ?\"\n        : \"non-dynamic symbol '\" + ident + \"'. Did you mean to define '\" +\n        this.symbols.DYNAMIC + ident + \"' in riscript?\");\n      throw Error(msg);\n    }\n\n    if (typeof result === 'undefined') {\n      // nothing found, defer\n      this.print('symbol', symbol + \" -> '\" + original + \"' ctx=\" +\n        this.lookupsToString(), '[deferred]', opts?.silent ? '{silent}' : '');\n      return original;\n    }\n\n    let info = original + \" -> '\" + result + \"'\" + (opts?.silent ? ' {silent}' : '');\n\n    // defer if we still have unresolved riscript\n    if (typeof result === 'string' && !resolved) {\n      if (isStatic) {\n        this.pendingSymbols.add(ident);\n        result = this.inlineAssignment(ident, ctx.TF, result);\n        this.print('symbol*', `${original} -> ${result} :: pending.add(${ident})`);\n      } else {\n        if (ctx.TF) result = this.restoreTransforms(result, ctx.TF);\n        this.print('symbol', info);\n      }\n      return result;\n    }\n\n    if (isStatic) {\n      // store !untransformed! result in static context\n      this.statics[ident] = result; // ADDED 8/18/23 - FIXED 10/8/23\n    }\n\n    if (ctx.TF) {\n      result = this.applyTransforms(result, ctx.TF);\n      info += \" -> '\" + result + \"'\";\n      // info += \" -> \" + ctx.TF.map(tf => ` ${tf.image} -> `) + '\\'' + result + \"'\";\n      // console.log(\"INFO: \" + info);\n      if (this.isNoRepeat) info += ' (norepeat)';\n    }\n\n    this.print('symbol', info);\n\n    // resolved, so remove from pending\n    if (this.pendingSymbols.has(ident)) {\n      this.trace && console.log('  [$pending.delete]', (isStatic ? '#' : '$') + ident,\n        this.pendingSymbols.length ? JSON.stringify(this.pendingSymbols) : '');\n      this.pendingSymbols.delete(ident);\n    }\n    this.isNoRepeat = false; // reset\n\n    return result;\n  }\n\n  pgate(ctx) {\n    this.print('pgate', this.nodeText);\n    // new RegExp(`^${this.symbols.PENDING_GATE}`\n    const original = this.nodeText;\n    const ident = original.replace(this.symbols.PENDING_GATE, '');\n    const lookup = this.pendingGates[ident];\n\n    if (!lookup) {\n      throw Error('no pending gate=\"' + original + '\" pgates=' +\n        JSON.stringify(Object.keys(this.pendingGates)));\n    }\n\n    const stillUnresolved = lookup.operands.some((o) => {\n      let { result, resolved } = this.checkContext(o);\n      if (typeof result === 'function') {\n        // while {} ?\n        result = result.call(); // call it\n        resolved = !this.scripting.isParseable(result);\n      }\n      return typeof result === 'undefined' || !resolved;\n    });\n\n    if (stillUnresolved) return original; // still deferred\n\n    const result = this.choice(lookup.deferredContext); // execute the gate\n    return result;\n  }\n\n  else(ctx) {\n    // this.print('else', this.nodeText);\n    return this.visit(ctx.expr).trim();\n  }\n\n  choice(ctx, opts) {\n    const $ = this.symbols;\n    let rawGate, gateResult;\n    const original = this.nodeText;\n    let info = original;\n    const choiceKey = this.RiScript._stringHash(original + ' #' + this.choiceId(ctx));\n\n    if (!this.isNoRepeat && this.hasNoRepeat(ctx.TF)) {\n      throw Error('noRepeat() not allowed on choice (use a $variable instead): ' + original);\n    }\n\n    let decision = 'accept';\n    if (opts?.forceReject) {\n      decision = 'reject';\n    } else {\n      if (ctx.gate) {\n        // do we have a gate\n        rawGate = ctx.gate[0].children.Gate[0].image;\n        gateResult = this.visit(ctx.gate);\n        decision = gateResult.decision;\n        info += `\\n  [gate] ${rawGate} -> ${decision !== 'defer'\n          ? decision.toUpperCase()\n          : `DEFER ${$.PENDING_GATE}${choiceKey}`\n          }  ${this.lookupsToString()}`;\n      }\n\n      if (gateResult) {\n        if (gateResult.decision === 'defer') {\n          this.pendingGates[choiceKey] = {\n            deferredContext: ctx,\n            operands: gateResult.operands\n          };\n          return `${$.PENDING_GATE}${choiceKey}`; // gate defers\n        }\n      }\n    }\n\n    if (decision === 'reject' && !('reject' in ctx)) {\n      return ''; // rejected without reject expr, return ''\n    }\n\n    const orExpr = ctx[decision]?.[0]?.children?.or_expr?.[0]; // yuck\n    const options = this.parseOptions(orExpr); // get options\n    if (!options) throw Error('No options in choice: ' + original);\n\n    let value = null;\n    const excluded = [];\n    let restored = false;\n    while (value === null) {\n      value = this.choose(options, excluded).value;\n\n      // if we still have script, defer until its resolved\n      if (this.scripting.isParseable(value)) {\n        if (ctx.TF) value = this.restoreTransforms(value, ctx.TF);\n        restored = true;\n        break;\n      }\n\n      // apply any remaining transforms\n      if (ctx.TF) value = this.applyTransforms(value, ctx.TF);\n\n      // we have 'norepeat' but value was already used, try again\n      if (this.isNoRepeat && value === this.choices[choiceKey]) {\n        this.print('choice.reject', value + ' [norepeat]');\n        excluded.push(value);\n        value = null;\n        continue;\n      }\n    }\n\n    if (!restored) this.choices[choiceKey] = value; // put in choice cache\n\n    return value;\n  }\n\n  // Helpers ================================================\n\n  hasNoRepeat(tfs) {\n    const transforms = this.RiScript._transformNames(tfs);\n    if (transforms.length) {\n      return transforms.includes('nr') || transforms.includes('norepeat');\n    }\n    return false;\n  }\n\n  checkContext(ident) {\n    let isStatic = false;\n    let isUser = false;\n    let result;\n\n    if (ident.length === 0) {\n      return { result: '', resolved: true, isStatic, isUser };\n    }\n\n    // check for dynamic symbol: $var\n    result = this.dynamics[ident];\n    if (typeof result === 'undefined') {\n      // no dynamic\n\n      // check for static symbol: #var\n      result = this.statics[ident];\n      if (typeof result !== 'undefined') {\n        isStatic = true; // found static\n      }\n    }\n\n    if (typeof result === 'undefined') {\n      // no static\n      // check for user-defined symbol: context[var]\n      result = this.context[ident];\n      if (typeof result !== 'undefined') {\n        isUser = true; // found user symbol\n      } else {\n        // check for user-defined dynamic? context[$var]\n        result = this.context[this.symbols.DYNAMIC + ident];\n        if (typeof result !== 'undefined') {\n          // no static\n          // note: treat as normal dynamic, isUser = false\n        }\n      }\n    }\n\n    // do we have more script to deal with ?\n    const resolved = !this.scripting.isParseable(result);\n\n    return { result, isStatic, isUser, resolved }; // TODO: replace with 'type'\n  }\n\n  inlineAssignment(ident, tfs, result) {\n    const $ = this.symbols;\n    const lhs = $.STATIC + ident;\n    const rhs = this.restoreTransforms(result, tfs);\n    result = $.OPEN_CHOICE + (lhs + '=' + rhs) + $.CLOSE_CHOICE;\n    return result;\n  }\n\n  choiceId(ctx) {\n    if (!ctx.OC || !ctx.OC.length) throw Error('invalid choice');\n    return ctx.OC[0].startOffset + '.' + ctx.OC[0].endOffset;\n  }\n\n  parseOptions(ctx) {\n    const options = [];\n    if (ctx && ctx?.children?.wexpr) {\n      const wexprs = ctx.children.wexpr;\n      for (let i = 0; i < wexprs.length; i++) {\n        const wexpr = wexprs[i];\n        const expr = wexpr.children.expr;\n        if (expr && expr.length != 1) { throw Error('invalid choice-expr: ' + expr.length); }\n\n        const weight = wexpr.children.Weight;\n        if (weight) {\n          if (weight.length != 1) { throw Error('invalid weight: ' + weight.length); }\n          let mult = 1;\n          try {\n            mult = parseInt(\n              this.symbols.CLOSE_WEIGHT.length\n                ? weight[0].image.trim().slice(1, -1)\n                : weight[0].image.trim().slice(1)\n            );\n          } catch (e) {\n            console.log('EX: ' + mult);\n          }\n          Array.from({ length: mult }, () => options.push(expr));\n        } else {\n          options.push(expr || '');\n        }\n      }\n    }\n    return options;\n  }\n\n  chooseUnique(options, choiceKey) {\n    // not used\n\n    const isUnique = false;\n    while (options.length && !isUnique) {\n      const { index, value } = this.choose(options);\n      if (value !== this.choices[choiceKey]) return value;\n      // console.log(`Skipping ${index}: '${value}'`);\n      options.splice(index, 1);\n    }\n    throw Error('No remaining options');\n  }\n\n  choose(options, excludes = []) {\n    if (!options || !options.length) {\n      throw Error('Invalid choice: no options');\n    }\n\n    const valid = options.filter((x) => !excludes.includes(x));\n    if (!valid.length) {\n      throw Error('Invalid choice: no valid options');\n    }\n\n    const index = this.scripting.RiTa.randi(valid.length);\n\n    let value = ''; const selected = valid[index];\n\n    if (typeof selected === 'string') {\n      this.print('choice.text', \"''\");\n    } else {\n      // if (typeof selected === 'object') {\n      this.path = 'choice.' + this.path;\n      value = this.visit(selected); // cstNode\n    }\n\n    if (typeof value === 'string') value = value.trim();\n\n    return { index, value };\n  }\n\n  applyTransforms(value, txs) {\n    if (this.traceTx) { console.log('applyTransforms', this.formatTxs(...arguments)); }\n    for (let i = 0; i < txs.length; i++) {\n      value = this.applyTransform(value, txs[i]);\n    }\n    return value;\n  }\n\n  // value is not yet resolved, so store with transform for later\n  restoreTransforms(value, txs) {\n    if (typeof value === 'string') {\n      const patt = new RegExp(\n        '^' + this.escaped.OPEN_CHOICE + '.*' + this.escaped.CLOSE_CHOICE + '$'\n      );\n      if (!patt.test(value)) {\n        // wrap in choice to preserve\n        value = this.symbols.OPEN_CHOICE + value + this.symbols.CLOSE_CHOICE;\n      }\n      if (txs) {\n        txs.forEach((tx) => (value += tx.image)); // append transform strings\n      }\n      if (this.traceTx) console.log('restoreTransforms:', value);\n    }\n    return value;\n  }\n\n  castValues(obj) {\n    let madeCast = false;\n    Object.entries(obj).forEach(([k, v]) => {\n      const num = parseFloat(v);\n      if (!isNaN(num)) {\n        madeCast = true;\n        obj[k] = num; // update object with casted value\n      }\n    });\n    return madeCast;\n  }\n\n  contextIsResolved(table) {\n    let allResolved = true;\n    Object.entries(table).forEach(([key, val]) => {\n      if (!this.scripting.isParseable(val)) {\n        allResolved = false;\n      }\n    });\n    return allResolved;\n  }\n\n  applyTransform(target, transform) {\n    const image = transform.image;\n    let result;\n    const raw = target + image;\n    const tx = image.substring(1).replace(/\\(\\)$/, '');\n\n    // function in dynamics\n    if (typeof this.dynamics[tx] === 'function') {\n      result = this.dynamics[tx](target);\n    }\n    // function in statics\n    else if (typeof this.statics[tx] === 'function') {\n      result = this.statics[tx](target);\n    }\n    // function in context\n    else if (typeof this.context[tx] === 'function') {\n      result = this.context[tx](target);\n    }\n\n    // function in transforms\n    else if (typeof this.RiScript.transforms[tx] === 'function') {\n      result = this.RiScript.transforms[tx](target);\n    }\n    // member functions (usually on String)\n    else if (typeof target[tx] === 'function') {\n      result = target[tx]();\n    } else {\n      // check for property\n      if (target.hasOwnProperty(tx)) {\n        result = target[tx];\n      } else {\n        if (!this.scripting.RiTa.SILENT && !this.scripting.silent) {\n          console.warn('[WARN] Unresolved transform: ' + raw);\n        }\n\n        /* Replace transform parens so as not to trigger\n           RiScript.isParseable (for example, in v2) 0 */\n        result = raw.replace(/\\(\\)$/, '&lpar;&rpar;');\n      }\n    }\n\n    if (this.trace) { console.log(`${this.tindent()}[transform] ${raw} -> '${result}'`); }\n\n    return result;\n  }\n\n  lookupsToString() {\n    const dyns = {};\n    const stats = {};\n    Object.entries(this.dynamics || {}).forEach(\n      ([k, v]) => (dyns[`$${k} `] = v)\n    );\n    Object.entries(this.statics || {}).forEach(\n      ([k, v]) => (stats[`#${k} `] = v)\n    );\n    return JSON.stringify({ ...this.context, ...stats, ...dyns }, (k, v) =>\n      typeof v === 'function' ? '<f*:pending>' : v\n    ).replace(/\"/g, '');\n  }\n\n  formatTxs(value, txs) {\n    return value + txs.map((tx) => tx.image.replace(/()/, '') + '()').join('');\n  }\n\n  print(s, ...args) {\n    if (this.trace) {\n      if (this.path && s !== 'script') {\n        s = this.path.replace(/\\.$/, '');\n      }\n      console.log(++this.order, `[${s}]`, ...args);\n      this.path = '';\n    }\n  }\n\n  tindent() {\n    return ' '.repeat((this.order + '').length + 1);\n  }\n}\n\nexport { RiScriptVisitor };\n\n// console.log('&#33; -> '+decode('&#33;'));\n// console.log('&amp; -> '+decode('&amp;'));\n","import { RiScript } from './riscript.js'\n\nclass RiGrammar {\n\n  constructor(rules = {}, context = {}) {\n    if (typeof rules !== 'object') {\n      throw Error('RiGrammar: expecting object, found ' + typeof rules);\n    }\n\n    this.scripting = new RiScript();\n    this.context = context;\n    this.setRules(rules);\n  }\n\n  static expand(rules, context, opts) {\n    return new RiGrammar(rules, context).expand(opts);\n  }\n\n  addTransform() {\n    return RiScript.addTransform(...arguments);\n  }\n  removeTransform() {\n    return RiScript.removeTransform(...arguments);\n  }\n  getTransforms() {\n    return RiScript.transforms;\n  }\n\n  equals(rg) {\n    return rg.toJSON() === this.toJSON();\n  }\n\n  expand(opts = {}) {\n    if ('context' in opts) {\n      throw Error('pass context to RiScript.grammar() or new RiGrammar() instead');\n    }\n\n    // TODO: clone opts here ?\n    opts.visitor = opts.visitor || new RiScript.Visitor(this.scripting);\n    opts.visitor.context = this.context || {};\n    opts.input = this._toScript(opts);\n    // opts.noAddedSilence = true;\n\n    return this.scripting._evaluate(opts);\n  }\n\n  addRule(name, def) {\n    this._validateRule(name, def);\n    this.rules[name] = def;\n  }\n\n  setRules(rules) {\n    if (typeof rules === 'undefined') throw Error('undefined rules');\n    this.rules = {};\n    let incoming = typeof rules === 'string' ? parseJSON(rules) : rules;\n    let self = this;\n    Object.entries(incoming).forEach((e) => self.addRule(...e));\n  }\n\n  removeRule(name) {\n    if (name in this.rules) {\n      delete this.rules[name];\n    }\n  }\n\n  toJSON() {\n    return JSON.stringify(this.rules, ...arguments);\n  }\n\n  toString(opts = {}) {\n    let replacer = opts.replacer || 0;\n    let space = opts.space || 2;\n    let lb = opts?.linebreak;\n    let res = this.toJSON(replacer, space);\n    if (lb) res = res.replace(/\\n/g, lb);\n    return res;\n  }\n\n  static fromJSON(str, opts) {\n    return new RiGrammar(JSON.parse(str), opts);\n  }\n\n  /* \n    Convert grammar to inline rules;\n    rules are dynamic, unless otherwise specified with leading #\n  */\n  _toScript(opts) {\n    let script = '',\n      start = opts.start || 'start';\n    let { Symbols } = this.scripting;\n\n    if (start.startsWith(Symbols.DYNAMIC)) {\n      start = start.substring(Symbols.DYNAMIC.length);\n    }\n\n    if (start.startsWith(Symbols.STATIC)) {\n      start = start.substring(Symbols.STATIC.length);\n    }\n\n    if (!(start in this.rules || Symbols.STATIC + start in this.rules)) {\n      throw Error('Rule: \"' + start + '\" not found in grammar');\n    }\n\n    Object.entries(this.rules).forEach(([name, rule], i) => {\n      while (name.startsWith(Symbols.DYNAMIC)) {\n        name = name.substring(1);\n      }\n      if (!name.startsWith(Symbols.STATIC)) {\n        name = Symbols.DYNAMIC + name;\n      }\n      // console.log(i,name);\n      if (!this.scripting.ChoiceWrapRE.test(rule)) {\n        // let orig = rule;\n        rule = Symbols.OPEN_CHOICE + rule + Symbols.CLOSE_CHOICE;\n        // console.log('WRAPPING: ' + orig + '->' + rule);\n      }\n      script += `${name}=${rule}\\n`;\n    });\n\n    if (opts.trace) console.log('Grammar:\\n' + script.replace(/^\\$/gm, '  $'));\n\n    script += `${Symbols.DYNAMIC}${start}`;\n    return script;\n  }\n\n  _validateRule(name, def) {\n    if (typeof name !== 'string' || name.length === 0) {\n      throw Error('expected [string] name');\n    }\n\n    if (typeof def === 'undefined') {\n      throw Error('undefined rule def: ' + name);\n    }\n    let { Symbols } = this.scripting;\n\n    if (name.startsWith(Symbols.DYNAMIC)) {\n      name = name.substring(Symbols.DYNAMIC.length);\n      throw Error(\n        'Grammar rules are dynamic by default;' +\n          \" if you need a static rule, use '\" +\n          Symbols.STATIC +\n          name +\n          \"', otherwise just use '\" +\n          name +\n          \"'.\"\n      );\n    }\n  }\n}\n\nfunction parseJSON(json) {\n  if (typeof json === 'string') {\n    try {\n      return JSON.parse(json);\n    } catch (e) {\n      throw Error(\n        'RiGrammar appears to be invalid JSON,' +\n          ' please check it at http://jsonlint.com/\\n' +\n          json\n      );\n    }\n  }\n}\n\nexport { RiGrammar };\n","import { RiScript } from './riscript.js';\nimport { RiGrammar } from './grammar.js';\nimport { RiScriptVisitor } from './visitor.js';\n\nRiScript.Grammar = RiGrammar;\nRiScript.Visitor = RiScriptVisitor;\n\nexport default RiScript\n"]}