{"version":3,"sources":["../src/riscript.js","../node_modules/lodash-es/_freeGlobal.js","../node_modules/lodash-es/_root.js","../node_modules/lodash-es/_Symbol.js","../node_modules/lodash-es/_getRawTag.js","../node_modules/lodash-es/_objectToString.js","../node_modules/lodash-es/_baseGetTag.js","../node_modules/lodash-es/isObjectLike.js","../node_modules/lodash-es/isSymbol.js","../node_modules/lodash-es/_arrayMap.js","../node_modules/lodash-es/isArray.js","../node_modules/lodash-es/_baseToString.js","../node_modules/lodash-es/_trimmedEndIndex.js","../node_modules/lodash-es/_baseTrim.js","../node_modules/lodash-es/isObject.js","../node_modules/lodash-es/toNumber.js","../node_modules/lodash-es/toFinite.js","../node_modules/lodash-es/toInteger.js","../node_modules/lodash-es/identity.js","../node_modules/lodash-es/isFunction.js","../node_modules/lodash-es/_coreJsData.js","../node_modules/lodash-es/_isMasked.js","../node_modules/lodash-es/_toSource.js","../node_modules/lodash-es/_baseIsNative.js","../node_modules/lodash-es/_getValue.js","../node_modules/lodash-es/_getNative.js","../node_modules/lodash-es/_WeakMap.js","../node_modules/lodash-es/_baseCreate.js","../node_modules/lodash-es/_apply.js","../node_modules/lodash-es/noop.js","../node_modules/lodash-es/_copyArray.js","../node_modules/lodash-es/_shortOut.js","../node_modules/lodash-es/constant.js","../node_modules/lodash-es/_defineProperty.js","../node_modules/lodash-es/_baseSetToString.js","../node_modules/lodash-es/_setToString.js","../node_modules/lodash-es/_arrayEach.js","../node_modules/lodash-es/_baseFindIndex.js","../node_modules/lodash-es/_baseIsNaN.js","../node_modules/lodash-es/_strictIndexOf.js","../node_modules/lodash-es/_baseIndexOf.js","../node_modules/lodash-es/_arrayIncludes.js","../node_modules/lodash-es/_isIndex.js","../node_modules/lodash-es/_baseAssignValue.js","../node_modules/lodash-es/eq.js","../node_modules/lodash-es/_assignValue.js","../node_modules/lodash-es/_copyObject.js","../node_modules/lodash-es/_overRest.js","../node_modules/lodash-es/_baseRest.js","../node_modules/lodash-es/isLength.js","../node_modules/lodash-es/isArrayLike.js","../node_modules/lodash-es/_isIterateeCall.js","../node_modules/lodash-es/_createAssigner.js","../node_modules/lodash-es/_isPrototype.js","../node_modules/lodash-es/_baseTimes.js","../node_modules/lodash-es/_baseIsArguments.js","../node_modules/lodash-es/isArguments.js","../node_modules/lodash-es/stubFalse.js","../node_modules/lodash-es/isBuffer.js","../node_modules/lodash-es/_baseIsTypedArray.js","../node_modules/lodash-es/_baseUnary.js","../node_modules/lodash-es/_nodeUtil.js","../node_modules/lodash-es/isTypedArray.js","../node_modules/lodash-es/_arrayLikeKeys.js","../node_modules/lodash-es/_overArg.js","../node_modules/lodash-es/_nativeKeys.js","../node_modules/lodash-es/_baseKeys.js","../node_modules/lodash-es/keys.js","../node_modules/lodash-es/assign.js","../node_modules/lodash-es/_nativeKeysIn.js","../node_modules/lodash-es/_baseKeysIn.js","../node_modules/lodash-es/keysIn.js","../node_modules/lodash-es/_isKey.js","../node_modules/lodash-es/_nativeCreate.js","../node_modules/lodash-es/_hashClear.js","../node_modules/lodash-es/_hashDelete.js","../node_modules/lodash-es/_hashGet.js","../node_modules/lodash-es/_hashHas.js","../node_modules/lodash-es/_hashSet.js","../node_modules/lodash-es/_Hash.js","../node_modules/lodash-es/_listCacheClear.js","../node_modules/lodash-es/_assocIndexOf.js","../node_modules/lodash-es/_listCacheDelete.js","../node_modules/lodash-es/_listCacheGet.js","../node_modules/lodash-es/_listCacheHas.js","../node_modules/lodash-es/_listCacheSet.js","../node_modules/lodash-es/_ListCache.js","../node_modules/lodash-es/_Map.js","../node_modules/lodash-es/_mapCacheClear.js","../node_modules/lodash-es/_isKeyable.js","../node_modules/lodash-es/_getMapData.js","../node_modules/lodash-es/_mapCacheDelete.js","../node_modules/lodash-es/_mapCacheGet.js","../node_modules/lodash-es/_mapCacheHas.js","../node_modules/lodash-es/_mapCacheSet.js","../node_modules/lodash-es/_MapCache.js","../node_modules/lodash-es/memoize.js","../node_modules/lodash-es/_memoizeCapped.js","../node_modules/lodash-es/_stringToPath.js","../node_modules/lodash-es/toString.js","../node_modules/lodash-es/_castPath.js","../node_modules/lodash-es/_toKey.js","../node_modules/lodash-es/_baseGet.js","../node_modules/lodash-es/get.js","../node_modules/lodash-es/_arrayPush.js","../node_modules/lodash-es/_isFlattenable.js","../node_modules/lodash-es/_baseFlatten.js","../node_modules/lodash-es/flatten.js","../node_modules/lodash-es/_getPrototype.js","../node_modules/lodash-es/_baseSlice.js","../node_modules/lodash-es/_arrayReduce.js","../node_modules/lodash-es/_stackClear.js","../node_modules/lodash-es/_stackDelete.js","../node_modules/lodash-es/_stackGet.js","../node_modules/lodash-es/_stackHas.js","../node_modules/lodash-es/_stackSet.js","../node_modules/lodash-es/_Stack.js","../node_modules/lodash-es/_baseAssign.js","../node_modules/lodash-es/_baseAssignIn.js","../node_modules/lodash-es/_cloneBuffer.js","../node_modules/lodash-es/_arrayFilter.js","../node_modules/lodash-es/stubArray.js","../node_modules/lodash-es/_getSymbols.js","../node_modules/lodash-es/_copySymbols.js","../node_modules/lodash-es/_getSymbolsIn.js","../node_modules/lodash-es/_copySymbolsIn.js","../node_modules/lodash-es/_baseGetAllKeys.js","../node_modules/lodash-es/_getAllKeys.js","../node_modules/lodash-es/_getAllKeysIn.js","../node_modules/lodash-es/_DataView.js","../node_modules/lodash-es/_Promise.js","../node_modules/lodash-es/_Set.js","../node_modules/lodash-es/_getTag.js","../node_modules/lodash-es/_initCloneArray.js","../node_modules/lodash-es/_Uint8Array.js","../node_modules/lodash-es/_cloneArrayBuffer.js","../node_modules/lodash-es/_cloneDataView.js","../node_modules/lodash-es/_cloneRegExp.js","../node_modules/lodash-es/_cloneSymbol.js","../node_modules/lodash-es/_cloneTypedArray.js","../node_modules/lodash-es/_initCloneByTag.js","../node_modules/lodash-es/_initCloneObject.js","../node_modules/lodash-es/_baseIsMap.js","../node_modules/lodash-es/isMap.js","../node_modules/lodash-es/_baseIsSet.js","../node_modules/lodash-es/isSet.js","../node_modules/lodash-es/_baseClone.js","../node_modules/lodash-es/clone.js","../node_modules/lodash-es/compact.js","../node_modules/lodash-es/_setCacheAdd.js","../node_modules/lodash-es/_setCacheHas.js","../node_modules/lodash-es/_SetCache.js","../node_modules/lodash-es/_arraySome.js","../node_modules/lodash-es/_cacheHas.js","../node_modules/lodash-es/_equalArrays.js","../node_modules/lodash-es/_mapToArray.js","../node_modules/lodash-es/_setToArray.js","../node_modules/lodash-es/_equalByTag.js","../node_modules/lodash-es/_equalObjects.js","../node_modules/lodash-es/_baseIsEqualDeep.js","../node_modules/lodash-es/_baseIsEqual.js","../node_modules/lodash-es/_baseIsMatch.js","../node_modules/lodash-es/_isStrictComparable.js","../node_modules/lodash-es/_getMatchData.js","../node_modules/lodash-es/_matchesStrictComparable.js","../node_modules/lodash-es/_baseMatches.js","../node_modules/lodash-es/_baseHasIn.js","../node_modules/lodash-es/_hasPath.js","../node_modules/lodash-es/hasIn.js","../node_modules/lodash-es/_baseMatchesProperty.js","../node_modules/lodash-es/_baseProperty.js","../node_modules/lodash-es/_basePropertyDeep.js","../node_modules/lodash-es/property.js","../node_modules/lodash-es/_baseIteratee.js","../node_modules/lodash-es/_arrayAggregator.js","../node_modules/lodash-es/_createBaseFor.js","../node_modules/lodash-es/_baseFor.js","../node_modules/lodash-es/_baseForOwn.js","../node_modules/lodash-es/_createBaseEach.js","../node_modules/lodash-es/_baseEach.js","../node_modules/lodash-es/_baseAggregator.js","../node_modules/lodash-es/_createAggregator.js","../node_modules/lodash-es/defaults.js","../node_modules/lodash-es/isArrayLikeObject.js","../node_modules/lodash-es/_arrayIncludesWith.js","../node_modules/lodash-es/_baseDifference.js","../node_modules/lodash-es/difference.js","../node_modules/lodash-es/last.js","../node_modules/lodash-es/drop.js","../node_modules/lodash-es/dropRight.js","../node_modules/lodash-es/_castFunction.js","../node_modules/lodash-es/forEach.js","../node_modules/lodash-es/_arrayEvery.js","../node_modules/lodash-es/_baseEvery.js","../node_modules/lodash-es/every.js","../node_modules/lodash-es/_baseFilter.js","../node_modules/lodash-es/filter.js","../node_modules/lodash-es/_createFind.js","../node_modules/lodash-es/findIndex.js","../node_modules/lodash-es/find.js","../node_modules/lodash-es/head.js","../node_modules/lodash-es/_baseMap.js","../node_modules/lodash-es/map.js","../node_modules/lodash-es/flatMap.js","../node_modules/lodash-es/groupBy.js","../node_modules/lodash-es/_baseHas.js","../node_modules/lodash-es/has.js","../node_modules/lodash-es/isString.js","../node_modules/lodash-es/_baseValues.js","../node_modules/lodash-es/values.js","../node_modules/lodash-es/includes.js","../node_modules/lodash-es/indexOf.js","../node_modules/lodash-es/isEmpty.js","../node_modules/lodash-es/_baseIsRegExp.js","../node_modules/lodash-es/isRegExp.js","../node_modules/lodash-es/isUndefined.js","../node_modules/lodash-es/negate.js","../node_modules/lodash-es/_baseSet.js","../node_modules/lodash-es/_basePickBy.js","../node_modules/lodash-es/pickBy.js","../node_modules/lodash-es/_baseReduce.js","../node_modules/lodash-es/reduce.js","../node_modules/lodash-es/reject.js","../node_modules/lodash-es/_baseSome.js","../node_modules/lodash-es/some.js","../node_modules/lodash-es/_createSet.js","../node_modules/lodash-es/_baseUniq.js","../node_modules/lodash-es/uniq.js","../node_modules/@chevrotain/utils/src/print.ts","../node_modules/@chevrotain/utils/src/timer.ts","../node_modules/@chevrotain/utils/src/to-fast-properties.ts","../node_modules/@chevrotain/gast/src/model.ts","../node_modules/@chevrotain/gast/src/visitor.ts","../node_modules/@chevrotain/gast/src/helpers.ts","../node_modules/chevrotain/src/parse/grammar/rest.ts","../node_modules/chevrotain/src/parse/grammar/first.ts","../node_modules/chevrotain/src/parse/constants.ts","../node_modules/chevrotain/src/parse/grammar/follow.ts","../node_modules/@chevrotain/regexp-to-ast/src/utils.ts","../node_modules/@chevrotain/regexp-to-ast/src/character-classes.ts","../node_modules/@chevrotain/regexp-to-ast/src/regexp-parser.ts","../node_modules/@chevrotain/regexp-to-ast/src/base-regexp-visitor.ts","../node_modules/chevrotain/src/scan/reg_exp_parser.ts","../node_modules/chevrotain/src/scan/reg_exp.ts","../node_modules/chevrotain/src/scan/lexer.ts","../node_modules/chevrotain/src/scan/tokens.ts","../node_modules/chevrotain/src/scan/lexer_errors_public.ts","../node_modules/chevrotain/src/scan/lexer_public.ts","../node_modules/chevrotain/src/scan/tokens_public.ts","../node_modules/chevrotain/src/parse/errors_public.ts","../node_modules/chevrotain/src/parse/grammar/resolver.ts","../node_modules/chevrotain/src/parse/grammar/interpreter.ts","../node_modules/chevrotain/src/parse/grammar/lookahead.ts","../node_modules/chevrotain/src/parse/grammar/checks.ts","../node_modules/chevrotain/src/parse/grammar/gast/gast_resolver_public.ts","../node_modules/chevrotain/src/parse/exceptions_public.ts","../node_modules/chevrotain/src/parse/parser/traits/recoverable.ts","../node_modules/chevrotain/src/parse/grammar/keys.ts","../node_modules/chevrotain/src/parse/grammar/llk_lookahead.ts","../node_modules/chevrotain/src/parse/parser/traits/looksahead.ts","../node_modules/chevrotain/src/parse/cst/cst.ts","../node_modules/chevrotain/src/lang/lang_extensions.ts","../node_modules/chevrotain/src/parse/cst/cst_visitor.ts","../node_modules/chevrotain/src/parse/parser/traits/tree_builder.ts","../node_modules/chevrotain/src/parse/parser/traits/lexer_adapter.ts","../node_modules/chevrotain/src/parse/parser/traits/recognizer_api.ts","../node_modules/chevrotain/src/parse/parser/traits/recognizer_engine.ts","../node_modules/chevrotain/src/parse/parser/traits/error_handler.ts","../node_modules/chevrotain/src/parse/parser/traits/context_assist.ts","../node_modules/chevrotain/src/parse/parser/traits/gast_recorder.ts","../node_modules/chevrotain/src/parse/parser/traits/perf_tracer.ts","../node_modules/chevrotain/src/parse/parser/utils/apply_mixins.ts","../node_modules/chevrotain/src/parse/parser/parser.ts","../src/tokens.js","../src/parser.js","../src/visitor.js","../src/grammar.js","../src/index.js"],"names":["he","Query","freeGlobal","freeGlobal_default","freeSelf","root","root_default","Symbol","Symbol_default","objectProto","hasOwnProperty","nativeObjectToString","symToStringTag","getRawTag","value","isOwn","tag","unmasked","result","getRawTag_default","objectToString","objectToString_default","nullTag","undefinedTag","baseGetTag","baseGetTag_default","isObjectLike","isObjectLike_default","symbolTag","isSymbol","isSymbol_default","arrayMap","array","iteratee","index","length","arrayMap_default","isArray","isArray_default","INFINITY","symbolProto","symbolToString","baseToString","baseToString_default","reWhitespace","trimmedEndIndex","string","trimmedEndIndex_default","reTrimStart","baseTrim","baseTrim_default","isObject","type","isObject_default","NAN","reIsBadHex","reIsBinary","reIsOctal","freeParseInt","toNumber","other","isBinary","toNumber_default","MAX_INTEGER","toFinite","sign","toFinite_default","toInteger","remainder","toInteger_default","identity","identity_default","asyncTag","funcTag","genTag","proxyTag","isFunction","isFunction_default","coreJsData","coreJsData_default","maskSrcKey","uid","isMasked","func","isMasked_default","funcProto","funcToString","toSource","toSource_default","reRegExpChar","reIsHostCtor","reIsNative","baseIsNative","pattern","baseIsNative_default","getValue","object","key","getValue_default","getNative","getNative_default","WeakMap","WeakMap_default","objectCreate","baseCreate","proto","baseCreate_default","apply","thisArg","args","apply_default","noop","noop_default","copyArray","source","copyArray_default","HOT_COUNT","HOT_SPAN","nativeNow","shortOut","count","lastCalled","stamp","remaining","shortOut_default","constant","constant_default","defineProperty","defineProperty_default","baseSetToString","baseSetToString_default","setToString","setToString_default","arrayEach","arrayEach_default","baseFindIndex","predicate","fromIndex","fromRight","baseFindIndex_default","baseIsNaN","baseIsNaN_default","strictIndexOf","strictIndexOf_default","baseIndexOf","baseIndexOf_default","arrayIncludes","arrayIncludes_default","MAX_SAFE_INTEGER","reIsUint","isIndex","isIndex_default","baseAssignValue","baseAssignValue_default","eq","eq_default","assignValue","objValue","assignValue_default","copyObject","props","customizer","isNew","newValue","copyObject_default","nativeMax","overRest","start","transform","otherArgs","overRest_default","baseRest","baseRest_default","isLength","isLength_default","isArrayLike","isArrayLike_default","isIterateeCall","isIterateeCall_default","createAssigner","assigner","sources","guard","createAssigner_default","isPrototype","Ctor","isPrototype_default","baseTimes","n","baseTimes_default","argsTag","baseIsArguments","baseIsArguments_default","propertyIsEnumerable","isArguments","isArguments_default","stubFalse","stubFalse_default","freeExports","freeModule","moduleExports","Buffer","nativeIsBuffer","isBuffer","isBuffer_default","arrayTag","boolTag","dateTag","errorTag","mapTag","numberTag","objectTag","regexpTag","setTag","stringTag","weakMapTag","arrayBufferTag","dataViewTag","float32Tag","float64Tag","int8Tag","int16Tag","int32Tag","uint8Tag","uint8ClampedTag","uint16Tag","uint32Tag","typedArrayTags","baseIsTypedArray","baseIsTypedArray_default","baseUnary","baseUnary_default","freeProcess","nodeUtil","types","nodeUtil_default","nodeIsTypedArray","isTypedArray","isTypedArray_default","arrayLikeKeys","inherited","isArr","isArg","isBuff","isType","skipIndexes","arrayLikeKeys_default","overArg","arg","overArg_default","nativeKeys","nativeKeys_default","baseKeys","baseKeys_default","keys","keys_default","assign","assign_default","nativeKeysIn","nativeKeysIn_default","baseKeysIn","isProto","baseKeysIn_default","keysIn","keysIn_default","reIsDeepProp","reIsPlainProp","isKey","isKey_default","nativeCreate","nativeCreate_default","hashClear","hashClear_default","hashDelete","hashDelete_default","HASH_UNDEFINED","hashGet","data","hashGet_default","hashHas","hashHas_default","hashSet","hashSet_default","Hash","entries","entry","Hash_default","listCacheClear","listCacheClear_default","assocIndexOf","assocIndexOf_default","arrayProto","splice","listCacheDelete","lastIndex","listCacheDelete_default","listCacheGet","listCacheGet_default","listCacheHas","listCacheHas_default","listCacheSet","listCacheSet_default","ListCache","ListCache_default","Map","Map_default","mapCacheClear","mapCacheClear_default","isKeyable","isKeyable_default","getMapData","map","getMapData_default","mapCacheDelete","mapCacheDelete_default","mapCacheGet","mapCacheGet_default","mapCacheHas","mapCacheHas_default","mapCacheSet","size","mapCacheSet_default","MapCache","MapCache_default","FUNC_ERROR_TEXT","memoize","resolver","memoized","cache","memoize_default","MAX_MEMOIZE_SIZE","memoizeCapped","memoizeCapped_default","rePropName","reEscapeChar","stringToPath","match","number","quote","subString","stringToPath_default","toString","toString_default","castPath","castPath_default","toKey","toKey_default","baseGet","path","baseGet_default","get","defaultValue","get_default","arrayPush","values","offset","arrayPush_default","spreadableSymbol","isFlattenable","isFlattenable_default","baseFlatten","depth","isStrict","baseFlatten_default","flatten","flatten_default","getPrototype","getPrototype_default","baseSlice","end","baseSlice_default","arrayReduce","accumulator","initAccum","arrayReduce_default","stackClear","stackClear_default","stackDelete","stackDelete_default","stackGet","stackGet_default","stackHas","stackHas_default","LARGE_ARRAY_SIZE","stackSet","pairs","stackSet_default","Stack","Stack_default","baseAssign","baseAssign_default","baseAssignIn","baseAssignIn_default","allocUnsafe","cloneBuffer","buffer","isDeep","cloneBuffer_default","arrayFilter","resIndex","arrayFilter_default","stubArray","stubArray_default","nativeGetSymbols","getSymbols","symbol","getSymbols_default","copySymbols","copySymbols_default","getSymbolsIn","getSymbolsIn_default","copySymbolsIn","copySymbolsIn_default","baseGetAllKeys","keysFunc","symbolsFunc","baseGetAllKeys_default","getAllKeys","getAllKeys_default","getAllKeysIn","getAllKeysIn_default","DataView","DataView_default","Promise","Promise_default","Set","Set_default","promiseTag","dataViewCtorString","mapCtorString","promiseCtorString","setCtorString","weakMapCtorString","getTag","ctorString","getTag_default","initCloneArray","initCloneArray_default","Uint8Array","Uint8Array_default","cloneArrayBuffer","arrayBuffer","cloneArrayBuffer_default","cloneDataView","dataView","cloneDataView_default","reFlags","cloneRegExp","regexp","cloneRegExp_default","symbolValueOf","cloneSymbol","cloneSymbol_default","cloneTypedArray","typedArray","cloneTypedArray_default","initCloneByTag","initCloneByTag_default","initCloneObject","initCloneObject_default","baseIsMap","baseIsMap_default","nodeIsMap","isMap","isMap_default","baseIsSet","baseIsSet_default","nodeIsSet","isSet","isSet_default","CLONE_DEEP_FLAG","CLONE_FLAT_FLAG","CLONE_SYMBOLS_FLAG","cloneableTags","baseClone","bitmask","stack","isFlat","isFull","isFunc","stacked","subValue","baseClone_default","clone","clone_default","compact","compact_default","setCacheAdd","setCacheAdd_default","setCacheHas","setCacheHas_default","SetCache","SetCache_default","arraySome","arraySome_default","cacheHas","cacheHas_default","COMPARE_PARTIAL_FLAG","COMPARE_UNORDERED_FLAG","equalArrays","equalFunc","isPartial","arrLength","othLength","arrStacked","othStacked","seen","arrValue","othValue","compared","othIndex","equalArrays_default","mapToArray","mapToArray_default","setToArray","set","setToArray_default","equalByTag","convert","equalByTag_default","equalObjects","objProps","objLength","othProps","objStacked","skipCtor","objCtor","othCtor","equalObjects_default","baseIsEqualDeep","objIsArr","othIsArr","objTag","othTag","objIsObj","othIsObj","isSameTag","objIsWrapped","othIsWrapped","objUnwrapped","othUnwrapped","baseIsEqualDeep_default","baseIsEqual","baseIsEqual_default","baseIsMatch","matchData","noCustomizer","srcValue","baseIsMatch_default","isStrictComparable","isStrictComparable_default","getMatchData","getMatchData_default","matchesStrictComparable","matchesStrictComparable_default","baseMatches","baseMatches_default","baseHasIn","baseHasIn_default","hasPath","hasFunc","hasPath_default","hasIn","hasIn_default","baseMatchesProperty","baseMatchesProperty_default","baseProperty","baseProperty_default","basePropertyDeep","basePropertyDeep_default","property","property_default","baseIteratee","baseIteratee_default","arrayAggregator","setter","arrayAggregator_default","createBaseFor","iterable","createBaseFor_default","baseFor","baseFor_default","baseForOwn","baseForOwn_default","createBaseEach","eachFunc","collection","createBaseEach_default","baseEach","baseEach_default","baseAggregator","baseAggregator_default","createAggregator","initializer","createAggregator_default","defaults","propsIndex","propsLength","defaults_default","isArrayLikeObject","isArrayLikeObject_default","arrayIncludesWith","comparator","arrayIncludesWith_default","baseDifference","includes","isCommon","valuesLength","outer","computed","valuesIndex","baseDifference_default","difference","difference_default","last","last_default","drop","drop_default","dropRight","dropRight_default","castFunction","castFunction_default","forEach","forEach_default","arrayEvery","arrayEvery_default","baseEvery","baseEvery_default","every","every_default","baseFilter","baseFilter_default","filter","filter_default","createFind","findIndexFunc","createFind_default","findIndex","findIndex_default","find","find_default","head","head_default","baseMap","baseMap_default","map_default","flatMap","flatMap_default","groupBy","groupBy_default","baseHas","baseHas_default","has","has_default","isString","isString_default","baseValues","baseValues_default","values_default","includes_default","indexOf","indexOf_default","isEmpty","isEmpty_default","baseIsRegExp","baseIsRegExp_default","nodeIsRegExp","isRegExp","isRegExp_default","isUndefined","isUndefined_default","negate","negate_default","baseSet","nested","baseSet_default","basePickBy","paths","basePickBy_default","pickBy","prop","pickBy_default","baseReduce","baseReduce_default","reduce","reduce_default","reject","reject_default","baseSome","baseSome_default","some","some_default","createSet","createSet_default","baseUniq","seenIndex","baseUniq_default","uniq","uniq_default","PRINT_ERROR","msg","PRINT_WARNING","timer","val","toFastProperties","toBecomeFast","FakeConstructor","fakeInstance","fakeAccess","tokenLabel","tokType","hasTokenLabel","obj","AbstractProduction","_definition","visitor","prod","NonTerminal","options","v","definition","Rule","Alternative","Option","RepetitionMandatory","RepetitionMandatoryWithSeparator","Repetition","RepetitionWithSeparator","Alternation","Terminal","serializeGrammar","topRules","serializeProduction","node","convertDefinition","serializedNonTerminal","serializedTerminal","GAstVisitor","nodeAny","isSequenceProd","isOptionalProd","alreadyVisited","subProd","isBranchingProd","getProductionDslName","RestWalker","prevRest","currRest","terminal","refProd","flatProd","fullOrRest","optionProd","atLeastOneProd","fullAtLeastOneRest","atLeastOneSepProd","fullAtLeastOneSepRest","restForRepetitionWithSeparator","manyProd","fullManyRest","manySepProd","fullManySepRest","orProd","alt","prodWrapper","repSepProd","first","firstForTerminal","firstForSequence","firstForBranching","firstSet","seq","nextSubProdIdx","hasInnerProdsRemaining","currSubProd","isLastInnerProdOptional","allAlternativesFirsts","innerProd","IN","ResyncFollowsWalker","topProd","followName","buildBetweenProdsFollowPrefix","fullRest","restProd","t_in_topProd_follows","computeAllProdsFollows","topProductions","reSyncFollows","currRefsFollow","inner","occurenceInParent","cc","char","insertToSet","item","subItem","addFlag","flagObj","flagKey","x","ASSERT_EXISTS","ASSERT_NEVER_REACH_HERE","isCharacter","digitsCharCodes","i","wordCharCodes","whitespaceCodes","hexDigitPattern","decimalPattern","decimalPatternNoZero","RegExpParser","newState","input","flags","alts","begin","terms","disjunction","isBacktracking","range","atLeast","atMost","atom","complement","escapeCode","letter","escapedChar","nextChar","from","isFromSingleChar","to","isToSingleChar","capturing","groupAst","howMuch","prevState","howMany","hexString","hexChar","BaseRegExpVisitor","child","subChild","regExpAstCache","regExpParser","getRegExpAst","regExp","regExpStr","regExpAst","clearRegExpParserCache","complementErrorMessage","failedOptimizationPrefixMsg","getOptimizedStartCodesIndices","ensureOptimizations","ast","firstCharOptimizedIndices","e","msgSuffix","ignoreCase","term","addOptimizedIdxToResult","code","rangeCode","minOptimizationVal","minUnOptVal","maxUnOptVal","minOptIdx","charCodeToOptimizedIndex","maxOptIdx","currOptIdx","isOptionalQuantifier","isWholeOptional","optimizedCharIdx","handleIgnoreCase","upperChar","lowerChar","findCode","setNode","targetCharCodes","codeOrRange","targetCode","quantifier","CharCodeFinder","canMatchCharCode","charCodes","charCodeFinder","PATTERN","DEFAULT_MODE","MODES","SUPPORT_STICKY","analyzeTokenTypes","tokenTypes","action","tracer","initCharCodeToOptimizedIndexMap","onlyRelevantTypes","currType","Lexer","hasCustom","allTransformedPatterns","currPattern","regExpSource","addStickyFlag","addStartOfInput","escapedRegExpString","wrappedRegExp","patternIdxToType","patternIdxToGroup","patternIdxToLongerAltIdxArr","patternIdxToPushMode","patternIdxToPopMode","clazz","groupName","longerAltType","patternIdxToCanLineTerminator","lineTerminatorCharCodes","getCharCodes","checkLineBreaksIssues","patternIdxToIsCustom","patternIdxToShort","emptyGroups","patternIdxToConfig","isCustomPattern","isShortPattern","acc","idx","canBeOptimized","charCodeToPatternIdxToConfig","currTokType","charCode","optimizedIdx","addToMapOfArrays","lastOptimizedIdx","charOrInt","currOptimizedIdx","optimizedCodes","validatePatterns","validModesNames","errors","missingResult","findMissingPatterns","invalidResult","findInvalidPatterns","validTokenTypes","validateRegExpPattern","findInvalidGroupType","findModesThatDoNotExist","findUnreachablePatterns","withRegExpPatterns","findEndOfInputAnchor","findStartOfInputAnchor","findUnsupportedFlags","findDuplicatePatterns","findEmptyMatchRegExps","tokenTypesWithMissingPattern","LexerDefinitionErrorType","valid","tokenTypesWithInvalidPattern","end_of_input","EndAnchorFinder","invalidRegex","regexpAst","endAnchorVisitor","matchesEmptyString","start_of_input","StartAnchorFinder","startAnchorVisitor","invalidFlags","found","identicalPatterns","outerType","innerType","duplicatePatterns","currIdenticalSet","setOfIdentical","tokenTypeNames","invalidTypes","group","validModes","invalidModes","canBeTested","noMetaChar","testIdx","str","tokenType","testTokenType","regExpArray","performRuntimeChecks","lexerDefinition","trackLines","lineTerminatorCharacters","currModeValue","currModeName","currIdx","longerAlt","currLongerAlt","performWarningRuntimeChecks","warnings","hasAnyLineBreak","allTokenTypes","concreteTokenTypes","terminatorCharCodes","currIssue","warningDescriptor","buildLineBreakIssueMessage","cloneEmptyGroups","clonedResult","groupKeys","currKey","currGroupValue","LineTerminatorOptimizedTester","text","len","c","details","charsOrCodes","numOrString","charCodeToOptimizedIdxMap","tokenStructuredMatcher","tokInstance","tokConstructor","instanceType","tokenStructuredMatcherNoCategories","token","tokenShortNameIdx","tokenIdxToClass","augmentTokenTypes","tokenTypesAndParents","expandCategories","assignTokenDefaultProps","assignCategoriesMapProp","assignCategoriesTokensProp","categories","searching","newCategories","hasShortKeyProperty","hasCategoriesProperty","hasExtendingTokensTypesProperty","hasExtendingTokensTypesMapProperty","singleAssignCategoriesToksMap","nextNode","pathNode","nextCategory","newPath","isTokenType","defaultLexerErrorProvider","fullText","startOffset","line","column","DEFAULT_LEXER_CONFIG","config","phaseDesc","phaseImpl","indent","time","traceMethod","traceInitVal","actualDefinition","hasOnlySingleMode","allModeNames","currModDef","currModName","currAnalyzeResult","allErrMessagesString","error","unOptimizedModes","cannotBeOptimized","modeName","initialMode","j","k","matchAltImage","matchedImage","payload","altPayload","imageLength","newToken","errLength","droppedChar","orgText","orgLength","matchedTokensIndex","guessedNumberOfTokens","matchedTokens","groups","lineTerminatorPattern","currModePatternsLength","currCharCodeToPatternIdxToConfig","modeStack","emptyArray","getPossiblePatterns","getPossiblePatternsSlow","getPossiblePatternsOptimized","possiblePatterns","pop_mode","popToken","newMode","modeCanBeOptimized","push_mode","currConfig","recoveryEnabled","nextCharCode","chosenPatternIdxToConfig","chosenPatternsLength","singleCharCode","longerAltLength","longerAltConfig","longerAltPattern","numOfLTsInMatch","foundTerminator","lastLTEndOffset","errorStartOffset","errorLine","errorColumn","foundResyncPoint","pushMode","newLastIndex","lastLTIdx","lastCharIsLT","fixForEndingInLT","oldColumn","image","tokenTypeIdx","startLine","startColumn","tokenVector","tokenToAdd","PARENT","CATEGORIES","LABEL","GROUP","PUSH_MODE","POP_MODE","LONGER_ALT","LINE_BREAKS","START_CHARS_HINT","createToken","createTokenInternal","EOF","createTokenInstance","endOffset","endLine","endColumn","tokenMatcher","defaultParserErrorProvider","expected","actual","previous","ruleName","firstRedundant","expectedPathsPerAlt","customUserDescription","errPrefix","errSuffix","allLookAheadPaths","currAltPaths","nextValidTokenSequences","currPath","currTokenType","calculatedDescription","itemMsg","expectedIterationPaths","defaultGrammarResolverErrorProvider","topLevelRule","undefinedRule","defaultGrammarValidatorErrorProvider","duplicateProds","getExtraProductionArgument","topLevelName","duplicateProd","dslName","extraArgument","hasExplicitIndex","rule","pathMsg","currTok","occurrence","currtok","currMessage","pathNames","currRule","leftRecursivePath","resolveGrammar","topLevels","errMsgProvider","refResolver","GastRefResolverVisitor","nameToTopRule","ref","ParserDefinitionErrorType","AbstractNextPossibleTokensWalker","NextAfterTokenWalker","AbstractNextTerminalAfterProductionWalker","topRule","NextTerminalAfterManyWalker","firstAfterMany","NextTerminalAfterManySepWalker","firstAfterManySep","NextTerminalAfterAtLeastOneWalker","firstAfterAtLeastOne","NextTerminalAfterAtLeastOneSepWalker","atleastOneSepProd","firstAfterfirstAfterAtLeastOneSep","possiblePathsFrom","targetDef","maxLength","remainingPathWith","nextDef","getAlternativesForProd","alternatives","newDef","currAlt","nextPossibleTokensAfter","initialDef","tokMatcher","maxLookAhead","EXIT_NON_TERMINAL","EXIT_NON_TERMINAL_ARR","EXIT_ALTERNATIVE","foundCompletePath","tokenVectorLength","minimalAlternativesIndex","possiblePaths","currDef","currRuleStack","currOccurrenceStack","nextPath","nextIdx","actualToken","newRuleStack","newOccurrenceStack","nextPathWithout","nextPathWith","secondIteration","separatorGast","nthRepetition","currAltPath","expandTopLevelRule","newCurrOccurrenceStack","PROD_TYPE","getProdType","buildLookaheadFuncForOr","ruleGrammar","maxLookahead","hasPredicates","dynamicTokensEnabled","laFuncBuilder","lookAheadPaths","getLookaheadPathsForOr","areTokenCategoriesNotUsed","buildLookaheadFuncForOptionalProd","prodType","lookaheadBuilder","getLookaheadPathsForOptionalProd","buildAlternativesLookAheadFunc","numOfAlts","areAllOneTokenLookahead","orAlts","predicates","t","currNumOfPaths","currPredicate","currPathLength","nextToken","singleTokenAlts","choiceToAlt","currExtendingType","buildSingleAlternativeLookaheadFunction","numOfPaths","singleTokensTypes","expectedTokenUniqueKey","RestDefinitionFinderWalker","targetOccurrence","targetProdType","expectedProdType","InsideDefinitionFinderVisitor","targetRef","expectedProdName","initializeArrayOfArrays","pathToHashKeys","longerKeys","currShorterKey","categoriesKeySuffix","isUniquePrefixHash","altKnownPathsKeys","searchPathKeys","currAltIdx","otherAltKnownPathsKeys","searchIdx","searchKey","lookAheadSequenceFromAlternatives","altsDefs","partialAlts","finalResult","altsHashes","dict","newData","pathLength","currDataset","altIdx","currAltPathsAndSuffixes","currPathIdx","currPathPrefix","suffixDef","prefixKeys","currAltResult","containsPath","newPartialPathsAndSuffixes","insideDefVisitor","insideDef","afterDef","insideFlat","afterFlat","alternative","searchPath","compareOtherPath","otherPath","searchTok","otherTok","isStrictPrefixOfPath","prefix","otherTokType","singleAltPaths","singlePath","validateLookahead","lookaheadValidationErrorMessages","errorMessage","validateGrammar","grammarName","duplicateErrors","currTopLevel","validateDuplicateProductions","termsNamespaceConflictErrors","checkTerminalAndNoneTerminalsNameSpace","tooManyAltsErrors","curRule","validateTooManyAlts","duplicateRulesError","validateRuleDoesNotAlreadyExist","collectorVisitor","OccurrenceValidationCollector","allRuleProductions","productionGroups","identifyProductionForDuplicates","duplicates","currGroup","currDuplicates","firstProd","defError","param","subrule","option","manySep","atLeastOne","atLeastOneSep","many","or","allRules","className","errMsg","validateRuleIsOverridden","definedRulesNames","validateNoLeftRecursion","nextNonTerminals","getFirstNoneTerminal","validNextSteps","errorsFromNextSteps","currRefRule","currSubDef","isFirstOptional","hasMore","rest","OrCollector","validateEmptyOrAlternative","orCollector","ors","currOr","exceptLast","currAlternative","possibleFirstInAlt","validateAmbiguousAlternationAlternatives","globalMaxLookahead","currOccurrence","actualMaxLookahead","altsAmbiguityErrors","checkAlternativesAmbiguities","altsPrefixAmbiguityErrors","checkPrefixAlternativesAmbiguities","RepetitionCollector","validateSomeNonEmptyLookaheadPath","topLevelRules","currTopRule","currProd","pathsInsideProduction","alternation","foundAmbiguousPaths","identicalAmbiguities","altsCurrPathAppearsIn","currOtherAlt","currOtherAltIdx","currAmbDescriptor","ambgIndices","pathsAndIndices","currPathsAndIdx","currPathAndIdx","targetIdx","targetPath","prefixAmbiguitiesPathsAndIndices","searchPathAndIdx","currAmbPathAndIdx","tokenNames","currToken","currRuleName","actualOptions","topRulesTable","MISMATCHED_TOKEN_EXCEPTION","NO_VIABLE_ALT_EXCEPTION","EARLY_EXIT_EXCEPTION","NOT_ALL_INPUT_PARSED_EXCEPTION","RECOGNITION_EXCEPTION_NAMES","isRecognitionException","RecognitionException","message","MismatchedTokenException","previousToken","NoViableAltException","NotAllInputParsedException","EarlyExitException","EOF_FOLLOW_KEY","IN_RULE_RECOVERY_EXCEPTION","InRuleRecoveryException","Recoverable","DEFAULT_PARSER_CONFIG","attemptInRepetitionRecovery","tokToInsert","grammarRule","grammarRuleArgs","lookAheadFunc","expectedTokType","reSyncTokType","savedLexerState","resyncedTokens","passedResyncPoint","nextTokenWithoutResync","generateErrorMessage","expectTokAfterLastMatch","nextTokIdx","notStuck","tokIdxInRule","grammarPath","follows","nextTok","expectedToken","mismatchedTok","possibleFollowsTokType","followKey","currentRuleReSyncSet","allPossibleReSyncTokTypes","foundMatch","resyncTokType","currRuleShortName","currRuleIdx","prevRuleShortName","explicitRuleStack","explicitOccurrenceStack","followStack","resyncTokens","prodFunc","lookaheadFunc","dslMethodIdx","prodOccurrence","nextToksWalker","pathRuleStack","pathOccurrenceStack","currShortName","firstAfterRepInfo","isEndOfRule","getKeyForAutomaticLookahead","ruleIdx","BITS_START_FOR_ALT_IDX","LLkLookaheadStrategy","_a","leftRecursionErrors","emptyAltErrors","ambiguousAltsErrors","emptyRepetitionErrors","rules","LooksAhead","repetition","repetitionMandatory","repetitionMandatoryWithSeparator","repetitionWithSeparator","collectMethods","prodIdx","laFunc","prodKey","prodMaxLookahead","dslMethodName","DslMethodsCollectorVisitor","dslMethods","setNodeLocationOnlyOffset","currNodeLocation","newLocationInfo","setNodeLocationFull","addTerminalToCst","tokenTypeName","addNoneTerminalToCst","ruleResult","NAME","defineNameProp","nameValue","defaultVisit","ctx","childrenNames","childrenNamesLength","currChildName","currChildArray","currChildArrayLength","currChild","createBaseSemanticVisitorConstructor","ruleNames","derivedConstructor","semanticProto","cstNode","semanticDefinitionErrors","validateVisitor","errorMessages","currDefError","createBaseVisitorConstructorWithDefaults","baseConstructor","withDefaultsProto","CstVisitorDefinitionError","visitorInstance","validateMissingCstMethods","missingRuleNames","TreeBuilder","fullRuleName","ruleCstNode","prevToken","loc","consumedToken","rootCst","ruleCstResult","preCstNode","newBaseCstVisitorConstructor","newConstructor","ruleStack","occurrenceStack","LexerAdapter","newInput","END_OF_FILE","soughtIdx","RecognizerApi","impl","ruleToCall","actionORMethodDef","altsOrOpts","name","implementation","DEFAULT_RULE_CONFIG","ruleImplementation","ruleErrors","orgState","RecognizerEngine","tokenVocabulary","uniqueTokens","noTokenCategoriesUsed","tokenConstructor","resyncEnabled","recoveryValueFunc","shortName","invokeRuleWithTry","cst","resyncEnabledConfig","isFirstInvokedRule","reSyncEnabled","recogError","partialCstResult","orgLookaheadFunction","laKey","separator","separatorLookAheadFunc","lookaheadFunction","nextTerminalAfterWalker","beforeIteration","altIdxToTake","firstRedundantTok","eFromConsumption","eFromInRuleRecovery","savedErrors","savedRuleStack","fullName","idxInCallingRule","ErrorHandler","newErrors","userDefinedErrMsg","insideProdPaths","actualTokens","errMsgTypes","lookAheadPathsPerAlternative","ContentAssist","startRuleName","precedingInput","startRuleGast","topRuleName","topProduction","RECORDING_NULL_OBJECT","HANDLE_SEPARATOR","MAX_METHOD_IDX","RFT","RECORDING_PHASE_TOKEN","RECORDING_PHASE_CSTNODE","GastRecorder","arg1","arg2","that","def","newTopLevelRule","originalError","recordProd","recordOrProd","assertMethodIdxIsValid","getIdxSuffix","prevProd","newNoneTerminal","prodConstructor","mainProdArg","handleSep","grammarAction","newProd","hasOptions","newOrProd","currAltFlat","PerformanceTracer","userTraceInitPerf","traceIsNumber","applyMixins","derivedCtor","baseCtors","baseCtor","baseProto","propName","basePropDescriptor","Parser","parserInstance","defErrorsMsgs","originalGrammarAction","recordedRuleGast","resolverErrors","validationErrors","lookaheadValidationErrors","allFollows","_b","CstParser","configClone","getTokens","v2Compatible","Symbols","Escaped","escapeRegex","PENDING_GATE_PATTERN","ExitGate","Gate","PendingGate","EnterGate","OC","CC","OR","ELSE","EQ","TF","OS","CS","SYM","Entity","Weight","Raw","s","RiScriptParser","allTokens","opts","$","Tokens","BaseVisitor","riScript","o","location","RiScriptVisitor","context","exprs","mingoQuery","raw","resolvedOps","unresolvedOps","operands","sym","resolved","isStatic","isUser","info","ident","original","lookup","rawGate","gateResult","choiceKey","decision","orExpr","excluded","restored","tfs","transforms","lhs","rhs","wexprs","wexpr","expr","weight","mult","excludes","selected","txs","tx","madeCast","num","table","allResolved","target","dyns","stats","decode","VowelRE","RegexEscape","HtmlEntities","RiQuery","scripting","condition","currentObj","ele","_RiScript","script","Constants","tokens","anysym","open","close","lexResult","endingBreak","rawQuery","g","deferredGate","deferredContext","slashEscapesToEntities","lines","eqIdx","opens","charCount","closes","unescapeRegexProperty","res","parts","escaped","urp","phones","quotify","chr","hash","strHash","RiScript","__publicField","replaceAll","escapeRegExp","replacement","RiGrammar","rg","incoming","parseJSON","self","replacer","space","lb","json","src_default"],"mappings":"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","sourcesContent":["import he from 'he';\nimport { Query } from 'mingo';\nimport { Lexer } from 'chevrotain';\n\nimport { getTokens } from './tokens.js';\nimport { RiScriptParser } from './parser.js';\nimport { RiScriptVisitor } from './visitor.js';\n\n/*\n  Specification:\n    script: expr+\n    expr: (atom)+\n    wexpr: (atom)+ weight\n    symbol: SYM transform*\n    assign: SYM EQ expr transform*\n    gate: @mingo@\n    silent: { gate? expr }\n    atom: (choice | symbol | text | silent) weight?\n    choice: [ gate? ( expr | wexpr ) (OR  (expr | wexpr ) )* else? ] transform*\n    else: ELSE expr\n    raw: Raw\n*/\n\n// TODO: integrate with rita, test node-packages, linting, coverage?\n\nconst { decode } = he;\nconst VowelRE = /[aeiou]/;\nconst RegexEscape = '_RE_';\nconst HtmlEntities = /&([a-z0-9]+|#[0-9]{1,6}|#x[0-9a-fA-F]{1,6});/gi;\n\nclass RiQuery extends Query {\n  constructor(scripting, condition, options) {\n    if (typeof condition === 'string') {\n      let raw = condition; // eslint-disable-line\n      condition = scripting.parseJSOL(condition);\n      // console.log('RAW: ', raw, 'parsed', condition);\n    }\n    super(condition, options);\n  }\n\n  test(obj) {\n    for (let i = 0, len = this.compiled.length; i < len; i++) {\n      if (!this.compiled[i](obj)) return false;\n    }\n    return true;\n  }\n\n  operands() {\n    const stack = [this.condition];\n    const keys = new Set();\n    while (stack?.length > 0) {\n      const currentObj = stack.pop();\n      Object.keys(currentObj).forEach((key) => {\n        const value = currentObj[key];\n        // console.log(`key: ${ key }, value: ${ value } `);\n        if (!key.startsWith('$')) keys.add(key);\n        if (typeof value === 'object' && value !== null) {\n          const eles = Array.isArray(value) ? value : [value];\n          eles.forEach((ele) => stack.push(ele));\n        }\n      });\n    }\n    return Array.from(keys);\n  }\n}\n\nclass RiScript {\n  static Query = RiQuery;\n\n  static VERSION = '[VI]{version}[/VI]';\n\n  static RiTaWarnings = { plurals: false, phones: false };\n\n  static evaluate(script, context, opts = {}) {\n    return new RiScript().evaluate(script, context, opts);\n  }\n\n  constructor(opts = {}) { // private ?\n    this.visitor = 0; // created in evaluate() or passed in here\n    this.v2Compatible = opts.compatibility === 2;\n    const { Constants, tokens } = getTokens(this.v2Compatible);\n    this.Escaped = Constants.Escaped;\n    this.Symbols = Constants.Symbols;\n\n    const anysym = Constants.Escaped.STATIC + Constants.Escaped.DYNAMIC;\n    const open = Constants.Escaped.OPEN_CHOICE;\n    const close = Constants.Escaped.CLOSE_CHOICE;\n\n    this.JSOLIdentRE = new RegExp(`([${anysym}]?[A-Za-z_0-9][A-Za-z_0-9]*)\\\\s*:`, 'g');\n    this.RawAssignRE = new RegExp(`^[${anysym}][A-Za-z_0-9][A-Za-z_0-9]*\\\\s*=`);\n    this.ChoiceWrapRE = new RegExp('^' + open + '[^' + open + close + ']*' + close + '$');\n\n    this.SpecialRE = new RegExp(`[${this.Escaped.SPECIAL.replace('&', '')}]`);\n    this.ContinueRE = new RegExp(this.Escaped.CONTINUATION + '\\\\r?\\\\n', 'g');\n    this.WhitespaceRE = /[\\u00a0\\u2000-\\u200b\\u2028-\\u2029\\u3000]+/g;\n    this.AnySymbolRE = new RegExp(`[${anysym}]`); // added\n\n    this.silent = false;\n    this.lexer = new Lexer(tokens);\n    this.parser = new RiScriptParser(tokens);\n    this.RiTa = opts.RiTa || {\n      VERSION: 0,\n      randi: (k) => Math.floor(Math.random() * k),\n    }\n  }\n\n  lex(opts) {\n    if (!opts.input) throw Error('no input');\n    const lexResult = this.lexer.tokenize(opts.input);\n    if (lexResult.errors.length) {\n      console.error('Input: ' + opts.input + '\\n', lexResult.errors[0].message);\n      throw Error('[LEXING] ' + lexResult.errors[0].message);\n    }\n    if (opts.trace) this.printTokens(lexResult.tokens);\n    opts.tokens = lexResult.tokens;\n    // return lexResult;\n  }\n\n  parse(opts) {\n    opts.cst = this.parser.parse(opts);\n  }\n\n  visit(opts) {\n    return this.visitor.start(opts);\n  }\n\n  lexParseVisit(opts = {}) {\n    this.lex(opts);\n    this.parse(opts);\n    return this.visit(opts);\n  }\n\n  evaluate(script, context, opts = {}) {\n    if (typeof script !== 'string') {\n      throw Error('RiScript.evaluate() expects a string, got ' + typeof script);\n    }\n    opts.input = script;\n    opts.visitor = new RiScriptVisitor(this, context);\n    return this._evaluate(opts);\n  }\n\n  _evaluate(opts) {\n    const { input } = opts;\n\n    // opts.onepass = true; // TMP\n\n    let last, endingBreak = /\\r?\\n$/.test(input); // keep\n\n    let expr = this.preParse(input, opts);\n    if (!expr) return '';\n\n    if (opts.trace) console.log(`\\nInput:  '${RiScript._escapeText(input)}'`);\n    if (opts.trace && input !== expr) {\n      console.log(`Parsed: '${RiScript._escapeText(expr)}'`);\n    }\n\n    if (!opts.visitor) throw Error('no visitor');\n    this.visitor = opts.visitor;\n    delete opts.visitor; // remind me why\n\n    for (let i = 1; expr !== last && i <= 10; i++) {\n      last = expr;\n\n      if (opts.trace) console.log('-'.repeat(20) + ' Pass#' + i + ' ' + '-'.repeat(20));\n\n      opts.input = expr;\n      expr = this.lexParseVisit(opts); // do it\n\n      if (opts.trace) {\n        console.log(`Result(${i}) -> \"` + `${RiScript._escapeText(expr)}\"`\n          + ` ctx=${this.visitor.lookupsToString()}`);\n      }\n\n      // end if no more riscript\n      if (opts.onepass || !this.isParseable(expr)) break;\n    }\n\n    // check for unresolved symbols ([$#]) after removing HTML entities\n    if (!this.silent && !this.RiTa.SILENT) {\n      if (this.AnySymbolRE.test(expr.replace(HtmlEntities, ''))) {\n        console.warn('[WARN] Unresolved symbol(s) in \"' + expr.replace(/\\n/g, '\\\\n') + '\" ');\n      }\n    }\n\n    return this.postParse(expr, opts) + (endingBreak ? '\\n' : '');\n  }\n\n  _query(rawQuery, opts) {\n    return new RiQuery(this, rawQuery, opts);\n  }\n\n  printTokens(tokens) {\n    let s = tokens.reduce((str, t) => {\n      let { name } = t.tokenType;\n      let tag = name;\n      if (tag === 'TEXT') tag = RiScript._escapeText(t.image, 1);\n      if (tag === 'SYM') tag = 'sym(' + t.image + ')';\n      if (tag === 'TX') tag = 'tx(' + t.image + ')';\n      return str + tag + ', ';\n    }, '')\n      .slice(0, -2);\n    console.log('\\nTokens: [ ' + s + ' ]  Context:',\n      this.visitor.lookupsToString());\n  }\n\n  postParse(input, opts) {\n    if (typeof input !== 'string') return '';\n\n    // replace html entities\n    let decoded = decode(input);\n\n    // clean up whitespace, linebreaks\n    let result = decoded.replace(this.WhitespaceRE, ' ').replace(/\\r?\\n$/, '');\n\n    // handle unresolved gates\n    let gates = [...result.matchAll(this.Symbols.PENDING_GATE_RE)];\n    gates.forEach((g) => {\n      if (!g || !g[0] || !g[1]) throw Error('bad gate: ' + g);\n      let deferredGate = this.visitor.pendingGates[g[1]];\n      let { deferredContext, operands } = deferredGate;\n      if (!operands.length) throw Error('no operands');\n      let reject = this.visitor.choice(deferredContext, { forceReject: true });\n\n      result = result.replace(g[0], reject);\n      if (opts.trace) console.log('  ' + g[0] + '-> ' + reject);\n    });\n\n    if (opts.trace) console.log(`\\nFinal: '${result}'`);\n\n    if (!opts.preserveLookups) {\n      // reset lookups unless preserveLookups=true (for testing only)\n      this.visitor.statics = undefined;\n      this.visitor.dynamics = undefined;\n    }\n\n    return result;\n  }\n\n  preParse(script, opts) {\n    if (typeof script !== 'string') return '';\n\n    const $ = this.Symbols;\n\n    let input = script;\n    if (!this.v2Compatible) {\n      // handle parenthesized weights ??\n      input = input.replace(/\\((\\s*\\d+\\s*)\\)/g, '^$1^');\n    }\n\n    input = input.replace(/\\/\\*[^]*?(\\r?\\n)?\\//g, ''); // multi-line comments\n    input = input.replace(/\\/\\/[^\\n]+(\\r?\\n|$)/g, ''); // single-line comments\n    input = input.replace(this.ContinueRE, ''); // line continuations\n    input = slashEscapesToEntities(input); // double-backslashed escapes\n\n    let result = '';\n    let lines = input.split(/\\r?\\n/);\n    for (let i = 0; i < lines.length; i++) {\n      // special-case: handle assignments alone on a line\n      if (/*!opts.noAddedSilence && */ this.RawAssignRE.test(lines[i])) {\n        // a very convoluted way of preserving line-breaks inside groups\n        let eqIdx = lines[i].indexOf('=');\n        if (eqIdx < 0) throw Error('invalid state: no assigment: ' + lines[i]);\n        let lhs = lines[i].substring(0, eqIdx),\n          rhs = lines[i].substring(eqIdx + 1);\n        let opens = charCount(rhs, $.OPEN_CHOICE);\n        let closes = charCount(rhs, $.CLOSE_CHOICE);\n        while (opens > closes) {\n          let line = lines[++i];\n          rhs += '\\n' + line;\n          opens += charCount(line, $.OPEN_CHOICE);\n          closes += charCount(line, $.CLOSE_CHOICE);\n        }\n        result += $.OPEN_SILENT + (lhs + '=' + rhs) + $.CLOSE_SILENT;\n      } else {\n        result += lines[i];\n        if (i < lines.length - 1) result += '\\n';\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Parses a mingo query into JSON format\n   */\n  parseJSOL(text) {\n    const unescapeRegexProperty = (text) => {\n      // TODO: why do we need this?\n      let res = text;\n      if (\n        typeof text === 'string' &&\n        text.startsWith(RegexEscape) &&\n        text.endsWith(RegexEscape)\n      ) {\n        let parts = text.split(RegexEscape);\n        if (parts.length !== 4) throw Error('invalid regex in unescape');\n        res = new RegExp(parts[1], parts[2]);\n      }\n      return res;\n    };\n    let escaped = RiScript._escapeJSONRegex(text)\n      .replace(this.JSOLIdentRE, '\"$1\":')\n      .replace(/'/g, '\"');\n\n    // console.log(\"escaped: '\"+escaped+\"'\");\n\n    let result = JSON.parse(escaped),\n      urp = unescapeRegexProperty;\n    Object.keys(result).forEach((k) => (result[k] = urp(result[k])));\n    return result;\n  }\n\n  isParseable(s) {\n    // conservatively assume non-string/numbers are always parseable\n    let result = true;\n    let isStrOrNum = /(string|number)/.test(typeof s);\n    // if a string or num, test for special chars\n    if (isStrOrNum) result = this.SpecialRE.test(s.toString());\n    return result;\n  }\n\n  // ========================= statics ===============================\n\n\n  // Default transform that adds an article\n  static articlize(s) {\n    if (!s || !s.length) return '';\n\n    let first = s.split(/\\s+/)[0];\n\n    if (!RiScript.RiTa?.phones) {\n      if (!RiScript.RiTaWarnings.phones) {\n        console.warn('[WARN] Install RiTa for proper phonemes');\n        RiScript.RiTaWarnings.phones = true;\n      }\n      // first.startsWith('a') ? 'an ' : 'a ') + s;\n      return (/^[aeiou].*/i.test(first) ? 'an ' : 'a ') + s;\n    }\n\n    let phones = RiScript.RiTa.phones(first, { silent: true });\n\n    // could still be original word if no phones found\n    return (\n      (phones && phones.length && VowelRE.test(phones[0]) ? 'an ' : 'a ') + s\n    );\n  }\n\n  // Default transform that capitalizes the first character\n  static capitalize(s) {\n    return s ? s[0].toUpperCase() + s.substring(1) : '';\n  }\n\n  // Default transform that capitalizes the string\n  static uppercase(s) {\n    return s ? s.toUpperCase() : '';\n  }\n\n  // Default transform that wraps the string in (smart) quotes.\n  static quotify(s) {\n    return '&#8220;' + (s || '') + '&#8221;';\n  }\n\n  // Default transform that pluralizes a string (requires RiTa)\n  static pluralize(s) {\n    if (!RiScript.RiTa?.pluralize) {\n      if (!RiScript.RiTaWarnings.plurals) {\n        RiScript.RiTaWarnings.plurals = true;\n        console.warn('[WARN] Install RiTa for proper pluralization');\n      }\n      return s.endsWith('s') ? s : s + 's';\n    }\n    return RiScript.RiTa.pluralize(s);\n  }\n\n  // Default no-op transform\n  static identity(s) {\n    return s;\n  }\n\n  // static helpers\n\n  static _transformNames(txs) {\n    return txs && txs.length\n      ? txs.map((tx) => tx.image.replace(/(^\\.|\\(\\)$)/g, ''), [])\n      : [];\n  }\n\n  static _escapeText(s, quotify) {\n    if (typeof s !== 'string') return s;\n    let t = s.replace(/\\r?\\n/g, '\\\\n');\n    return quotify || !t.length ? \"'\" + t + \"'\" : t;\n  }\n\n  static _escapeJSONRegex(text) {\n    return text.replace(\n      /\\/([^/]+?)\\/([igmsuy]*)/g,\n      `\"${RegexEscape}$1${RegexEscape}$2${RegexEscape}\"`\n    );\n  }\n\n  static _stringHash(s) {\n    let chr,\n      hash = 0;\n    for (let i = 0; i < s.length; i++) {\n      chr = s.charCodeAt(i);\n      hash = (hash << 5) - hash + chr;\n      hash |= 0; // Convert to 32bit integer\n    }\n    let strHash = hash.toString();\n    return hash < 0 ? strHash.replace('-', '0') : strHash;\n  }\n}\n\n////////////////////// STATIC PROPS ///////////////////////\n\nRiScript.transforms = {\n  quotify: RiScript.quotify,\n  pluralize: RiScript.pluralize,\n  capitalize: RiScript.capitalize,\n  articlize: RiScript.articlize,\n  uppercase: RiScript.uppercase,\n\n  // sequences\n  norepeat: RiScript.identity,\n\n  // aliases\n  art: RiScript.articlize,\n  nr: RiScript.identity,\n  cap: RiScript.capitalize,\n  ucf: RiScript.capitalize, // deprecated?\n  uc: RiScript.uppercase,\n  qq: RiScript.quotify,\n  s: RiScript.pluralize,\n};\n\n///////////////////////// FUNCTIONS /////////////////////////\n\nfunction slashEscapesToEntities(s) {\n  s = replaceAll(s, '\\\\(', '&lpar;');\n  s = replaceAll(s, '\\\\)', '&rpar;');\n  s = replaceAll(s, '\\\\[', '&lsqb;');\n  s = replaceAll(s, '\\\\]', '&rsqb;');\n  s = replaceAll(s, '\\\\{', '&lcqb;');\n  s = replaceAll(s, '\\\\}', '&rcqb;');\n  s = replaceAll(s, '\\\\@', '&commat;');\n  s = replaceAll(s, '\\\\#', '&num;');\n  s = replaceAll(s, '\\\\|', ' &vert');\n  s = replaceAll(s, '\\\\=', ' &equals');\n  return s;\n}\nfunction escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\nfunction replaceAll(str, match, replacement) {\n  return str.replace(new RegExp(escapeRegExp(match), 'g'), () => replacement);\n}\nfunction charCount(str, c) {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === c) count++;\n  }\n  return count;\n}\n\nexport { RiScript };","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nexport default freeGlobal;\n","import freeGlobal from './_freeGlobal.js';\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nexport default root;\n","import root from './_root.js';\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nexport default Symbol;\n","import Symbol from './_Symbol.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nexport default getRawTag;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nexport default objectToString;\n","import Symbol from './_Symbol.js';\nimport getRawTag from './_getRawTag.js';\nimport objectToString from './_objectToString.js';\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nexport default baseGetTag;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nexport default isObjectLike;\n","import baseGetTag from './_baseGetTag.js';\nimport isObjectLike from './isObjectLike.js';\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nexport default isSymbol;\n","/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\nexport default arrayMap;\n","/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nexport default isArray;\n","import Symbol from './_Symbol.js';\nimport arrayMap from './_arrayMap.js';\nimport isArray from './isArray.js';\nimport isSymbol from './isSymbol.js';\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nexport default baseToString;\n","/** Used to match a single whitespace character. */\nvar reWhitespace = /\\s/;\n\n/**\n * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n * character of `string`.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {number} Returns the index of the last non-whitespace character.\n */\nfunction trimmedEndIndex(string) {\n  var index = string.length;\n\n  while (index-- && reWhitespace.test(string.charAt(index))) {}\n  return index;\n}\n\nexport default trimmedEndIndex;\n","import trimmedEndIndex from './_trimmedEndIndex.js';\n\n/** Used to match leading whitespace. */\nvar reTrimStart = /^\\s+/;\n\n/**\n * The base implementation of `_.trim`.\n *\n * @private\n * @param {string} string The string to trim.\n * @returns {string} Returns the trimmed string.\n */\nfunction baseTrim(string) {\n  return string\n    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')\n    : string;\n}\n\nexport default baseTrim;\n","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nexport default isObject;\n","import baseTrim from './_baseTrim.js';\nimport isObject from './isObject.js';\nimport isSymbol from './isSymbol.js';\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = baseTrim(value);\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nexport default toNumber;\n","import toNumber from './toNumber.js';\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_INTEGER = 1.7976931348623157e+308;\n\n/**\n * Converts `value` to a finite number.\n *\n * @static\n * @memberOf _\n * @since 4.12.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted number.\n * @example\n *\n * _.toFinite(3.2);\n * // => 3.2\n *\n * _.toFinite(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toFinite(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toFinite('3.2');\n * // => 3.2\n */\nfunction toFinite(value) {\n  if (!value) {\n    return value === 0 ? value : 0;\n  }\n  value = toNumber(value);\n  if (value === INFINITY || value === -INFINITY) {\n    var sign = (value < 0 ? -1 : 1);\n    return sign * MAX_INTEGER;\n  }\n  return value === value ? value : 0;\n}\n\nexport default toFinite;\n","import toFinite from './toFinite.js';\n\n/**\n * Converts `value` to an integer.\n *\n * **Note:** This method is loosely based on\n * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted integer.\n * @example\n *\n * _.toInteger(3.2);\n * // => 3\n *\n * _.toInteger(Number.MIN_VALUE);\n * // => 0\n *\n * _.toInteger(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toInteger('3.2');\n * // => 3\n */\nfunction toInteger(value) {\n  var result = toFinite(value),\n      remainder = result % 1;\n\n  return result === result ? (remainder ? result - remainder : result) : 0;\n}\n\nexport default toInteger;\n","/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\nexport default identity;\n","import baseGetTag from './_baseGetTag.js';\nimport isObject from './isObject.js';\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nexport default isFunction;\n","import root from './_root.js';\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\nexport default coreJsData;\n","import coreJsData from './_coreJsData.js';\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\nexport default isMasked;\n","/** Used for built-in method references. */\nvar funcProto = Function.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\nexport default toSource;\n","import isFunction from './isFunction.js';\nimport isMasked from './_isMasked.js';\nimport isObject from './isObject.js';\nimport toSource from './_toSource.js';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\nexport default baseIsNative;\n","/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\nexport default getValue;\n","import baseIsNative from './_baseIsNative.js';\nimport getValue from './_getValue.js';\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\nexport default getNative;\n","import getNative from './_getNative.js';\nimport root from './_root.js';\n\n/* Built-in method references that are verified to be native. */\nvar WeakMap = getNative(root, 'WeakMap');\n\nexport default WeakMap;\n","import isObject from './isObject.js';\n\n/** Built-in value references. */\nvar objectCreate = Object.create;\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} proto The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nvar baseCreate = (function() {\n  function object() {}\n  return function(proto) {\n    if (!isObject(proto)) {\n      return {};\n    }\n    if (objectCreate) {\n      return objectCreate(proto);\n    }\n    object.prototype = proto;\n    var result = new object;\n    object.prototype = undefined;\n    return result;\n  };\n}());\n\nexport default baseCreate;\n","/**\n * A faster alternative to `Function#apply`, this function invokes `func`\n * with the `this` binding of `thisArg` and the arguments of `args`.\n *\n * @private\n * @param {Function} func The function to invoke.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {Array} args The arguments to invoke `func` with.\n * @returns {*} Returns the result of `func`.\n */\nfunction apply(func, thisArg, args) {\n  switch (args.length) {\n    case 0: return func.call(thisArg);\n    case 1: return func.call(thisArg, args[0]);\n    case 2: return func.call(thisArg, args[0], args[1]);\n    case 3: return func.call(thisArg, args[0], args[1], args[2]);\n  }\n  return func.apply(thisArg, args);\n}\n\nexport default apply;\n","/**\n * This method returns `undefined`.\n *\n * @static\n * @memberOf _\n * @since 2.3.0\n * @category Util\n * @example\n *\n * _.times(2, _.noop);\n * // => [undefined, undefined]\n */\nfunction noop() {\n  // No operation performed.\n}\n\nexport default noop;\n","/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\nexport default copyArray;\n","/** Used to detect hot functions by number of calls within a span of milliseconds. */\nvar HOT_COUNT = 800,\n    HOT_SPAN = 16;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeNow = Date.now;\n\n/**\n * Creates a function that'll short out and invoke `identity` instead\n * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n * milliseconds.\n *\n * @private\n * @param {Function} func The function to restrict.\n * @returns {Function} Returns the new shortable function.\n */\nfunction shortOut(func) {\n  var count = 0,\n      lastCalled = 0;\n\n  return function() {\n    var stamp = nativeNow(),\n        remaining = HOT_SPAN - (stamp - lastCalled);\n\n    lastCalled = stamp;\n    if (remaining > 0) {\n      if (++count >= HOT_COUNT) {\n        return arguments[0];\n      }\n    } else {\n      count = 0;\n    }\n    return func.apply(undefined, arguments);\n  };\n}\n\nexport default shortOut;\n","/**\n * Creates a function that returns `value`.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {*} value The value to return from the new function.\n * @returns {Function} Returns the new constant function.\n * @example\n *\n * var objects = _.times(2, _.constant({ 'a': 1 }));\n *\n * console.log(objects);\n * // => [{ 'a': 1 }, { 'a': 1 }]\n *\n * console.log(objects[0] === objects[1]);\n * // => true\n */\nfunction constant(value) {\n  return function() {\n    return value;\n  };\n}\n\nexport default constant;\n","import getNative from './_getNative.js';\n\nvar defineProperty = (function() {\n  try {\n    var func = getNative(Object, 'defineProperty');\n    func({}, '', {});\n    return func;\n  } catch (e) {}\n}());\n\nexport default defineProperty;\n","import constant from './constant.js';\nimport defineProperty from './_defineProperty.js';\nimport identity from './identity.js';\n\n/**\n * The base implementation of `setToString` without support for hot loop shorting.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar baseSetToString = !defineProperty ? identity : function(func, string) {\n  return defineProperty(func, 'toString', {\n    'configurable': true,\n    'enumerable': false,\n    'value': constant(string),\n    'writable': true\n  });\n};\n\nexport default baseSetToString;\n","import baseSetToString from './_baseSetToString.js';\nimport shortOut from './_shortOut.js';\n\n/**\n * Sets the `toString` method of `func` to return `string`.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar setToString = shortOut(baseSetToString);\n\nexport default setToString;\n","/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\nexport default arrayEach;\n","/**\n * The base implementation of `_.findIndex` and `_.findLastIndex` without\n * support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} predicate The function invoked per iteration.\n * @param {number} fromIndex The index to search from.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseFindIndex(array, predicate, fromIndex, fromRight) {\n  var length = array.length,\n      index = fromIndex + (fromRight ? 1 : -1);\n\n  while ((fromRight ? index-- : ++index < length)) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\nexport default baseFindIndex;\n","/**\n * The base implementation of `_.isNaN` without support for number objects.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n */\nfunction baseIsNaN(value) {\n  return value !== value;\n}\n\nexport default baseIsNaN;\n","/**\n * A specialized version of `_.indexOf` which performs strict equality\n * comparisons of values, i.e. `===`.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction strictIndexOf(array, value, fromIndex) {\n  var index = fromIndex - 1,\n      length = array.length;\n\n  while (++index < length) {\n    if (array[index] === value) {\n      return index;\n    }\n  }\n  return -1;\n}\n\nexport default strictIndexOf;\n","import baseFindIndex from './_baseFindIndex.js';\nimport baseIsNaN from './_baseIsNaN.js';\nimport strictIndexOf from './_strictIndexOf.js';\n\n/**\n * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseIndexOf(array, value, fromIndex) {\n  return value === value\n    ? strictIndexOf(array, value, fromIndex)\n    : baseFindIndex(array, baseIsNaN, fromIndex);\n}\n\nexport default baseIndexOf;\n","import baseIndexOf from './_baseIndexOf.js';\n\n/**\n * A specialized version of `_.includes` for arrays without support for\n * specifying an index to search from.\n *\n * @private\n * @param {Array} [array] The array to inspect.\n * @param {*} target The value to search for.\n * @returns {boolean} Returns `true` if `target` is found, else `false`.\n */\nfunction arrayIncludes(array, value) {\n  var length = array == null ? 0 : array.length;\n  return !!length && baseIndexOf(array, value, 0) > -1;\n}\n\nexport default arrayIncludes;\n","/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\nexport default isIndex;\n","import defineProperty from './_defineProperty.js';\n\n/**\n * The base implementation of `assignValue` and `assignMergeValue` without\n * value checks.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction baseAssignValue(object, key, value) {\n  if (key == '__proto__' && defineProperty) {\n    defineProperty(object, key, {\n      'configurable': true,\n      'enumerable': true,\n      'value': value,\n      'writable': true\n    });\n  } else {\n    object[key] = value;\n  }\n}\n\nexport default baseAssignValue;\n","/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\nexport default eq;\n","import baseAssignValue from './_baseAssignValue.js';\nimport eq from './eq.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    baseAssignValue(object, key, value);\n  }\n}\n\nexport default assignValue;\n","import assignValue from './_assignValue.js';\nimport baseAssignValue from './_baseAssignValue.js';\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  var isNew = !object;\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    if (newValue === undefined) {\n      newValue = source[key];\n    }\n    if (isNew) {\n      baseAssignValue(object, key, newValue);\n    } else {\n      assignValue(object, key, newValue);\n    }\n  }\n  return object;\n}\n\nexport default copyObject;\n","import apply from './_apply.js';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * A specialized version of `baseRest` which transforms the rest array.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @param {Function} transform The rest array transform.\n * @returns {Function} Returns the new function.\n */\nfunction overRest(func, start, transform) {\n  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n  return function() {\n    var args = arguments,\n        index = -1,\n        length = nativeMax(args.length - start, 0),\n        array = Array(length);\n\n    while (++index < length) {\n      array[index] = args[start + index];\n    }\n    index = -1;\n    var otherArgs = Array(start + 1);\n    while (++index < start) {\n      otherArgs[index] = args[index];\n    }\n    otherArgs[start] = transform(array);\n    return apply(func, this, otherArgs);\n  };\n}\n\nexport default overRest;\n","import identity from './identity.js';\nimport overRest from './_overRest.js';\nimport setToString from './_setToString.js';\n\n/**\n * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @returns {Function} Returns the new function.\n */\nfunction baseRest(func, start) {\n  return setToString(overRest(func, start, identity), func + '');\n}\n\nexport default baseRest;\n","/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\nexport default isLength;\n","import isFunction from './isFunction.js';\nimport isLength from './isLength.js';\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\nexport default isArrayLike;\n","import eq from './eq.js';\nimport isArrayLike from './isArrayLike.js';\nimport isIndex from './_isIndex.js';\nimport isObject from './isObject.js';\n\n/**\n * Checks if the given arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n *  else `false`.\n */\nfunction isIterateeCall(value, index, object) {\n  if (!isObject(object)) {\n    return false;\n  }\n  var type = typeof index;\n  if (type == 'number'\n        ? (isArrayLike(object) && isIndex(index, object.length))\n        : (type == 'string' && index in object)\n      ) {\n    return eq(object[index], value);\n  }\n  return false;\n}\n\nexport default isIterateeCall;\n","import baseRest from './_baseRest.js';\nimport isIterateeCall from './_isIterateeCall.js';\n\n/**\n * Creates a function like `_.assign`.\n *\n * @private\n * @param {Function} assigner The function to assign values.\n * @returns {Function} Returns the new assigner function.\n */\nfunction createAssigner(assigner) {\n  return baseRest(function(object, sources) {\n    var index = -1,\n        length = sources.length,\n        customizer = length > 1 ? sources[length - 1] : undefined,\n        guard = length > 2 ? sources[2] : undefined;\n\n    customizer = (assigner.length > 3 && typeof customizer == 'function')\n      ? (length--, customizer)\n      : undefined;\n\n    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n      customizer = length < 3 ? undefined : customizer;\n      length = 1;\n    }\n    object = Object(object);\n    while (++index < length) {\n      var source = sources[index];\n      if (source) {\n        assigner(object, source, index, customizer);\n      }\n    }\n    return object;\n  });\n}\n\nexport default createAssigner;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\nexport default isPrototype;\n","/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\nexport default baseTimes;\n","import baseGetTag from './_baseGetTag.js';\nimport isObjectLike from './isObjectLike.js';\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\nexport default baseIsArguments;\n","import baseIsArguments from './_baseIsArguments.js';\nimport isObjectLike from './isObjectLike.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\nexport default isArguments;\n","/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nexport default stubFalse;\n","import root from './_root.js';\nimport stubFalse from './stubFalse.js';\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\nexport default isBuffer;\n","import baseGetTag from './_baseGetTag.js';\nimport isLength from './isLength.js';\nimport isObjectLike from './isObjectLike.js';\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\nexport default baseIsTypedArray;\n","/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\nexport default baseUnary;\n","import freeGlobal from './_freeGlobal.js';\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    // Use `util.types` for Node.js 10+.\n    var types = freeModule && freeModule.require && freeModule.require('util').types;\n\n    if (types) {\n      return types;\n    }\n\n    // Legacy `process.binding('util')` for Node.js < 10.\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\nexport default nodeUtil;\n","import baseIsTypedArray from './_baseIsTypedArray.js';\nimport baseUnary from './_baseUnary.js';\nimport nodeUtil from './_nodeUtil.js';\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\nexport default isTypedArray;\n","import baseTimes from './_baseTimes.js';\nimport isArguments from './isArguments.js';\nimport isArray from './isArray.js';\nimport isBuffer from './isBuffer.js';\nimport isIndex from './_isIndex.js';\nimport isTypedArray from './isTypedArray.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nexport default arrayLikeKeys;\n","/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\nexport default overArg;\n","import overArg from './_overArg.js';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = overArg(Object.keys, Object);\n\nexport default nativeKeys;\n","import isPrototype from './_isPrototype.js';\nimport nativeKeys from './_nativeKeys.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nexport default baseKeys;\n","import arrayLikeKeys from './_arrayLikeKeys.js';\nimport baseKeys from './_baseKeys.js';\nimport isArrayLike from './isArrayLike.js';\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\nexport default keys;\n","import assignValue from './_assignValue.js';\nimport copyObject from './_copyObject.js';\nimport createAssigner from './_createAssigner.js';\nimport isArrayLike from './isArrayLike.js';\nimport isPrototype from './_isPrototype.js';\nimport keys from './keys.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Assigns own enumerable string keyed properties of source objects to the\n * destination object. Source objects are applied from left to right.\n * Subsequent sources overwrite property assignments of previous sources.\n *\n * **Note:** This method mutates `object` and is loosely based on\n * [`Object.assign`](https://mdn.io/Object/assign).\n *\n * @static\n * @memberOf _\n * @since 0.10.0\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @see _.assignIn\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * function Bar() {\n *   this.c = 3;\n * }\n *\n * Foo.prototype.b = 2;\n * Bar.prototype.d = 4;\n *\n * _.assign({ 'a': 0 }, new Foo, new Bar);\n * // => { 'a': 1, 'c': 3 }\n */\nvar assign = createAssigner(function(object, source) {\n  if (isPrototype(source) || isArrayLike(source)) {\n    copyObject(source, keys(source), object);\n    return;\n  }\n  for (var key in source) {\n    if (hasOwnProperty.call(source, key)) {\n      assignValue(object, key, source[key]);\n    }\n  }\n});\n\nexport default assign;\n","/**\n * This function is like\n * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * except that it includes inherited enumerable properties.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction nativeKeysIn(object) {\n  var result = [];\n  if (object != null) {\n    for (var key in Object(object)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nexport default nativeKeysIn;\n","import isObject from './isObject.js';\nimport isPrototype from './_isPrototype.js';\nimport nativeKeysIn from './_nativeKeysIn.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeysIn(object) {\n  if (!isObject(object)) {\n    return nativeKeysIn(object);\n  }\n  var isProto = isPrototype(object),\n      result = [];\n\n  for (var key in object) {\n    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nexport default baseKeysIn;\n","import arrayLikeKeys from './_arrayLikeKeys.js';\nimport baseKeysIn from './_baseKeysIn.js';\nimport isArrayLike from './isArrayLike.js';\n\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\nfunction keysIn(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n}\n\nexport default keysIn;\n","import isArray from './isArray.js';\nimport isSymbol from './isSymbol.js';\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/;\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\nexport default isKey;\n","import getNative from './_getNative.js';\n\n/* Built-in method references that are verified to be native. */\nvar nativeCreate = getNative(Object, 'create');\n\nexport default nativeCreate;\n","import nativeCreate from './_nativeCreate.js';\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\nexport default hashClear;\n","/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nexport default hashDelete;\n","import nativeCreate from './_nativeCreate.js';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\nexport default hashGet;\n","import nativeCreate from './_nativeCreate.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\nexport default hashHas;\n","import nativeCreate from './_nativeCreate.js';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\nexport default hashSet;\n","import hashClear from './_hashClear.js';\nimport hashDelete from './_hashDelete.js';\nimport hashGet from './_hashGet.js';\nimport hashHas from './_hashHas.js';\nimport hashSet from './_hashSet.js';\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\nexport default Hash;\n","/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\nexport default listCacheClear;\n","import eq from './eq.js';\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\nexport default assocIndexOf;\n","import assocIndexOf from './_assocIndexOf.js';\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\nexport default listCacheDelete;\n","import assocIndexOf from './_assocIndexOf.js';\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\nexport default listCacheGet;\n","import assocIndexOf from './_assocIndexOf.js';\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\nexport default listCacheHas;\n","import assocIndexOf from './_assocIndexOf.js';\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\nexport default listCacheSet;\n","import listCacheClear from './_listCacheClear.js';\nimport listCacheDelete from './_listCacheDelete.js';\nimport listCacheGet from './_listCacheGet.js';\nimport listCacheHas from './_listCacheHas.js';\nimport listCacheSet from './_listCacheSet.js';\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\nexport default ListCache;\n","import getNative from './_getNative.js';\nimport root from './_root.js';\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map');\n\nexport default Map;\n","import Hash from './_Hash.js';\nimport ListCache from './_ListCache.js';\nimport Map from './_Map.js';\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\nexport default mapCacheClear;\n","/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\nexport default isKeyable;\n","import isKeyable from './_isKeyable.js';\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\nexport default getMapData;\n","import getMapData from './_getMapData.js';\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nexport default mapCacheDelete;\n","import getMapData from './_getMapData.js';\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\nexport default mapCacheGet;\n","import getMapData from './_getMapData.js';\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\nexport default mapCacheHas;\n","import getMapData from './_getMapData.js';\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\nexport default mapCacheSet;\n","import mapCacheClear from './_mapCacheClear.js';\nimport mapCacheDelete from './_mapCacheDelete.js';\nimport mapCacheGet from './_mapCacheGet.js';\nimport mapCacheHas from './_mapCacheHas.js';\nimport mapCacheSet from './_mapCacheSet.js';\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\nexport default MapCache;\n","import MapCache from './_MapCache.js';\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = MapCache;\n\nexport default memoize;\n","import memoize from './memoize.js';\n\n/** Used as the maximum memoize cache size. */\nvar MAX_MEMOIZE_SIZE = 500;\n\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */\nfunction memoizeCapped(func) {\n  var result = memoize(func, function(key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n\n  var cache = result.cache;\n  return result;\n}\n\nexport default memoizeCapped;\n","import memoizeCapped from './_memoizeCapped.js';\n\n/** Used to match property names within property paths. */\nvar rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoizeCapped(function(string) {\n  var result = [];\n  if (string.charCodeAt(0) === 46 /* . */) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, subString) {\n    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\nexport default stringToPath;\n","import baseToString from './_baseToString.js';\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\nexport default toString;\n","import isArray from './isArray.js';\nimport isKey from './_isKey.js';\nimport stringToPath from './_stringToPath.js';\nimport toString from './toString.js';\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value, object) {\n  if (isArray(value)) {\n    return value;\n  }\n  return isKey(value, object) ? [value] : stringToPath(toString(value));\n}\n\nexport default castPath;\n","import isSymbol from './isSymbol.js';\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nexport default toKey;\n","import castPath from './_castPath.js';\nimport toKey from './_toKey.js';\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = castPath(path, object);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\nexport default baseGet;\n","import baseGet from './_baseGet.js';\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\nexport default get;\n","/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\nexport default arrayPush;\n","import Symbol from './_Symbol.js';\nimport isArguments from './isArguments.js';\nimport isArray from './isArray.js';\n\n/** Built-in value references. */\nvar spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;\n\n/**\n * Checks if `value` is a flattenable `arguments` object or array.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n */\nfunction isFlattenable(value) {\n  return isArray(value) || isArguments(value) ||\n    !!(spreadableSymbol && value && value[spreadableSymbol]);\n}\n\nexport default isFlattenable;\n","import arrayPush from './_arrayPush.js';\nimport isFlattenable from './_isFlattenable.js';\n\n/**\n * The base implementation of `_.flatten` with support for restricting flattening.\n *\n * @private\n * @param {Array} array The array to flatten.\n * @param {number} depth The maximum recursion depth.\n * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n * @param {Array} [result=[]] The initial result value.\n * @returns {Array} Returns the new flattened array.\n */\nfunction baseFlatten(array, depth, predicate, isStrict, result) {\n  var index = -1,\n      length = array.length;\n\n  predicate || (predicate = isFlattenable);\n  result || (result = []);\n\n  while (++index < length) {\n    var value = array[index];\n    if (depth > 0 && predicate(value)) {\n      if (depth > 1) {\n        // Recursively flatten arrays (susceptible to call stack limits).\n        baseFlatten(value, depth - 1, predicate, isStrict, result);\n      } else {\n        arrayPush(result, value);\n      }\n    } else if (!isStrict) {\n      result[result.length] = value;\n    }\n  }\n  return result;\n}\n\nexport default baseFlatten;\n","import baseFlatten from './_baseFlatten.js';\n\n/**\n * Flattens `array` a single level deep.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to flatten.\n * @returns {Array} Returns the new flattened array.\n * @example\n *\n * _.flatten([1, [2, [3, [4]], 5]]);\n * // => [1, 2, [3, [4]], 5]\n */\nfunction flatten(array) {\n  var length = array == null ? 0 : array.length;\n  return length ? baseFlatten(array, 1) : [];\n}\n\nexport default flatten;\n","import overArg from './_overArg.js';\n\n/** Built-in value references. */\nvar getPrototype = overArg(Object.getPrototypeOf, Object);\n\nexport default getPrototype;\n","/**\n * The base implementation of `_.slice` without an iteratee call guard.\n *\n * @private\n * @param {Array} array The array to slice.\n * @param {number} [start=0] The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the slice of `array`.\n */\nfunction baseSlice(array, start, end) {\n  var index = -1,\n      length = array.length;\n\n  if (start < 0) {\n    start = -start > length ? 0 : (length + start);\n  }\n  end = end > length ? length : end;\n  if (end < 0) {\n    end += length;\n  }\n  length = start > end ? 0 : ((end - start) >>> 0);\n  start >>>= 0;\n\n  var result = Array(length);\n  while (++index < length) {\n    result[index] = array[index + start];\n  }\n  return result;\n}\n\nexport default baseSlice;\n","/**\n * A specialized version of `_.reduce` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @param {boolean} [initAccum] Specify using the first element of `array` as\n *  the initial value.\n * @returns {*} Returns the accumulated value.\n */\nfunction arrayReduce(array, iteratee, accumulator, initAccum) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  if (initAccum && length) {\n    accumulator = array[++index];\n  }\n  while (++index < length) {\n    accumulator = iteratee(accumulator, array[index], index, array);\n  }\n  return accumulator;\n}\n\nexport default arrayReduce;\n","import ListCache from './_ListCache.js';\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\nexport default stackClear;\n","/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\nexport default stackDelete;\n","/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\nexport default stackGet;\n","/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\nexport default stackHas;\n","import ListCache from './_ListCache.js';\nimport Map from './_Map.js';\nimport MapCache from './_MapCache.js';\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\nexport default stackSet;\n","import ListCache from './_ListCache.js';\nimport stackClear from './_stackClear.js';\nimport stackDelete from './_stackDelete.js';\nimport stackGet from './_stackGet.js';\nimport stackHas from './_stackHas.js';\nimport stackSet from './_stackSet.js';\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\nexport default Stack;\n","import copyObject from './_copyObject.js';\nimport keys from './keys.js';\n\n/**\n * The base implementation of `_.assign` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssign(object, source) {\n  return object && copyObject(source, keys(source), object);\n}\n\nexport default baseAssign;\n","import copyObject from './_copyObject.js';\nimport keysIn from './keysIn.js';\n\n/**\n * The base implementation of `_.assignIn` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssignIn(object, source) {\n  return object && copyObject(source, keysIn(source), object);\n}\n\nexport default baseAssignIn;\n","import root from './_root.js';\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;\n\n/**\n * Creates a clone of  `buffer`.\n *\n * @private\n * @param {Buffer} buffer The buffer to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Buffer} Returns the cloned buffer.\n */\nfunction cloneBuffer(buffer, isDeep) {\n  if (isDeep) {\n    return buffer.slice();\n  }\n  var length = buffer.length,\n      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n\n  buffer.copy(result);\n  return result;\n}\n\nexport default cloneBuffer;\n","/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\nexport default arrayFilter;\n","/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\nexport default stubArray;\n","import arrayFilter from './_arrayFilter.js';\nimport stubArray from './stubArray.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\nexport default getSymbols;\n","import copyObject from './_copyObject.js';\nimport getSymbols from './_getSymbols.js';\n\n/**\n * Copies own symbols of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbols(source, object) {\n  return copyObject(source, getSymbols(source), object);\n}\n\nexport default copySymbols;\n","import arrayPush from './_arrayPush.js';\nimport getPrototype from './_getPrototype.js';\nimport getSymbols from './_getSymbols.js';\nimport stubArray from './stubArray.js';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\n\n/**\n * Creates an array of the own and inherited enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {\n  var result = [];\n  while (object) {\n    arrayPush(result, getSymbols(object));\n    object = getPrototype(object);\n  }\n  return result;\n};\n\nexport default getSymbolsIn;\n","import copyObject from './_copyObject.js';\nimport getSymbolsIn from './_getSymbolsIn.js';\n\n/**\n * Copies own and inherited symbols of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbolsIn(source, object) {\n  return copyObject(source, getSymbolsIn(source), object);\n}\n\nexport default copySymbolsIn;\n","import arrayPush from './_arrayPush.js';\nimport isArray from './isArray.js';\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\nexport default baseGetAllKeys;\n","import baseGetAllKeys from './_baseGetAllKeys.js';\nimport getSymbols from './_getSymbols.js';\nimport keys from './keys.js';\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\nexport default getAllKeys;\n","import baseGetAllKeys from './_baseGetAllKeys.js';\nimport getSymbolsIn from './_getSymbolsIn.js';\nimport keysIn from './keysIn.js';\n\n/**\n * Creates an array of own and inherited enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeysIn(object) {\n  return baseGetAllKeys(object, keysIn, getSymbolsIn);\n}\n\nexport default getAllKeysIn;\n","import getNative from './_getNative.js';\nimport root from './_root.js';\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView');\n\nexport default DataView;\n","import getNative from './_getNative.js';\nimport root from './_root.js';\n\n/* Built-in method references that are verified to be native. */\nvar Promise = getNative(root, 'Promise');\n\nexport default Promise;\n","import getNative from './_getNative.js';\nimport root from './_root.js';\n\n/* Built-in method references that are verified to be native. */\nvar Set = getNative(root, 'Set');\n\nexport default Set;\n","import DataView from './_DataView.js';\nimport Map from './_Map.js';\nimport Promise from './_Promise.js';\nimport Set from './_Set.js';\nimport WeakMap from './_WeakMap.js';\nimport baseGetTag from './_baseGetTag.js';\nimport toSource from './_toSource.js';\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    setTag = '[object Set]',\n    weakMapTag = '[object WeakMap]';\n\nvar dataViewTag = '[object DataView]';\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\nexport default getTag;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Initializes an array clone.\n *\n * @private\n * @param {Array} array The array to clone.\n * @returns {Array} Returns the initialized clone.\n */\nfunction initCloneArray(array) {\n  var length = array.length,\n      result = new array.constructor(length);\n\n  // Add properties assigned by `RegExp#exec`.\n  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n    result.index = array.index;\n    result.input = array.input;\n  }\n  return result;\n}\n\nexport default initCloneArray;\n","import root from './_root.js';\n\n/** Built-in value references. */\nvar Uint8Array = root.Uint8Array;\n\nexport default Uint8Array;\n","import Uint8Array from './_Uint8Array.js';\n\n/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */\nfunction cloneArrayBuffer(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n  return result;\n}\n\nexport default cloneArrayBuffer;\n","import cloneArrayBuffer from './_cloneArrayBuffer.js';\n\n/**\n * Creates a clone of `dataView`.\n *\n * @private\n * @param {Object} dataView The data view to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned data view.\n */\nfunction cloneDataView(dataView, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n}\n\nexport default cloneDataView;\n","/** Used to match `RegExp` flags from their coerced string values. */\nvar reFlags = /\\w*$/;\n\n/**\n * Creates a clone of `regexp`.\n *\n * @private\n * @param {Object} regexp The regexp to clone.\n * @returns {Object} Returns the cloned regexp.\n */\nfunction cloneRegExp(regexp) {\n  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n  result.lastIndex = regexp.lastIndex;\n  return result;\n}\n\nexport default cloneRegExp;\n","import Symbol from './_Symbol.js';\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * Creates a clone of the `symbol` object.\n *\n * @private\n * @param {Object} symbol The symbol object to clone.\n * @returns {Object} Returns the cloned symbol object.\n */\nfunction cloneSymbol(symbol) {\n  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n}\n\nexport default cloneSymbol;\n","import cloneArrayBuffer from './_cloneArrayBuffer.js';\n\n/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */\nfunction cloneTypedArray(typedArray, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\n\nexport default cloneTypedArray;\n","import cloneArrayBuffer from './_cloneArrayBuffer.js';\nimport cloneDataView from './_cloneDataView.js';\nimport cloneRegExp from './_cloneRegExp.js';\nimport cloneSymbol from './_cloneSymbol.js';\nimport cloneTypedArray from './_cloneTypedArray.js';\n\n/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Initializes an object clone based on its `toStringTag`.\n *\n * **Note:** This function only supports cloning values with tags of\n * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.\n *\n * @private\n * @param {Object} object The object to clone.\n * @param {string} tag The `toStringTag` of the object to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneByTag(object, tag, isDeep) {\n  var Ctor = object.constructor;\n  switch (tag) {\n    case arrayBufferTag:\n      return cloneArrayBuffer(object);\n\n    case boolTag:\n    case dateTag:\n      return new Ctor(+object);\n\n    case dataViewTag:\n      return cloneDataView(object, isDeep);\n\n    case float32Tag: case float64Tag:\n    case int8Tag: case int16Tag: case int32Tag:\n    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n      return cloneTypedArray(object, isDeep);\n\n    case mapTag:\n      return new Ctor;\n\n    case numberTag:\n    case stringTag:\n      return new Ctor(object);\n\n    case regexpTag:\n      return cloneRegExp(object);\n\n    case setTag:\n      return new Ctor;\n\n    case symbolTag:\n      return cloneSymbol(object);\n  }\n}\n\nexport default initCloneByTag;\n","import baseCreate from './_baseCreate.js';\nimport getPrototype from './_getPrototype.js';\nimport isPrototype from './_isPrototype.js';\n\n/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneObject(object) {\n  return (typeof object.constructor == 'function' && !isPrototype(object))\n    ? baseCreate(getPrototype(object))\n    : {};\n}\n\nexport default initCloneObject;\n","import getTag from './_getTag.js';\nimport isObjectLike from './isObjectLike.js';\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]';\n\n/**\n * The base implementation of `_.isMap` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n */\nfunction baseIsMap(value) {\n  return isObjectLike(value) && getTag(value) == mapTag;\n}\n\nexport default baseIsMap;\n","import baseIsMap from './_baseIsMap.js';\nimport baseUnary from './_baseUnary.js';\nimport nodeUtil from './_nodeUtil.js';\n\n/* Node.js helper references. */\nvar nodeIsMap = nodeUtil && nodeUtil.isMap;\n\n/**\n * Checks if `value` is classified as a `Map` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n * @example\n *\n * _.isMap(new Map);\n * // => true\n *\n * _.isMap(new WeakMap);\n * // => false\n */\nvar isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;\n\nexport default isMap;\n","import getTag from './_getTag.js';\nimport isObjectLike from './isObjectLike.js';\n\n/** `Object#toString` result references. */\nvar setTag = '[object Set]';\n\n/**\n * The base implementation of `_.isSet` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n */\nfunction baseIsSet(value) {\n  return isObjectLike(value) && getTag(value) == setTag;\n}\n\nexport default baseIsSet;\n","import baseIsSet from './_baseIsSet.js';\nimport baseUnary from './_baseUnary.js';\nimport nodeUtil from './_nodeUtil.js';\n\n/* Node.js helper references. */\nvar nodeIsSet = nodeUtil && nodeUtil.isSet;\n\n/**\n * Checks if `value` is classified as a `Set` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n * @example\n *\n * _.isSet(new Set);\n * // => true\n *\n * _.isSet(new WeakSet);\n * // => false\n */\nvar isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;\n\nexport default isSet;\n","import Stack from './_Stack.js';\nimport arrayEach from './_arrayEach.js';\nimport assignValue from './_assignValue.js';\nimport baseAssign from './_baseAssign.js';\nimport baseAssignIn from './_baseAssignIn.js';\nimport cloneBuffer from './_cloneBuffer.js';\nimport copyArray from './_copyArray.js';\nimport copySymbols from './_copySymbols.js';\nimport copySymbolsIn from './_copySymbolsIn.js';\nimport getAllKeys from './_getAllKeys.js';\nimport getAllKeysIn from './_getAllKeysIn.js';\nimport getTag from './_getTag.js';\nimport initCloneArray from './_initCloneArray.js';\nimport initCloneByTag from './_initCloneByTag.js';\nimport initCloneObject from './_initCloneObject.js';\nimport isArray from './isArray.js';\nimport isBuffer from './isBuffer.js';\nimport isMap from './isMap.js';\nimport isObject from './isObject.js';\nimport isSet from './isSet.js';\nimport keys from './keys.js';\nimport keysIn from './keysIn.js';\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_DEEP_FLAG = 1,\n    CLONE_FLAT_FLAG = 2,\n    CLONE_SYMBOLS_FLAG = 4;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values supported by `_.clone`. */\nvar cloneableTags = {};\ncloneableTags[argsTag] = cloneableTags[arrayTag] =\ncloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\ncloneableTags[boolTag] = cloneableTags[dateTag] =\ncloneableTags[float32Tag] = cloneableTags[float64Tag] =\ncloneableTags[int8Tag] = cloneableTags[int16Tag] =\ncloneableTags[int32Tag] = cloneableTags[mapTag] =\ncloneableTags[numberTag] = cloneableTags[objectTag] =\ncloneableTags[regexpTag] = cloneableTags[setTag] =\ncloneableTags[stringTag] = cloneableTags[symbolTag] =\ncloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\ncloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\ncloneableTags[errorTag] = cloneableTags[funcTag] =\ncloneableTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n * traversed objects.\n *\n * @private\n * @param {*} value The value to clone.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Deep clone\n *  2 - Flatten inherited properties\n *  4 - Clone symbols\n * @param {Function} [customizer] The function to customize cloning.\n * @param {string} [key] The key of `value`.\n * @param {Object} [object] The parent object of `value`.\n * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n * @returns {*} Returns the cloned value.\n */\nfunction baseClone(value, bitmask, customizer, key, object, stack) {\n  var result,\n      isDeep = bitmask & CLONE_DEEP_FLAG,\n      isFlat = bitmask & CLONE_FLAT_FLAG,\n      isFull = bitmask & CLONE_SYMBOLS_FLAG;\n\n  if (customizer) {\n    result = object ? customizer(value, key, object, stack) : customizer(value);\n  }\n  if (result !== undefined) {\n    return result;\n  }\n  if (!isObject(value)) {\n    return value;\n  }\n  var isArr = isArray(value);\n  if (isArr) {\n    result = initCloneArray(value);\n    if (!isDeep) {\n      return copyArray(value, result);\n    }\n  } else {\n    var tag = getTag(value),\n        isFunc = tag == funcTag || tag == genTag;\n\n    if (isBuffer(value)) {\n      return cloneBuffer(value, isDeep);\n    }\n    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n      result = (isFlat || isFunc) ? {} : initCloneObject(value);\n      if (!isDeep) {\n        return isFlat\n          ? copySymbolsIn(value, baseAssignIn(result, value))\n          : copySymbols(value, baseAssign(result, value));\n      }\n    } else {\n      if (!cloneableTags[tag]) {\n        return object ? value : {};\n      }\n      result = initCloneByTag(value, tag, isDeep);\n    }\n  }\n  // Check for circular references and return its corresponding clone.\n  stack || (stack = new Stack);\n  var stacked = stack.get(value);\n  if (stacked) {\n    return stacked;\n  }\n  stack.set(value, result);\n\n  if (isSet(value)) {\n    value.forEach(function(subValue) {\n      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));\n    });\n  } else if (isMap(value)) {\n    value.forEach(function(subValue, key) {\n      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));\n    });\n  }\n\n  var keysFunc = isFull\n    ? (isFlat ? getAllKeysIn : getAllKeys)\n    : (isFlat ? keysIn : keys);\n\n  var props = isArr ? undefined : keysFunc(value);\n  arrayEach(props || value, function(subValue, key) {\n    if (props) {\n      key = subValue;\n      subValue = value[key];\n    }\n    // Recursively populate clone (susceptible to call stack limits).\n    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));\n  });\n  return result;\n}\n\nexport default baseClone;\n","import baseClone from './_baseClone.js';\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_SYMBOLS_FLAG = 4;\n\n/**\n * Creates a shallow clone of `value`.\n *\n * **Note:** This method is loosely based on the\n * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)\n * and supports cloning arrays, array buffers, booleans, date objects, maps,\n * numbers, `Object` objects, regexes, sets, strings, symbols, and typed\n * arrays. The own enumerable properties of `arguments` objects are cloned\n * as plain objects. An empty object is returned for uncloneable values such\n * as error objects, functions, DOM nodes, and WeakMaps.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to clone.\n * @returns {*} Returns the cloned value.\n * @see _.cloneDeep\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var shallow = _.clone(objects);\n * console.log(shallow[0] === objects[0]);\n * // => true\n */\nfunction clone(value) {\n  return baseClone(value, CLONE_SYMBOLS_FLAG);\n}\n\nexport default clone;\n","/**\n * Creates an array with all falsey values removed. The values `false`, `null`,\n * `0`, `\"\"`, `undefined`, and `NaN` are falsey.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to compact.\n * @returns {Array} Returns the new array of filtered values.\n * @example\n *\n * _.compact([0, 1, false, 2, '', 3]);\n * // => [1, 2, 3]\n */\nfunction compact(array) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (value) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\nexport default compact;\n","/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\nexport default setCacheAdd;\n","/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\nexport default setCacheHas;\n","import MapCache from './_MapCache.js';\nimport setCacheAdd from './_setCacheAdd.js';\nimport setCacheHas from './_setCacheHas.js';\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values == null ? 0 : values.length;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\nexport default SetCache;\n","/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport default arraySome;\n","/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\nexport default cacheHas;\n","import SetCache from './_SetCache.js';\nimport arraySome from './_arraySome.js';\nimport cacheHas from './_cacheHas.js';\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Check that cyclic values are equal.\n  var arrStacked = stack.get(array);\n  var othStacked = stack.get(other);\n  if (arrStacked && othStacked) {\n    return arrStacked == other && othStacked == array;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!cacheHas(seen, othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, bitmask, customizer, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\nexport default equalArrays;\n","/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\nexport default mapToArray;\n","/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\nexport default setToArray;\n","import Symbol from './_Symbol.js';\nimport Uint8Array from './_Uint8Array.js';\nimport eq from './eq.js';\nimport equalArrays from './_equalArrays.js';\nimport mapToArray from './_mapToArray.js';\nimport setToArray from './_setToArray.js';\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]';\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\nexport default equalByTag;\n","import getAllKeys from './_getAllKeys.js';\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1;\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Check that cyclic values are equal.\n  var objStacked = stack.get(object);\n  var othStacked = stack.get(other);\n  if (objStacked && othStacked) {\n    return objStacked == other && othStacked == object;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\nexport default equalObjects;\n","import Stack from './_Stack.js';\nimport equalArrays from './_equalArrays.js';\nimport equalByTag from './_equalByTag.js';\nimport equalObjects from './_equalObjects.js';\nimport getTag from './_getTag.js';\nimport isArray from './isArray.js';\nimport isBuffer from './isBuffer.js';\nimport isTypedArray from './isTypedArray.js';\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = objIsArr ? arrayTag : getTag(object),\n      othTag = othIsArr ? arrayTag : getTag(other);\n\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && isBuffer(object)) {\n    if (!isBuffer(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\n\nexport default baseIsEqualDeep;\n","import baseIsEqualDeep from './_baseIsEqualDeep.js';\nimport isObjectLike from './isObjectLike.js';\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\n\nexport default baseIsEqual;\n","import Stack from './_Stack.js';\nimport baseIsEqual from './_baseIsEqual.js';\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * The base implementation of `_.isMatch` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property values to match.\n * @param {Array} matchData The property names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparisons.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */\nfunction baseIsMatch(object, source, matchData, customizer) {\n  var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer;\n\n  if (object == null) {\n    return !length;\n  }\n  object = Object(object);\n  while (index--) {\n    var data = matchData[index];\n    if ((noCustomizer && data[2])\n          ? data[1] !== object[data[0]]\n          : !(data[0] in object)\n        ) {\n      return false;\n    }\n  }\n  while (++index < length) {\n    data = matchData[index];\n    var key = data[0],\n        objValue = object[key],\n        srcValue = data[1];\n\n    if (noCustomizer && data[2]) {\n      if (objValue === undefined && !(key in object)) {\n        return false;\n      }\n    } else {\n      var stack = new Stack;\n      if (customizer) {\n        var result = customizer(objValue, srcValue, key, object, source, stack);\n      }\n      if (!(result === undefined\n            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\n            : result\n          )) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nexport default baseIsMatch;\n","import isObject from './isObject.js';\n\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */\nfunction isStrictComparable(value) {\n  return value === value && !isObject(value);\n}\n\nexport default isStrictComparable;\n","import isStrictComparable from './_isStrictComparable.js';\nimport keys from './keys.js';\n\n/**\n * Gets the property names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */\nfunction getMatchData(object) {\n  var result = keys(object),\n      length = result.length;\n\n  while (length--) {\n    var key = result[length],\n        value = object[key];\n\n    result[length] = [key, value, isStrictComparable(value)];\n  }\n  return result;\n}\n\nexport default getMatchData;\n","/**\n * A specialized version of `matchesProperty` for source values suitable\n * for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction matchesStrictComparable(key, srcValue) {\n  return function(object) {\n    if (object == null) {\n      return false;\n    }\n    return object[key] === srcValue &&\n      (srcValue !== undefined || (key in Object(object)));\n  };\n}\n\nexport default matchesStrictComparable;\n","import baseIsMatch from './_baseIsMatch.js';\nimport getMatchData from './_getMatchData.js';\nimport matchesStrictComparable from './_matchesStrictComparable.js';\n\n/**\n * The base implementation of `_.matches` which doesn't clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatches(source) {\n  var matchData = getMatchData(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n  }\n  return function(object) {\n    return object === source || baseIsMatch(object, source, matchData);\n  };\n}\n\nexport default baseMatches;\n","/**\n * The base implementation of `_.hasIn` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHasIn(object, key) {\n  return object != null && key in Object(object);\n}\n\nexport default baseHasIn;\n","import castPath from './_castPath.js';\nimport isArguments from './isArguments.js';\nimport isArray from './isArray.js';\nimport isIndex from './_isIndex.js';\nimport isLength from './isLength.js';\nimport toKey from './_toKey.js';\n\n/**\n * Checks if `path` exists on `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @param {Function} hasFunc The function to check properties.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n */\nfunction hasPath(object, path, hasFunc) {\n  path = castPath(path, object);\n\n  var index = -1,\n      length = path.length,\n      result = false;\n\n  while (++index < length) {\n    var key = toKey(path[index]);\n    if (!(result = object != null && hasFunc(object, key))) {\n      break;\n    }\n    object = object[key];\n  }\n  if (result || ++index != length) {\n    return result;\n  }\n  length = object == null ? 0 : object.length;\n  return !!length && isLength(length) && isIndex(key, length) &&\n    (isArray(object) || isArguments(object));\n}\n\nexport default hasPath;\n","import baseHasIn from './_baseHasIn.js';\nimport hasPath from './_hasPath.js';\n\n/**\n * Checks if `path` is a direct or inherited property of `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.hasIn(object, 'a');\n * // => true\n *\n * _.hasIn(object, 'a.b');\n * // => true\n *\n * _.hasIn(object, ['a', 'b']);\n * // => true\n *\n * _.hasIn(object, 'b');\n * // => false\n */\nfunction hasIn(object, path) {\n  return object != null && hasPath(object, path, baseHasIn);\n}\n\nexport default hasIn;\n","import baseIsEqual from './_baseIsEqual.js';\nimport get from './get.js';\nimport hasIn from './hasIn.js';\nimport isKey from './_isKey.js';\nimport isStrictComparable from './_isStrictComparable.js';\nimport matchesStrictComparable from './_matchesStrictComparable.js';\nimport toKey from './_toKey.js';\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatchesProperty(path, srcValue) {\n  if (isKey(path) && isStrictComparable(srcValue)) {\n    return matchesStrictComparable(toKey(path), srcValue);\n  }\n  return function(object) {\n    var objValue = get(object, path);\n    return (objValue === undefined && objValue === srcValue)\n      ? hasIn(object, path)\n      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n  };\n}\n\nexport default baseMatchesProperty;\n","/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\nexport default baseProperty;\n","import baseGet from './_baseGet.js';\n\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyDeep(path) {\n  return function(object) {\n    return baseGet(object, path);\n  };\n}\n\nexport default basePropertyDeep;\n","import baseProperty from './_baseProperty.js';\nimport basePropertyDeep from './_basePropertyDeep.js';\nimport isKey from './_isKey.js';\nimport toKey from './_toKey.js';\n\n/**\n * Creates a function that returns the value at `path` of a given object.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n * @example\n *\n * var objects = [\n *   { 'a': { 'b': 2 } },\n *   { 'a': { 'b': 1 } }\n * ];\n *\n * _.map(objects, _.property('a.b'));\n * // => [2, 1]\n *\n * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n * // => [1, 2]\n */\nfunction property(path) {\n  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n}\n\nexport default property;\n","import baseMatches from './_baseMatches.js';\nimport baseMatchesProperty from './_baseMatchesProperty.js';\nimport identity from './identity.js';\nimport isArray from './isArray.js';\nimport property from './property.js';\n\n/**\n * The base implementation of `_.iteratee`.\n *\n * @private\n * @param {*} [value=_.identity] The value to convert to an iteratee.\n * @returns {Function} Returns the iteratee.\n */\nfunction baseIteratee(value) {\n  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n  if (typeof value == 'function') {\n    return value;\n  }\n  if (value == null) {\n    return identity;\n  }\n  if (typeof value == 'object') {\n    return isArray(value)\n      ? baseMatchesProperty(value[0], value[1])\n      : baseMatches(value);\n  }\n  return property(value);\n}\n\nexport default baseIteratee;\n","/**\n * A specialized version of `baseAggregator` for arrays.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} setter The function to set `accumulator` values.\n * @param {Function} iteratee The iteratee to transform keys.\n * @param {Object} accumulator The initial aggregated object.\n * @returns {Function} Returns `accumulator`.\n */\nfunction arrayAggregator(array, setter, iteratee, accumulator) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    var value = array[index];\n    setter(accumulator, value, iteratee(value), array);\n  }\n  return accumulator;\n}\n\nexport default arrayAggregator;\n","/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\nexport default createBaseFor;\n","import createBaseFor from './_createBaseFor.js';\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\nexport default baseFor;\n","import baseFor from './_baseFor.js';\nimport keys from './keys.js';\n\n/**\n * The base implementation of `_.forOwn` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return object && baseFor(object, iteratee, keys);\n}\n\nexport default baseForOwn;\n","import isArrayLike from './isArrayLike.js';\n\n/**\n * Creates a `baseEach` or `baseEachRight` function.\n *\n * @private\n * @param {Function} eachFunc The function to iterate over a collection.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseEach(eachFunc, fromRight) {\n  return function(collection, iteratee) {\n    if (collection == null) {\n      return collection;\n    }\n    if (!isArrayLike(collection)) {\n      return eachFunc(collection, iteratee);\n    }\n    var length = collection.length,\n        index = fromRight ? length : -1,\n        iterable = Object(collection);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (iteratee(iterable[index], index, iterable) === false) {\n        break;\n      }\n    }\n    return collection;\n  };\n}\n\nexport default createBaseEach;\n","import baseForOwn from './_baseForOwn.js';\nimport createBaseEach from './_createBaseEach.js';\n\n/**\n * The base implementation of `_.forEach` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n */\nvar baseEach = createBaseEach(baseForOwn);\n\nexport default baseEach;\n","import baseEach from './_baseEach.js';\n\n/**\n * Aggregates elements of `collection` on `accumulator` with keys transformed\n * by `iteratee` and values set by `setter`.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} setter The function to set `accumulator` values.\n * @param {Function} iteratee The iteratee to transform keys.\n * @param {Object} accumulator The initial aggregated object.\n * @returns {Function} Returns `accumulator`.\n */\nfunction baseAggregator(collection, setter, iteratee, accumulator) {\n  baseEach(collection, function(value, key, collection) {\n    setter(accumulator, value, iteratee(value), collection);\n  });\n  return accumulator;\n}\n\nexport default baseAggregator;\n","import arrayAggregator from './_arrayAggregator.js';\nimport baseAggregator from './_baseAggregator.js';\nimport baseIteratee from './_baseIteratee.js';\nimport isArray from './isArray.js';\n\n/**\n * Creates a function like `_.groupBy`.\n *\n * @private\n * @param {Function} setter The function to set accumulator values.\n * @param {Function} [initializer] The accumulator object initializer.\n * @returns {Function} Returns the new aggregator function.\n */\nfunction createAggregator(setter, initializer) {\n  return function(collection, iteratee) {\n    var func = isArray(collection) ? arrayAggregator : baseAggregator,\n        accumulator = initializer ? initializer() : {};\n\n    return func(collection, setter, baseIteratee(iteratee, 2), accumulator);\n  };\n}\n\nexport default createAggregator;\n","import baseRest from './_baseRest.js';\nimport eq from './eq.js';\nimport isIterateeCall from './_isIterateeCall.js';\nimport keysIn from './keysIn.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Assigns own and inherited enumerable string keyed properties of source\n * objects to the destination object for all destination properties that\n * resolve to `undefined`. Source objects are applied from left to right.\n * Once a property is set, additional values of the same property are ignored.\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @see _.defaultsDeep\n * @example\n *\n * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n * // => { 'a': 1, 'b': 2 }\n */\nvar defaults = baseRest(function(object, sources) {\n  object = Object(object);\n\n  var index = -1;\n  var length = sources.length;\n  var guard = length > 2 ? sources[2] : undefined;\n\n  if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n    length = 1;\n  }\n\n  while (++index < length) {\n    var source = sources[index];\n    var props = keysIn(source);\n    var propsIndex = -1;\n    var propsLength = props.length;\n\n    while (++propsIndex < propsLength) {\n      var key = props[propsIndex];\n      var value = object[key];\n\n      if (value === undefined ||\n          (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {\n        object[key] = source[key];\n      }\n    }\n  }\n\n  return object;\n});\n\nexport default defaults;\n","import isArrayLike from './isArrayLike.js';\nimport isObjectLike from './isObjectLike.js';\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\nexport default isArrayLikeObject;\n","/**\n * This function is like `arrayIncludes` except that it accepts a comparator.\n *\n * @private\n * @param {Array} [array] The array to inspect.\n * @param {*} target The value to search for.\n * @param {Function} comparator The comparator invoked per element.\n * @returns {boolean} Returns `true` if `target` is found, else `false`.\n */\nfunction arrayIncludesWith(array, value, comparator) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (comparator(value, array[index])) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport default arrayIncludesWith;\n","import SetCache from './_SetCache.js';\nimport arrayIncludes from './_arrayIncludes.js';\nimport arrayIncludesWith from './_arrayIncludesWith.js';\nimport arrayMap from './_arrayMap.js';\nimport baseUnary from './_baseUnary.js';\nimport cacheHas from './_cacheHas.js';\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * The base implementation of methods like `_.difference` without support\n * for excluding multiple arrays or iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Array} values The values to exclude.\n * @param {Function} [iteratee] The iteratee invoked per element.\n * @param {Function} [comparator] The comparator invoked per element.\n * @returns {Array} Returns the new array of filtered values.\n */\nfunction baseDifference(array, values, iteratee, comparator) {\n  var index = -1,\n      includes = arrayIncludes,\n      isCommon = true,\n      length = array.length,\n      result = [],\n      valuesLength = values.length;\n\n  if (!length) {\n    return result;\n  }\n  if (iteratee) {\n    values = arrayMap(values, baseUnary(iteratee));\n  }\n  if (comparator) {\n    includes = arrayIncludesWith;\n    isCommon = false;\n  }\n  else if (values.length >= LARGE_ARRAY_SIZE) {\n    includes = cacheHas;\n    isCommon = false;\n    values = new SetCache(values);\n  }\n  outer:\n  while (++index < length) {\n    var value = array[index],\n        computed = iteratee == null ? value : iteratee(value);\n\n    value = (comparator || value !== 0) ? value : 0;\n    if (isCommon && computed === computed) {\n      var valuesIndex = valuesLength;\n      while (valuesIndex--) {\n        if (values[valuesIndex] === computed) {\n          continue outer;\n        }\n      }\n      result.push(value);\n    }\n    else if (!includes(values, computed, comparator)) {\n      result.push(value);\n    }\n  }\n  return result;\n}\n\nexport default baseDifference;\n","import baseDifference from './_baseDifference.js';\nimport baseFlatten from './_baseFlatten.js';\nimport baseRest from './_baseRest.js';\nimport isArrayLikeObject from './isArrayLikeObject.js';\n\n/**\n * Creates an array of `array` values not included in the other given arrays\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons. The order and references of result values are\n * determined by the first array.\n *\n * **Note:** Unlike `_.pullAll`, this method returns a new array.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {...Array} [values] The values to exclude.\n * @returns {Array} Returns the new array of filtered values.\n * @see _.without, _.xor\n * @example\n *\n * _.difference([2, 1], [2, 3]);\n * // => [1]\n */\nvar difference = baseRest(function(array, values) {\n  return isArrayLikeObject(array)\n    ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))\n    : [];\n});\n\nexport default difference;\n","/**\n * Gets the last element of `array`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to query.\n * @returns {*} Returns the last element of `array`.\n * @example\n *\n * _.last([1, 2, 3]);\n * // => 3\n */\nfunction last(array) {\n  var length = array == null ? 0 : array.length;\n  return length ? array[length - 1] : undefined;\n}\n\nexport default last;\n","import baseSlice from './_baseSlice.js';\nimport toInteger from './toInteger.js';\n\n/**\n * Creates a slice of `array` with `n` elements dropped from the beginning.\n *\n * @static\n * @memberOf _\n * @since 0.5.0\n * @category Array\n * @param {Array} array The array to query.\n * @param {number} [n=1] The number of elements to drop.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {Array} Returns the slice of `array`.\n * @example\n *\n * _.drop([1, 2, 3]);\n * // => [2, 3]\n *\n * _.drop([1, 2, 3], 2);\n * // => [3]\n *\n * _.drop([1, 2, 3], 5);\n * // => []\n *\n * _.drop([1, 2, 3], 0);\n * // => [1, 2, 3]\n */\nfunction drop(array, n, guard) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return [];\n  }\n  n = (guard || n === undefined) ? 1 : toInteger(n);\n  return baseSlice(array, n < 0 ? 0 : n, length);\n}\n\nexport default drop;\n","import baseSlice from './_baseSlice.js';\nimport toInteger from './toInteger.js';\n\n/**\n * Creates a slice of `array` with `n` elements dropped from the end.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Array\n * @param {Array} array The array to query.\n * @param {number} [n=1] The number of elements to drop.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {Array} Returns the slice of `array`.\n * @example\n *\n * _.dropRight([1, 2, 3]);\n * // => [1, 2]\n *\n * _.dropRight([1, 2, 3], 2);\n * // => [1]\n *\n * _.dropRight([1, 2, 3], 5);\n * // => []\n *\n * _.dropRight([1, 2, 3], 0);\n * // => [1, 2, 3]\n */\nfunction dropRight(array, n, guard) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return [];\n  }\n  n = (guard || n === undefined) ? 1 : toInteger(n);\n  n = length - n;\n  return baseSlice(array, 0, n < 0 ? 0 : n);\n}\n\nexport default dropRight;\n","import identity from './identity.js';\n\n/**\n * Casts `value` to `identity` if it's not a function.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {Function} Returns cast function.\n */\nfunction castFunction(value) {\n  return typeof value == 'function' ? value : identity;\n}\n\nexport default castFunction;\n","import arrayEach from './_arrayEach.js';\nimport baseEach from './_baseEach.js';\nimport castFunction from './_castFunction.js';\nimport isArray from './isArray.js';\n\n/**\n * Iterates over elements of `collection` and invokes `iteratee` for each element.\n * The iteratee is invoked with three arguments: (value, index|key, collection).\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * **Note:** As with other \"Collections\" methods, objects with a \"length\"\n * property are iterated like arrays. To avoid this behavior use `_.forIn`\n * or `_.forOwn` for object iteration.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @alias each\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n * @see _.forEachRight\n * @example\n *\n * _.forEach([1, 2], function(value) {\n *   console.log(value);\n * });\n * // => Logs `1` then `2`.\n *\n * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {\n *   console.log(key);\n * });\n * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n */\nfunction forEach(collection, iteratee) {\n  var func = isArray(collection) ? arrayEach : baseEach;\n  return func(collection, castFunction(iteratee));\n}\n\nexport default forEach;\n","/**\n * A specialized version of `_.every` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if all elements pass the predicate check,\n *  else `false`.\n */\nfunction arrayEvery(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (!predicate(array[index], index, array)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport default arrayEvery;\n","import baseEach from './_baseEach.js';\n\n/**\n * The base implementation of `_.every` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if all elements pass the predicate check,\n *  else `false`\n */\nfunction baseEvery(collection, predicate) {\n  var result = true;\n  baseEach(collection, function(value, index, collection) {\n    result = !!predicate(value, index, collection);\n    return result;\n  });\n  return result;\n}\n\nexport default baseEvery;\n","import arrayEvery from './_arrayEvery.js';\nimport baseEvery from './_baseEvery.js';\nimport baseIteratee from './_baseIteratee.js';\nimport isArray from './isArray.js';\nimport isIterateeCall from './_isIterateeCall.js';\n\n/**\n * Checks if `predicate` returns truthy for **all** elements of `collection`.\n * Iteration is stopped once `predicate` returns falsey. The predicate is\n * invoked with three arguments: (value, index|key, collection).\n *\n * **Note:** This method returns `true` for\n * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because\n * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of\n * elements of empty collections.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {boolean} Returns `true` if all elements pass the predicate check,\n *  else `false`.\n * @example\n *\n * _.every([true, 1, null, 'yes'], Boolean);\n * // => false\n *\n * var users = [\n *   { 'user': 'barney', 'age': 36, 'active': false },\n *   { 'user': 'fred',   'age': 40, 'active': false }\n * ];\n *\n * // The `_.matches` iteratee shorthand.\n * _.every(users, { 'user': 'barney', 'active': false });\n * // => false\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.every(users, ['active', false]);\n * // => true\n *\n * // The `_.property` iteratee shorthand.\n * _.every(users, 'active');\n * // => false\n */\nfunction every(collection, predicate, guard) {\n  var func = isArray(collection) ? arrayEvery : baseEvery;\n  if (guard && isIterateeCall(collection, predicate, guard)) {\n    predicate = undefined;\n  }\n  return func(collection, baseIteratee(predicate, 3));\n}\n\nexport default every;\n","import baseEach from './_baseEach.js';\n\n/**\n * The base implementation of `_.filter` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction baseFilter(collection, predicate) {\n  var result = [];\n  baseEach(collection, function(value, index, collection) {\n    if (predicate(value, index, collection)) {\n      result.push(value);\n    }\n  });\n  return result;\n}\n\nexport default baseFilter;\n","import arrayFilter from './_arrayFilter.js';\nimport baseFilter from './_baseFilter.js';\nimport baseIteratee from './_baseIteratee.js';\nimport isArray from './isArray.js';\n\n/**\n * Iterates over elements of `collection`, returning an array of all elements\n * `predicate` returns truthy for. The predicate is invoked with three\n * arguments: (value, index|key, collection).\n *\n * **Note:** Unlike `_.remove`, this method returns a new array.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n * @see _.reject\n * @example\n *\n * var users = [\n *   { 'user': 'barney', 'age': 36, 'active': true },\n *   { 'user': 'fred',   'age': 40, 'active': false }\n * ];\n *\n * _.filter(users, function(o) { return !o.active; });\n * // => objects for ['fred']\n *\n * // The `_.matches` iteratee shorthand.\n * _.filter(users, { 'age': 36, 'active': true });\n * // => objects for ['barney']\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.filter(users, ['active', false]);\n * // => objects for ['fred']\n *\n * // The `_.property` iteratee shorthand.\n * _.filter(users, 'active');\n * // => objects for ['barney']\n *\n * // Combining several predicates using `_.overEvery` or `_.overSome`.\n * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));\n * // => objects for ['fred', 'barney']\n */\nfunction filter(collection, predicate) {\n  var func = isArray(collection) ? arrayFilter : baseFilter;\n  return func(collection, baseIteratee(predicate, 3));\n}\n\nexport default filter;\n","import baseIteratee from './_baseIteratee.js';\nimport isArrayLike from './isArrayLike.js';\nimport keys from './keys.js';\n\n/**\n * Creates a `_.find` or `_.findLast` function.\n *\n * @private\n * @param {Function} findIndexFunc The function to find the collection index.\n * @returns {Function} Returns the new find function.\n */\nfunction createFind(findIndexFunc) {\n  return function(collection, predicate, fromIndex) {\n    var iterable = Object(collection);\n    if (!isArrayLike(collection)) {\n      var iteratee = baseIteratee(predicate, 3);\n      collection = keys(collection);\n      predicate = function(key) { return iteratee(iterable[key], key, iterable); };\n    }\n    var index = findIndexFunc(collection, predicate, fromIndex);\n    return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;\n  };\n}\n\nexport default createFind;\n","import baseFindIndex from './_baseFindIndex.js';\nimport baseIteratee from './_baseIteratee.js';\nimport toInteger from './toInteger.js';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * This method is like `_.find` except that it returns the index of the first\n * element `predicate` returns truthy for instead of the element itself.\n *\n * @static\n * @memberOf _\n * @since 1.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {number} Returns the index of the found element, else `-1`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'active': false },\n *   { 'user': 'fred',    'active': false },\n *   { 'user': 'pebbles', 'active': true }\n * ];\n *\n * _.findIndex(users, function(o) { return o.user == 'barney'; });\n * // => 0\n *\n * // The `_.matches` iteratee shorthand.\n * _.findIndex(users, { 'user': 'fred', 'active': false });\n * // => 1\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.findIndex(users, ['active', false]);\n * // => 0\n *\n * // The `_.property` iteratee shorthand.\n * _.findIndex(users, 'active');\n * // => 2\n */\nfunction findIndex(array, predicate, fromIndex) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return -1;\n  }\n  var index = fromIndex == null ? 0 : toInteger(fromIndex);\n  if (index < 0) {\n    index = nativeMax(length + index, 0);\n  }\n  return baseFindIndex(array, baseIteratee(predicate, 3), index);\n}\n\nexport default findIndex;\n","import createFind from './_createFind.js';\nimport findIndex from './findIndex.js';\n\n/**\n * Iterates over elements of `collection`, returning the first element\n * `predicate` returns truthy for. The predicate is invoked with three\n * arguments: (value, index|key, collection).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to inspect.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {*} Returns the matched element, else `undefined`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'age': 36, 'active': true },\n *   { 'user': 'fred',    'age': 40, 'active': false },\n *   { 'user': 'pebbles', 'age': 1,  'active': true }\n * ];\n *\n * _.find(users, function(o) { return o.age < 40; });\n * // => object for 'barney'\n *\n * // The `_.matches` iteratee shorthand.\n * _.find(users, { 'age': 1, 'active': true });\n * // => object for 'pebbles'\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.find(users, ['active', false]);\n * // => object for 'fred'\n *\n * // The `_.property` iteratee shorthand.\n * _.find(users, 'active');\n * // => object for 'barney'\n */\nvar find = createFind(findIndex);\n\nexport default find;\n","/**\n * Gets the first element of `array`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @alias first\n * @category Array\n * @param {Array} array The array to query.\n * @returns {*} Returns the first element of `array`.\n * @example\n *\n * _.head([1, 2, 3]);\n * // => 1\n *\n * _.head([]);\n * // => undefined\n */\nfunction head(array) {\n  return (array && array.length) ? array[0] : undefined;\n}\n\nexport default head;\n","import baseEach from './_baseEach.js';\nimport isArrayLike from './isArrayLike.js';\n\n/**\n * The base implementation of `_.map` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction baseMap(collection, iteratee) {\n  var index = -1,\n      result = isArrayLike(collection) ? Array(collection.length) : [];\n\n  baseEach(collection, function(value, key, collection) {\n    result[++index] = iteratee(value, key, collection);\n  });\n  return result;\n}\n\nexport default baseMap;\n","import arrayMap from './_arrayMap.js';\nimport baseIteratee from './_baseIteratee.js';\nimport baseMap from './_baseMap.js';\nimport isArray from './isArray.js';\n\n/**\n * Creates an array of values by running each element in `collection` thru\n * `iteratee`. The iteratee is invoked with three arguments:\n * (value, index|key, collection).\n *\n * Many lodash methods are guarded to work as iteratees for methods like\n * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n *\n * The guarded methods are:\n * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,\n * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,\n * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,\n * `template`, `trim`, `trimEnd`, `trimStart`, and `words`\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n * @example\n *\n * function square(n) {\n *   return n * n;\n * }\n *\n * _.map([4, 8], square);\n * // => [16, 64]\n *\n * _.map({ 'a': 4, 'b': 8 }, square);\n * // => [16, 64] (iteration order is not guaranteed)\n *\n * var users = [\n *   { 'user': 'barney' },\n *   { 'user': 'fred' }\n * ];\n *\n * // The `_.property` iteratee shorthand.\n * _.map(users, 'user');\n * // => ['barney', 'fred']\n */\nfunction map(collection, iteratee) {\n  var func = isArray(collection) ? arrayMap : baseMap;\n  return func(collection, baseIteratee(iteratee, 3));\n}\n\nexport default map;\n","import baseFlatten from './_baseFlatten.js';\nimport map from './map.js';\n\n/**\n * Creates a flattened array of values by running each element in `collection`\n * thru `iteratee` and flattening the mapped results. The iteratee is invoked\n * with three arguments: (value, index|key, collection).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new flattened array.\n * @example\n *\n * function duplicate(n) {\n *   return [n, n];\n * }\n *\n * _.flatMap([1, 2], duplicate);\n * // => [1, 1, 2, 2]\n */\nfunction flatMap(collection, iteratee) {\n  return baseFlatten(map(collection, iteratee), 1);\n}\n\nexport default flatMap;\n","import baseAssignValue from './_baseAssignValue.js';\nimport createAggregator from './_createAggregator.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an object composed of keys generated from the results of running\n * each element of `collection` thru `iteratee`. The order of grouped values\n * is determined by the order they occur in `collection`. The corresponding\n * value of each key is an array of elements responsible for generating the\n * key. The iteratee is invoked with one argument: (value).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n * @returns {Object} Returns the composed aggregate object.\n * @example\n *\n * _.groupBy([6.1, 4.2, 6.3], Math.floor);\n * // => { '4': [4.2], '6': [6.1, 6.3] }\n *\n * // The `_.property` iteratee shorthand.\n * _.groupBy(['one', 'two', 'three'], 'length');\n * // => { '3': ['one', 'two'], '5': ['three'] }\n */\nvar groupBy = createAggregator(function(result, value, key) {\n  if (hasOwnProperty.call(result, key)) {\n    result[key].push(value);\n  } else {\n    baseAssignValue(result, key, [value]);\n  }\n});\n\nexport default groupBy;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.has` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHas(object, key) {\n  return object != null && hasOwnProperty.call(object, key);\n}\n\nexport default baseHas;\n","import baseHas from './_baseHas.js';\nimport hasPath from './_hasPath.js';\n\n/**\n * Checks if `path` is a direct property of `object`.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = { 'a': { 'b': 2 } };\n * var other = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.has(object, 'a');\n * // => true\n *\n * _.has(object, 'a.b');\n * // => true\n *\n * _.has(object, ['a', 'b']);\n * // => true\n *\n * _.has(other, 'a');\n * // => false\n */\nfunction has(object, path) {\n  return object != null && hasPath(object, path, baseHas);\n}\n\nexport default has;\n","import baseGetTag from './_baseGetTag.js';\nimport isArray from './isArray.js';\nimport isObjectLike from './isObjectLike.js';\n\n/** `Object#toString` result references. */\nvar stringTag = '[object String]';\n\n/**\n * Checks if `value` is classified as a `String` primitive or object.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a string, else `false`.\n * @example\n *\n * _.isString('abc');\n * // => true\n *\n * _.isString(1);\n * // => false\n */\nfunction isString(value) {\n  return typeof value == 'string' ||\n    (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);\n}\n\nexport default isString;\n","import arrayMap from './_arrayMap.js';\n\n/**\n * The base implementation of `_.values` and `_.valuesIn` which creates an\n * array of `object` property values corresponding to the property names\n * of `props`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array} props The property names to get values for.\n * @returns {Object} Returns the array of property values.\n */\nfunction baseValues(object, props) {\n  return arrayMap(props, function(key) {\n    return object[key];\n  });\n}\n\nexport default baseValues;\n","import baseValues from './_baseValues.js';\nimport keys from './keys.js';\n\n/**\n * Creates an array of the own enumerable string keyed property values of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property values.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.values(new Foo);\n * // => [1, 2] (iteration order is not guaranteed)\n *\n * _.values('hi');\n * // => ['h', 'i']\n */\nfunction values(object) {\n  return object == null ? [] : baseValues(object, keys(object));\n}\n\nexport default values;\n","import baseIndexOf from './_baseIndexOf.js';\nimport isArrayLike from './isArrayLike.js';\nimport isString from './isString.js';\nimport toInteger from './toInteger.js';\nimport values from './values.js';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * Checks if `value` is in `collection`. If `collection` is a string, it's\n * checked for a substring of `value`, otherwise\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * is used for equality comparisons. If `fromIndex` is negative, it's used as\n * the offset from the end of `collection`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object|string} collection The collection to inspect.\n * @param {*} value The value to search for.\n * @param {number} [fromIndex=0] The index to search from.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\n * @returns {boolean} Returns `true` if `value` is found, else `false`.\n * @example\n *\n * _.includes([1, 2, 3], 1);\n * // => true\n *\n * _.includes([1, 2, 3], 1, 2);\n * // => false\n *\n * _.includes({ 'a': 1, 'b': 2 }, 1);\n * // => true\n *\n * _.includes('abcd', 'bc');\n * // => true\n */\nfunction includes(collection, value, fromIndex, guard) {\n  collection = isArrayLike(collection) ? collection : values(collection);\n  fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;\n\n  var length = collection.length;\n  if (fromIndex < 0) {\n    fromIndex = nativeMax(length + fromIndex, 0);\n  }\n  return isString(collection)\n    ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)\n    : (!!length && baseIndexOf(collection, value, fromIndex) > -1);\n}\n\nexport default includes;\n","import baseIndexOf from './_baseIndexOf.js';\nimport toInteger from './toInteger.js';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * Gets the index at which the first occurrence of `value` is found in `array`\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons. If `fromIndex` is negative, it's used as the\n * offset from the end of `array`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n * @example\n *\n * _.indexOf([1, 2, 1, 2], 2);\n * // => 1\n *\n * // Search from the `fromIndex`.\n * _.indexOf([1, 2, 1, 2], 2, 2);\n * // => 3\n */\nfunction indexOf(array, value, fromIndex) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return -1;\n  }\n  var index = fromIndex == null ? 0 : toInteger(fromIndex);\n  if (index < 0) {\n    index = nativeMax(length + index, 0);\n  }\n  return baseIndexOf(array, value, index);\n}\n\nexport default indexOf;\n","import baseKeys from './_baseKeys.js';\nimport getTag from './_getTag.js';\nimport isArguments from './isArguments.js';\nimport isArray from './isArray.js';\nimport isArrayLike from './isArrayLike.js';\nimport isBuffer from './isBuffer.js';\nimport isPrototype from './_isPrototype.js';\nimport isTypedArray from './isTypedArray.js';\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]',\n    setTag = '[object Set]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if `value` is an empty object, collection, map, or set.\n *\n * Objects are considered empty if they have no own enumerable string keyed\n * properties.\n *\n * Array-like values such as `arguments` objects, arrays, buffers, strings, or\n * jQuery-like collections are considered empty if they have a `length` of `0`.\n * Similarly, maps and sets are considered empty if they have a `size` of `0`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is empty, else `false`.\n * @example\n *\n * _.isEmpty(null);\n * // => true\n *\n * _.isEmpty(true);\n * // => true\n *\n * _.isEmpty(1);\n * // => true\n *\n * _.isEmpty([1, 2, 3]);\n * // => false\n *\n * _.isEmpty({ 'a': 1 });\n * // => false\n */\nfunction isEmpty(value) {\n  if (value == null) {\n    return true;\n  }\n  if (isArrayLike(value) &&\n      (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||\n        isBuffer(value) || isTypedArray(value) || isArguments(value))) {\n    return !value.length;\n  }\n  var tag = getTag(value);\n  if (tag == mapTag || tag == setTag) {\n    return !value.size;\n  }\n  if (isPrototype(value)) {\n    return !baseKeys(value).length;\n  }\n  for (var key in value) {\n    if (hasOwnProperty.call(value, key)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport default isEmpty;\n","import baseGetTag from './_baseGetTag.js';\nimport isObjectLike from './isObjectLike.js';\n\n/** `Object#toString` result references. */\nvar regexpTag = '[object RegExp]';\n\n/**\n * The base implementation of `_.isRegExp` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n */\nfunction baseIsRegExp(value) {\n  return isObjectLike(value) && baseGetTag(value) == regexpTag;\n}\n\nexport default baseIsRegExp;\n","import baseIsRegExp from './_baseIsRegExp.js';\nimport baseUnary from './_baseUnary.js';\nimport nodeUtil from './_nodeUtil.js';\n\n/* Node.js helper references. */\nvar nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;\n\n/**\n * Checks if `value` is classified as a `RegExp` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n * @example\n *\n * _.isRegExp(/abc/);\n * // => true\n *\n * _.isRegExp('/abc/');\n * // => false\n */\nvar isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;\n\nexport default isRegExp;\n","/**\n * Checks if `value` is `undefined`.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.\n * @example\n *\n * _.isUndefined(void 0);\n * // => true\n *\n * _.isUndefined(null);\n * // => false\n */\nfunction isUndefined(value) {\n  return value === undefined;\n}\n\nexport default isUndefined;\n","/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that negates the result of the predicate `func`. The\n * `func` predicate is invoked with the `this` binding and arguments of the\n * created function.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Function\n * @param {Function} predicate The predicate to negate.\n * @returns {Function} Returns the new negated function.\n * @example\n *\n * function isEven(n) {\n *   return n % 2 == 0;\n * }\n *\n * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));\n * // => [1, 3, 5]\n */\nfunction negate(predicate) {\n  if (typeof predicate != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  return function() {\n    var args = arguments;\n    switch (args.length) {\n      case 0: return !predicate.call(this);\n      case 1: return !predicate.call(this, args[0]);\n      case 2: return !predicate.call(this, args[0], args[1]);\n      case 3: return !predicate.call(this, args[0], args[1], args[2]);\n    }\n    return !predicate.apply(this, args);\n  };\n}\n\nexport default negate;\n","import assignValue from './_assignValue.js';\nimport castPath from './_castPath.js';\nimport isIndex from './_isIndex.js';\nimport isObject from './isObject.js';\nimport toKey from './_toKey.js';\n\n/**\n * The base implementation of `_.set`.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {Array|string} path The path of the property to set.\n * @param {*} value The value to set.\n * @param {Function} [customizer] The function to customize path creation.\n * @returns {Object} Returns `object`.\n */\nfunction baseSet(object, path, value, customizer) {\n  if (!isObject(object)) {\n    return object;\n  }\n  path = castPath(path, object);\n\n  var index = -1,\n      length = path.length,\n      lastIndex = length - 1,\n      nested = object;\n\n  while (nested != null && ++index < length) {\n    var key = toKey(path[index]),\n        newValue = value;\n\n    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {\n      return object;\n    }\n\n    if (index != lastIndex) {\n      var objValue = nested[key];\n      newValue = customizer ? customizer(objValue, key, nested) : undefined;\n      if (newValue === undefined) {\n        newValue = isObject(objValue)\n          ? objValue\n          : (isIndex(path[index + 1]) ? [] : {});\n      }\n    }\n    assignValue(nested, key, newValue);\n    nested = nested[key];\n  }\n  return object;\n}\n\nexport default baseSet;\n","import baseGet from './_baseGet.js';\nimport baseSet from './_baseSet.js';\nimport castPath from './_castPath.js';\n\n/**\n * The base implementation of  `_.pickBy` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The source object.\n * @param {string[]} paths The property paths to pick.\n * @param {Function} predicate The function invoked per property.\n * @returns {Object} Returns the new object.\n */\nfunction basePickBy(object, paths, predicate) {\n  var index = -1,\n      length = paths.length,\n      result = {};\n\n  while (++index < length) {\n    var path = paths[index],\n        value = baseGet(object, path);\n\n    if (predicate(value, path)) {\n      baseSet(result, castPath(path, object), value);\n    }\n  }\n  return result;\n}\n\nexport default basePickBy;\n","import arrayMap from './_arrayMap.js';\nimport baseIteratee from './_baseIteratee.js';\nimport basePickBy from './_basePickBy.js';\nimport getAllKeysIn from './_getAllKeysIn.js';\n\n/**\n * Creates an object composed of the `object` properties `predicate` returns\n * truthy for. The predicate is invoked with two arguments: (value, key).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The source object.\n * @param {Function} [predicate=_.identity] The function invoked per property.\n * @returns {Object} Returns the new object.\n * @example\n *\n * var object = { 'a': 1, 'b': '2', 'c': 3 };\n *\n * _.pickBy(object, _.isNumber);\n * // => { 'a': 1, 'c': 3 }\n */\nfunction pickBy(object, predicate) {\n  if (object == null) {\n    return {};\n  }\n  var props = arrayMap(getAllKeysIn(object), function(prop) {\n    return [prop];\n  });\n  predicate = baseIteratee(predicate);\n  return basePickBy(object, props, function(value, path) {\n    return predicate(value, path[0]);\n  });\n}\n\nexport default pickBy;\n","/**\n * The base implementation of `_.reduce` and `_.reduceRight`, without support\n * for iteratee shorthands, which iterates over `collection` using `eachFunc`.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} accumulator The initial value.\n * @param {boolean} initAccum Specify using the first or last element of\n *  `collection` as the initial value.\n * @param {Function} eachFunc The function to iterate over `collection`.\n * @returns {*} Returns the accumulated value.\n */\nfunction baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {\n  eachFunc(collection, function(value, index, collection) {\n    accumulator = initAccum\n      ? (initAccum = false, value)\n      : iteratee(accumulator, value, index, collection);\n  });\n  return accumulator;\n}\n\nexport default baseReduce;\n","import arrayReduce from './_arrayReduce.js';\nimport baseEach from './_baseEach.js';\nimport baseIteratee from './_baseIteratee.js';\nimport baseReduce from './_baseReduce.js';\nimport isArray from './isArray.js';\n\n/**\n * Reduces `collection` to a value which is the accumulated result of running\n * each element in `collection` thru `iteratee`, where each successive\n * invocation is supplied the return value of the previous. If `accumulator`\n * is not given, the first element of `collection` is used as the initial\n * value. The iteratee is invoked with four arguments:\n * (accumulator, value, index|key, collection).\n *\n * Many lodash methods are guarded to work as iteratees for methods like\n * `_.reduce`, `_.reduceRight`, and `_.transform`.\n *\n * The guarded methods are:\n * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,\n * and `sortBy`\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @returns {*} Returns the accumulated value.\n * @see _.reduceRight\n * @example\n *\n * _.reduce([1, 2], function(sum, n) {\n *   return sum + n;\n * }, 0);\n * // => 3\n *\n * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n *   (result[value] || (result[value] = [])).push(key);\n *   return result;\n * }, {});\n * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)\n */\nfunction reduce(collection, iteratee, accumulator) {\n  var func = isArray(collection) ? arrayReduce : baseReduce,\n      initAccum = arguments.length < 3;\n\n  return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);\n}\n\nexport default reduce;\n","import arrayFilter from './_arrayFilter.js';\nimport baseFilter from './_baseFilter.js';\nimport baseIteratee from './_baseIteratee.js';\nimport isArray from './isArray.js';\nimport negate from './negate.js';\n\n/**\n * The opposite of `_.filter`; this method returns the elements of `collection`\n * that `predicate` does **not** return truthy for.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n * @see _.filter\n * @example\n *\n * var users = [\n *   { 'user': 'barney', 'age': 36, 'active': false },\n *   { 'user': 'fred',   'age': 40, 'active': true }\n * ];\n *\n * _.reject(users, function(o) { return !o.active; });\n * // => objects for ['fred']\n *\n * // The `_.matches` iteratee shorthand.\n * _.reject(users, { 'age': 40, 'active': true });\n * // => objects for ['barney']\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.reject(users, ['active', false]);\n * // => objects for ['fred']\n *\n * // The `_.property` iteratee shorthand.\n * _.reject(users, 'active');\n * // => objects for ['barney']\n */\nfunction reject(collection, predicate) {\n  var func = isArray(collection) ? arrayFilter : baseFilter;\n  return func(collection, negate(baseIteratee(predicate, 3)));\n}\n\nexport default reject;\n","import baseEach from './_baseEach.js';\n\n/**\n * The base implementation of `_.some` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction baseSome(collection, predicate) {\n  var result;\n\n  baseEach(collection, function(value, index, collection) {\n    result = predicate(value, index, collection);\n    return !result;\n  });\n  return !!result;\n}\n\nexport default baseSome;\n","import arraySome from './_arraySome.js';\nimport baseIteratee from './_baseIteratee.js';\nimport baseSome from './_baseSome.js';\nimport isArray from './isArray.js';\nimport isIterateeCall from './_isIterateeCall.js';\n\n/**\n * Checks if `predicate` returns truthy for **any** element of `collection`.\n * Iteration is stopped once `predicate` returns truthy. The predicate is\n * invoked with three arguments: (value, index|key, collection).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n * @example\n *\n * _.some([null, 0, 'yes', false], Boolean);\n * // => true\n *\n * var users = [\n *   { 'user': 'barney', 'active': true },\n *   { 'user': 'fred',   'active': false }\n * ];\n *\n * // The `_.matches` iteratee shorthand.\n * _.some(users, { 'user': 'barney', 'active': false });\n * // => false\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.some(users, ['active', false]);\n * // => true\n *\n * // The `_.property` iteratee shorthand.\n * _.some(users, 'active');\n * // => true\n */\nfunction some(collection, predicate, guard) {\n  var func = isArray(collection) ? arraySome : baseSome;\n  if (guard && isIterateeCall(collection, predicate, guard)) {\n    predicate = undefined;\n  }\n  return func(collection, baseIteratee(predicate, 3));\n}\n\nexport default some;\n","import Set from './_Set.js';\nimport noop from './noop.js';\nimport setToArray from './_setToArray.js';\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Creates a set object of `values`.\n *\n * @private\n * @param {Array} values The values to add to the set.\n * @returns {Object} Returns the new set.\n */\nvar createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {\n  return new Set(values);\n};\n\nexport default createSet;\n","import SetCache from './_SetCache.js';\nimport arrayIncludes from './_arrayIncludes.js';\nimport arrayIncludesWith from './_arrayIncludesWith.js';\nimport cacheHas from './_cacheHas.js';\nimport createSet from './_createSet.js';\nimport setToArray from './_setToArray.js';\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * The base implementation of `_.uniqBy` without support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} [iteratee] The iteratee invoked per element.\n * @param {Function} [comparator] The comparator invoked per element.\n * @returns {Array} Returns the new duplicate free array.\n */\nfunction baseUniq(array, iteratee, comparator) {\n  var index = -1,\n      includes = arrayIncludes,\n      length = array.length,\n      isCommon = true,\n      result = [],\n      seen = result;\n\n  if (comparator) {\n    isCommon = false;\n    includes = arrayIncludesWith;\n  }\n  else if (length >= LARGE_ARRAY_SIZE) {\n    var set = iteratee ? null : createSet(array);\n    if (set) {\n      return setToArray(set);\n    }\n    isCommon = false;\n    includes = cacheHas;\n    seen = new SetCache;\n  }\n  else {\n    seen = iteratee ? [] : result;\n  }\n  outer:\n  while (++index < length) {\n    var value = array[index],\n        computed = iteratee ? iteratee(value) : value;\n\n    value = (comparator || value !== 0) ? value : 0;\n    if (isCommon && computed === computed) {\n      var seenIndex = seen.length;\n      while (seenIndex--) {\n        if (seen[seenIndex] === computed) {\n          continue outer;\n        }\n      }\n      if (iteratee) {\n        seen.push(computed);\n      }\n      result.push(value);\n    }\n    else if (!includes(seen, computed, comparator)) {\n      if (seen !== result) {\n        seen.push(computed);\n      }\n      result.push(value);\n    }\n  }\n  return result;\n}\n\nexport default baseUniq;\n","import baseUniq from './_baseUniq.js';\n\n/**\n * Creates a duplicate-free version of an array, using\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons, in which only the first occurrence of each element\n * is kept. The order of result values is determined by the order they occur\n * in the array.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @returns {Array} Returns the new duplicate free array.\n * @example\n *\n * _.uniq([2, 1, 2]);\n * // => [2, 1]\n */\nfunction uniq(array) {\n  return (array && array.length) ? baseUniq(array) : [];\n}\n\nexport default uniq;\n","export function PRINT_ERROR(msg: string) {\n  /* istanbul ignore else - can't override global.console in node.js */\n  if (console && console.error) {\n    console.error(`Error: ${msg}`);\n  }\n}\n\nexport function PRINT_WARNING(msg: string) {\n  /* istanbul ignore else - can't override global.console in node.js*/\n  if (console && console.warn) {\n    // TODO: modify docs accordingly\n    console.warn(`Warning: ${msg}`);\n  }\n}\n","export function timer<T>(func: () => T): { time: number; value: T } {\n  const start = new Date().getTime();\n  const val = func();\n  const end = new Date().getTime();\n  const total = end - start;\n  return { time: total, value: val };\n}\n","// based on: https://github.com/petkaantonov/bluebird/blob/b97c0d2d487e8c5076e8bd897e0dcd4622d31846/src/util.js#L201-L216\nexport function toFastProperties(toBecomeFast: any) {\n  function FakeConstructor() {}\n\n  // If our object is used as a constructor, it would receive\n  FakeConstructor.prototype = toBecomeFast;\n  const fakeInstance = new (FakeConstructor as any)();\n\n  function fakeAccess() {\n    return typeof fakeInstance.bar;\n  }\n\n  // help V8 understand this is a \"real\" prototype by actually using\n  // the fake instance.\n  fakeAccess();\n  fakeAccess();\n\n  // Always true condition to suppress the Firefox warning of unreachable\n  // code after a return statement.\n  if (1) return toBecomeFast;\n\n  // Eval prevents optimization of this method (even though this is dead code)\n  // - https://esbuild.github.io/content-types/#direct-eval\n  /* istanbul ignore next */\n  // tslint:disable-next-line\n  (0, eval)(toBecomeFast);\n}\n","import { assign, forEach, isRegExp, isString, map, pickBy } from \"lodash-es\";\nimport type {\n  IGASTVisitor,\n  IProduction,\n  IProductionWithOccurrence,\n  ISerializedGast,\n  TokenType,\n} from \"@chevrotain/types\";\n\n// TODO: duplicated code to avoid extracting another sub-package -- how to avoid?\nfunction tokenLabel(tokType: TokenType): string {\n  if (hasTokenLabel(tokType)) {\n    return tokType.LABEL;\n  } else {\n    return tokType.name;\n  }\n}\n\n// TODO: duplicated code to avoid extracting another sub-package -- how to avoid?\nfunction hasTokenLabel(\n  obj: TokenType,\n): obj is TokenType & Pick<Required<TokenType>, \"LABEL\"> {\n  return isString(obj.LABEL) && obj.LABEL !== \"\";\n}\n\nexport abstract class AbstractProduction<T extends IProduction = IProduction>\n  implements IProduction\n{\n  public get definition(): T[] {\n    return this._definition;\n  }\n  public set definition(value: T[]) {\n    this._definition = value;\n  }\n\n  constructor(protected _definition: T[]) {}\n\n  accept(visitor: IGASTVisitor): void {\n    visitor.visit(this);\n    forEach(this.definition, (prod) => {\n      prod.accept(visitor);\n    });\n  }\n}\n\nexport class NonTerminal\n  extends AbstractProduction\n  implements IProductionWithOccurrence\n{\n  public nonTerminalName!: string;\n  public label?: string;\n  public referencedRule!: Rule;\n  public idx: number = 1;\n\n  constructor(options: {\n    nonTerminalName: string;\n    label?: string;\n    referencedRule?: Rule;\n    idx?: number;\n  }) {\n    super([]);\n    assign(\n      this,\n      pickBy(options, (v) => v !== undefined),\n    );\n  }\n\n  set definition(definition: IProduction[]) {\n    // immutable\n  }\n\n  get definition(): IProduction[] {\n    if (this.referencedRule !== undefined) {\n      return this.referencedRule.definition;\n    }\n    return [];\n  }\n\n  accept(visitor: IGASTVisitor): void {\n    visitor.visit(this);\n    // don't visit children of a reference, we will get cyclic infinite loops if we do so\n  }\n}\n\nexport class Rule extends AbstractProduction {\n  public name!: string;\n  public orgText: string = \"\";\n\n  constructor(options: {\n    name: string;\n    definition: IProduction[];\n    orgText?: string;\n  }) {\n    super(options.definition);\n    assign(\n      this,\n      pickBy(options, (v) => v !== undefined),\n    );\n  }\n}\n\nexport class Alternative extends AbstractProduction {\n  public ignoreAmbiguities: boolean = false;\n\n  constructor(options: {\n    definition: IProduction[];\n    ignoreAmbiguities?: boolean;\n  }) {\n    super(options.definition);\n    assign(\n      this,\n      pickBy(options, (v) => v !== undefined),\n    );\n  }\n}\n\nexport class Option\n  extends AbstractProduction\n  implements IProductionWithOccurrence\n{\n  public idx: number = 1;\n  public maxLookahead?: number;\n\n  constructor(options: {\n    definition: IProduction[];\n    idx?: number;\n    maxLookahead?: number;\n  }) {\n    super(options.definition);\n    assign(\n      this,\n      pickBy(options, (v) => v !== undefined),\n    );\n  }\n}\n\nexport class RepetitionMandatory\n  extends AbstractProduction\n  implements IProductionWithOccurrence\n{\n  public idx: number = 1;\n  public maxLookahead?: number;\n\n  constructor(options: {\n    definition: IProduction[];\n    idx?: number;\n    maxLookahead?: number;\n  }) {\n    super(options.definition);\n    assign(\n      this,\n      pickBy(options, (v) => v !== undefined),\n    );\n  }\n}\n\nexport class RepetitionMandatoryWithSeparator\n  extends AbstractProduction\n  implements IProductionWithOccurrence\n{\n  public separator!: TokenType;\n  public idx: number = 1;\n  public maxLookahead?: number;\n\n  constructor(options: {\n    definition: IProduction[];\n    separator: TokenType;\n    idx?: number;\n  }) {\n    super(options.definition);\n    assign(\n      this,\n      pickBy(options, (v) => v !== undefined),\n    );\n  }\n}\n\nexport class Repetition\n  extends AbstractProduction\n  implements IProductionWithOccurrence\n{\n  public separator!: TokenType;\n  public idx: number = 1;\n  public maxLookahead?: number;\n\n  constructor(options: {\n    definition: IProduction[];\n    idx?: number;\n    maxLookahead?: number;\n  }) {\n    super(options.definition);\n    assign(\n      this,\n      pickBy(options, (v) => v !== undefined),\n    );\n  }\n}\n\nexport class RepetitionWithSeparator\n  extends AbstractProduction\n  implements IProductionWithOccurrence\n{\n  public separator!: TokenType;\n  public idx: number = 1;\n  public maxLookahead?: number;\n\n  constructor(options: {\n    definition: IProduction[];\n    separator: TokenType;\n    idx?: number;\n  }) {\n    super(options.definition);\n    assign(\n      this,\n      pickBy(options, (v) => v !== undefined),\n    );\n  }\n}\n\nexport class Alternation\n  extends AbstractProduction<Alternative>\n  implements IProductionWithOccurrence\n{\n  public idx: number = 1;\n  public ignoreAmbiguities: boolean = false;\n  public hasPredicates: boolean = false;\n  public maxLookahead?: number;\n\n  public get definition(): Alternative[] {\n    return this._definition;\n  }\n  public set definition(value: Alternative[]) {\n    this._definition = value;\n  }\n\n  constructor(options: {\n    definition: Alternative[];\n    idx?: number;\n    ignoreAmbiguities?: boolean;\n    hasPredicates?: boolean;\n    maxLookahead?: number;\n  }) {\n    super(options.definition);\n    assign(\n      this,\n      pickBy(options, (v) => v !== undefined),\n    );\n  }\n}\n\nexport class Terminal implements IProductionWithOccurrence {\n  public terminalType!: TokenType;\n  public label?: string;\n  public idx: number = 1;\n\n  constructor(options: {\n    terminalType: TokenType;\n    label?: string;\n    idx?: number;\n  }) {\n    assign(\n      this,\n      pickBy(options, (v) => v !== undefined),\n    );\n  }\n\n  accept(visitor: IGASTVisitor): void {\n    visitor.visit(this);\n  }\n}\n\nexport interface ISerializedBasic extends ISerializedGast {\n  type:\n    | \"Alternative\"\n    | \"Option\"\n    | \"RepetitionMandatory\"\n    | \"Repetition\"\n    | \"Alternation\";\n  idx?: number;\n}\n\nexport interface ISerializedGastRule extends ISerializedGast {\n  type: \"Rule\";\n  name: string;\n  orgText: string;\n}\n\nexport interface ISerializedNonTerminal extends ISerializedGast {\n  type: \"NonTerminal\";\n  name: string;\n  label?: string;\n  idx: number;\n}\n\nexport interface ISerializedTerminal extends ISerializedGast {\n  type: \"Terminal\";\n  name: string;\n  terminalLabel?: string;\n  label?: string;\n  pattern?: string;\n  idx: number;\n}\n\nexport interface ISerializedTerminalWithSeparator extends ISerializedGast {\n  type: \"RepetitionMandatoryWithSeparator\" | \"RepetitionWithSeparator\";\n  idx: number;\n  separator: ISerializedTerminal;\n}\n\nexport type ISerializedGastAny =\n  | ISerializedBasic\n  | ISerializedGastRule\n  | ISerializedNonTerminal\n  | ISerializedTerminal\n  | ISerializedTerminalWithSeparator;\n\nexport function serializeGrammar(topRules: Rule[]): ISerializedGast[] {\n  return map(topRules, serializeProduction);\n}\n\nexport function serializeProduction(node: IProduction): ISerializedGast {\n  function convertDefinition(definition: IProduction[]): ISerializedGast[] {\n    return map(definition, serializeProduction);\n  }\n  /* istanbul ignore else */\n  if (node instanceof NonTerminal) {\n    const serializedNonTerminal: ISerializedNonTerminal = {\n      type: \"NonTerminal\",\n      name: node.nonTerminalName,\n      idx: node.idx,\n    };\n\n    if (isString(node.label)) {\n      serializedNonTerminal.label = node.label;\n    }\n\n    return serializedNonTerminal;\n  } else if (node instanceof Alternative) {\n    return <ISerializedBasic>{\n      type: \"Alternative\",\n      definition: convertDefinition(node.definition),\n    };\n  } else if (node instanceof Option) {\n    return <ISerializedBasic>{\n      type: \"Option\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition),\n    };\n  } else if (node instanceof RepetitionMandatory) {\n    return <ISerializedBasic>{\n      type: \"RepetitionMandatory\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition),\n    };\n  } else if (node instanceof RepetitionMandatoryWithSeparator) {\n    return <ISerializedTerminalWithSeparator>{\n      type: \"RepetitionMandatoryWithSeparator\",\n      idx: node.idx,\n      separator: <ISerializedTerminal>(\n        serializeProduction(new Terminal({ terminalType: node.separator }))\n      ),\n      definition: convertDefinition(node.definition),\n    };\n  } else if (node instanceof RepetitionWithSeparator) {\n    return <ISerializedTerminalWithSeparator>{\n      type: \"RepetitionWithSeparator\",\n      idx: node.idx,\n      separator: <ISerializedTerminal>(\n        serializeProduction(new Terminal({ terminalType: node.separator }))\n      ),\n      definition: convertDefinition(node.definition),\n    };\n  } else if (node instanceof Repetition) {\n    return <ISerializedBasic>{\n      type: \"Repetition\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition),\n    };\n  } else if (node instanceof Alternation) {\n    return <ISerializedBasic>{\n      type: \"Alternation\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition),\n    };\n  } else if (node instanceof Terminal) {\n    const serializedTerminal = <ISerializedTerminal>{\n      type: \"Terminal\",\n      name: node.terminalType.name,\n      label: tokenLabel(node.terminalType),\n      idx: node.idx,\n    };\n\n    if (isString(node.label)) {\n      serializedTerminal.terminalLabel = node.label;\n    }\n\n    const pattern = node.terminalType.PATTERN;\n    if (node.terminalType.PATTERN) {\n      serializedTerminal.pattern = isRegExp(pattern)\n        ? (<any>pattern).source\n        : pattern;\n    }\n\n    return serializedTerminal;\n  } else if (node instanceof Rule) {\n    return <ISerializedGastRule>{\n      type: \"Rule\",\n      name: node.name,\n      orgText: node.orgText,\n      definition: convertDefinition(node.definition),\n    };\n    /* c8 ignore next 3 */\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\n","import {\n  Alternation,\n  Alternative,\n  NonTerminal,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Rule,\n  Terminal,\n} from \"./model.js\";\nimport type { IProduction } from \"@chevrotain/types\";\n\nexport abstract class GAstVisitor {\n  public visit(node: IProduction): any {\n    const nodeAny: any = node;\n    switch (nodeAny.constructor) {\n      case NonTerminal:\n        return this.visitNonTerminal(nodeAny);\n      case Alternative:\n        return this.visitAlternative(nodeAny);\n      case Option:\n        return this.visitOption(nodeAny);\n      case RepetitionMandatory:\n        return this.visitRepetitionMandatory(nodeAny);\n      case RepetitionMandatoryWithSeparator:\n        return this.visitRepetitionMandatoryWithSeparator(nodeAny);\n      case RepetitionWithSeparator:\n        return this.visitRepetitionWithSeparator(nodeAny);\n      case Repetition:\n        return this.visitRepetition(nodeAny);\n      case Alternation:\n        return this.visitAlternation(nodeAny);\n      case Terminal:\n        return this.visitTerminal(nodeAny);\n      case Rule:\n        return this.visitRule(nodeAny);\n      /* c8 ignore next 2 */\n      default:\n        throw Error(\"non exhaustive match\");\n    }\n  }\n\n  /* c8 ignore next */\n  public visitNonTerminal(node: NonTerminal): any {}\n\n  /* c8 ignore next */\n  public visitAlternative(node: Alternative): any {}\n\n  /* c8 ignore next */\n  public visitOption(node: Option): any {}\n\n  /* c8 ignore next */\n  public visitRepetition(node: Repetition): any {}\n\n  /* c8 ignore next */\n  public visitRepetitionMandatory(node: RepetitionMandatory): any {}\n\n  /* c8 ignore next 3 */\n  public visitRepetitionMandatoryWithSeparator(\n    node: RepetitionMandatoryWithSeparator,\n  ): any {}\n\n  /* c8 ignore next */\n  public visitRepetitionWithSeparator(node: RepetitionWithSeparator): any {}\n\n  /* c8 ignore next */\n  public visitAlternation(node: Alternation): any {}\n\n  /* c8 ignore next */\n  public visitTerminal(node: Terminal): any {}\n\n  /* c8 ignore next */\n  public visitRule(node: Rule): any {}\n}\n","import { every, includes, some } from \"lodash-es\";\nimport {\n  AbstractProduction,\n  Alternation,\n  Alternative,\n  NonTerminal,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Rule,\n  Terminal,\n} from \"./model.js\";\nimport type { IProduction, IProductionWithOccurrence } from \"@chevrotain/types\";\n\nexport function isSequenceProd(\n  prod: IProduction,\n): prod is { definition: IProduction[] } & IProduction {\n  return (\n    prod instanceof Alternative ||\n    prod instanceof Option ||\n    prod instanceof Repetition ||\n    prod instanceof RepetitionMandatory ||\n    prod instanceof RepetitionMandatoryWithSeparator ||\n    prod instanceof RepetitionWithSeparator ||\n    prod instanceof Terminal ||\n    prod instanceof Rule\n  );\n}\n\nexport function isOptionalProd(\n  prod: IProduction,\n  alreadyVisited: NonTerminal[] = [],\n): boolean {\n  const isDirectlyOptional =\n    prod instanceof Option ||\n    prod instanceof Repetition ||\n    prod instanceof RepetitionWithSeparator;\n  if (isDirectlyOptional) {\n    return true;\n  }\n\n  // note that this can cause infinite loop if one optional empty TOP production has a cyclic dependency with another\n  // empty optional top rule\n  // may be indirectly optional ((A?B?C?) | (D?E?F?))\n  if (prod instanceof Alternation) {\n    // for OR its enough for just one of the alternatives to be optional\n    return some((<Alternation>prod).definition, (subProd: IProduction) => {\n      return isOptionalProd(subProd, alreadyVisited);\n    });\n  } else if (prod instanceof NonTerminal && includes(alreadyVisited, prod)) {\n    // avoiding stack overflow due to infinite recursion\n    return false;\n  } else if (prod instanceof AbstractProduction) {\n    if (prod instanceof NonTerminal) {\n      alreadyVisited.push(prod);\n    }\n    return every(\n      (<AbstractProduction>prod).definition,\n      (subProd: IProduction) => {\n        return isOptionalProd(subProd, alreadyVisited);\n      },\n    );\n  } else {\n    return false;\n  }\n}\n\nexport function isBranchingProd(\n  prod: IProduction,\n): prod is { definition: IProduction[] } & IProduction {\n  return prod instanceof Alternation;\n}\n\nexport function getProductionDslName(prod: IProductionWithOccurrence): string {\n  /* istanbul ignore else */\n  if (prod instanceof NonTerminal) {\n    return \"SUBRULE\";\n  } else if (prod instanceof Option) {\n    return \"OPTION\";\n  } else if (prod instanceof Alternation) {\n    return \"OR\";\n  } else if (prod instanceof RepetitionMandatory) {\n    return \"AT_LEAST_ONE\";\n  } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n    return \"AT_LEAST_ONE_SEP\";\n  } else if (prod instanceof RepetitionWithSeparator) {\n    return \"MANY_SEP\";\n  } else if (prod instanceof Repetition) {\n    return \"MANY\";\n  } else if (prod instanceof Terminal) {\n    return \"CONSUME\";\n    /* c8 ignore next 3 */\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\n","import { drop, forEach } from \"lodash-es\";\nimport {\n  Alternation,\n  Alternative,\n  NonTerminal,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Terminal,\n} from \"@chevrotain/gast\";\nimport { IProduction } from \"@chevrotain/types\";\n\n/**\n *  A Grammar Walker that computes the \"remaining\" grammar \"after\" a productions in the grammar.\n */\nexport abstract class RestWalker {\n  walk(prod: { definition: IProduction[] }, prevRest: any[] = []): void {\n    forEach(prod.definition, (subProd: IProduction, index) => {\n      const currRest = drop(prod.definition, index + 1);\n      /* istanbul ignore else */\n      if (subProd instanceof NonTerminal) {\n        this.walkProdRef(subProd, currRest, prevRest);\n      } else if (subProd instanceof Terminal) {\n        this.walkTerminal(subProd, currRest, prevRest);\n      } else if (subProd instanceof Alternative) {\n        this.walkFlat(subProd, currRest, prevRest);\n      } else if (subProd instanceof Option) {\n        this.walkOption(subProd, currRest, prevRest);\n      } else if (subProd instanceof RepetitionMandatory) {\n        this.walkAtLeastOne(subProd, currRest, prevRest);\n      } else if (subProd instanceof RepetitionMandatoryWithSeparator) {\n        this.walkAtLeastOneSep(subProd, currRest, prevRest);\n      } else if (subProd instanceof RepetitionWithSeparator) {\n        this.walkManySep(subProd, currRest, prevRest);\n      } else if (subProd instanceof Repetition) {\n        this.walkMany(subProd, currRest, prevRest);\n      } else if (subProd instanceof Alternation) {\n        this.walkOr(subProd, currRest, prevRest);\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    });\n  }\n\n  walkTerminal(\n    terminal: Terminal,\n    currRest: IProduction[],\n    prevRest: IProduction[],\n  ): void {}\n\n  walkProdRef(\n    refProd: NonTerminal,\n    currRest: IProduction[],\n    prevRest: IProduction[],\n  ): void {}\n\n  walkFlat(\n    flatProd: Alternative,\n    currRest: IProduction[],\n    prevRest: IProduction[],\n  ): void {\n    // ABCDEF => after the D the rest is EF\n    const fullOrRest = currRest.concat(prevRest);\n    this.walk(flatProd, <any>fullOrRest);\n  }\n\n  walkOption(\n    optionProd: Option,\n    currRest: IProduction[],\n    prevRest: IProduction[],\n  ): void {\n    // ABC(DE)?F => after the (DE)? the rest is F\n    const fullOrRest = currRest.concat(prevRest);\n    this.walk(optionProd, <any>fullOrRest);\n  }\n\n  walkAtLeastOne(\n    atLeastOneProd: RepetitionMandatory,\n    currRest: IProduction[],\n    prevRest: IProduction[],\n  ): void {\n    // ABC(DE)+F => after the (DE)+ the rest is (DE)?F\n    const fullAtLeastOneRest: IProduction[] = [\n      new Option({ definition: atLeastOneProd.definition }),\n    ].concat(<any>currRest, <any>prevRest);\n    this.walk(atLeastOneProd, fullAtLeastOneRest);\n  }\n\n  walkAtLeastOneSep(\n    atLeastOneSepProd: RepetitionMandatoryWithSeparator,\n    currRest: IProduction[],\n    prevRest: IProduction[],\n  ): void {\n    // ABC DE(,DE)* F => after the (,DE)+ the rest is (,DE)?F\n    const fullAtLeastOneSepRest = restForRepetitionWithSeparator(\n      atLeastOneSepProd,\n      currRest,\n      prevRest,\n    );\n    this.walk(atLeastOneSepProd, fullAtLeastOneSepRest);\n  }\n\n  walkMany(\n    manyProd: Repetition,\n    currRest: IProduction[],\n    prevRest: IProduction[],\n  ): void {\n    // ABC(DE)*F => after the (DE)* the rest is (DE)?F\n    const fullManyRest: IProduction[] = [\n      new Option({ definition: manyProd.definition }),\n    ].concat(<any>currRest, <any>prevRest);\n    this.walk(manyProd, fullManyRest);\n  }\n\n  walkManySep(\n    manySepProd: RepetitionWithSeparator,\n    currRest: IProduction[],\n    prevRest: IProduction[],\n  ): void {\n    // ABC (DE(,DE)*)? F => after the (,DE)* the rest is (,DE)?F\n    const fullManySepRest = restForRepetitionWithSeparator(\n      manySepProd,\n      currRest,\n      prevRest,\n    );\n    this.walk(manySepProd, fullManySepRest);\n  }\n\n  walkOr(\n    orProd: Alternation,\n    currRest: IProduction[],\n    prevRest: IProduction[],\n  ): void {\n    // ABC(D|E|F)G => when finding the (D|E|F) the rest is G\n    const fullOrRest = currRest.concat(prevRest);\n    // walk all different alternatives\n    forEach(orProd.definition, (alt) => {\n      // wrapping each alternative in a single definition wrapper\n      // to avoid errors in computing the rest of that alternative in the invocation to computeInProdFollows\n      // (otherwise for OR([alt1,alt2]) alt2 will be considered in 'rest' of alt1\n      const prodWrapper = new Alternative({ definition: [alt] });\n      this.walk(prodWrapper, <any>fullOrRest);\n    });\n  }\n}\n\nfunction restForRepetitionWithSeparator(\n  repSepProd: RepetitionWithSeparator,\n  currRest: IProduction[],\n  prevRest: IProduction[],\n) {\n  const repSepRest = [\n    new Option({\n      definition: [\n        new Terminal({ terminalType: repSepProd.separator }) as IProduction,\n      ].concat(repSepProd.definition),\n    }) as IProduction,\n  ];\n  const fullRepSepRest: IProduction[] = repSepRest.concat(currRest, prevRest);\n  return fullRepSepRest;\n}\n","import { flatten, map, uniq } from \"lodash-es\";\nimport {\n  isBranchingProd,\n  isOptionalProd,\n  isSequenceProd,\n  NonTerminal,\n  Terminal,\n} from \"@chevrotain/gast\";\nimport { IProduction, TokenType } from \"@chevrotain/types\";\n\nexport function first(prod: IProduction): TokenType[] {\n  /* istanbul ignore else */\n  if (prod instanceof NonTerminal) {\n    // this could in theory cause infinite loops if\n    // (1) prod A refs prod B.\n    // (2) prod B refs prod A\n    // (3) AB can match the empty set\n    // in other words a cycle where everything is optional so the first will keep\n    // looking ahead for the next optional part and will never exit\n    // currently there is no safeguard for this unique edge case because\n    // (1) not sure a grammar in which this can happen is useful for anything (productive)\n    return first((<NonTerminal>prod).referencedRule);\n  } else if (prod instanceof Terminal) {\n    return firstForTerminal(<Terminal>prod);\n  } else if (isSequenceProd(prod)) {\n    return firstForSequence(prod);\n  } else if (isBranchingProd(prod)) {\n    return firstForBranching(prod);\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\n\nexport function firstForSequence(prod: {\n  definition: IProduction[];\n}): TokenType[] {\n  let firstSet: TokenType[] = [];\n  const seq = prod.definition;\n  let nextSubProdIdx = 0;\n  let hasInnerProdsRemaining = seq.length > nextSubProdIdx;\n  let currSubProd;\n  // so we enter the loop at least once (if the definition is not empty\n  let isLastInnerProdOptional = true;\n  // scan a sequence until it's end or until we have found a NONE optional production in it\n  while (hasInnerProdsRemaining && isLastInnerProdOptional) {\n    currSubProd = seq[nextSubProdIdx];\n    isLastInnerProdOptional = isOptionalProd(currSubProd);\n    firstSet = firstSet.concat(first(currSubProd));\n    nextSubProdIdx = nextSubProdIdx + 1;\n    hasInnerProdsRemaining = seq.length > nextSubProdIdx;\n  }\n\n  return uniq(firstSet);\n}\n\nexport function firstForBranching(prod: {\n  definition: IProduction[];\n}): TokenType[] {\n  const allAlternativesFirsts: TokenType[][] = map(\n    prod.definition,\n    (innerProd) => {\n      return first(innerProd);\n    },\n  );\n  return uniq(flatten<TokenType>(allAlternativesFirsts));\n}\n\nexport function firstForTerminal(terminal: Terminal): TokenType[] {\n  return [terminal.terminalType];\n}\n","// TODO: can this be removed? where is it used?\nexport const IN = \"_~IN~_\";\n","import { RestWalker } from \"./rest.js\";\nimport { first } from \"./first.js\";\nimport { assign, forEach } from \"lodash-es\";\nimport { IN } from \"../constants.js\";\nimport { Alternative, NonTerminal, Rule, Terminal } from \"@chevrotain/gast\";\nimport { IProduction, TokenType } from \"@chevrotain/types\";\n\n// This ResyncFollowsWalker computes all of the follows required for RESYNC\n// (skipping reference production).\nexport class ResyncFollowsWalker extends RestWalker {\n  public follows: Record<string, TokenType[]> = {};\n\n  constructor(private topProd: Rule) {\n    super();\n  }\n\n  startWalking(): Record<string, TokenType[]> {\n    this.walk(this.topProd);\n    return this.follows;\n  }\n\n  walkTerminal(\n    terminal: Terminal,\n    currRest: IProduction[],\n    prevRest: IProduction[],\n  ): void {\n    // do nothing! just like in the public sector after 13:00\n  }\n\n  walkProdRef(\n    refProd: NonTerminal,\n    currRest: IProduction[],\n    prevRest: IProduction[],\n  ): void {\n    const followName =\n      buildBetweenProdsFollowPrefix(refProd.referencedRule, refProd.idx) +\n      this.topProd.name;\n    const fullRest: IProduction[] = currRest.concat(prevRest);\n    const restProd = new Alternative({ definition: fullRest });\n    const t_in_topProd_follows = first(restProd);\n    this.follows[followName] = t_in_topProd_follows;\n  }\n}\n\nexport function computeAllProdsFollows(\n  topProductions: Rule[],\n): Record<string, TokenType[]> {\n  const reSyncFollows = {};\n\n  forEach(topProductions, (topProd) => {\n    const currRefsFollow = new ResyncFollowsWalker(topProd).startWalking();\n    assign(reSyncFollows, currRefsFollow);\n  });\n  return reSyncFollows;\n}\n\nexport function buildBetweenProdsFollowPrefix(\n  inner: Rule,\n  occurenceInParent: number,\n): string {\n  return inner.name + occurenceInParent + IN;\n}\n\nexport function buildInProdFollowPrefix(terminal: Terminal): string {\n  const terminalName = terminal.terminalType.name;\n  return terminalName + terminal.idx + IN;\n}\n","import type { Character, IRegExpAST, RegExpFlags } from \"../types\";\n\nexport function cc(char: string): number {\n  return char.charCodeAt(0);\n}\n\nexport function insertToSet<T>(item: T | T[], set: T[]) {\n  if (Array.isArray(item)) {\n    item.forEach(function (subItem) {\n      set.push(subItem);\n    });\n  } else {\n    set.push(item);\n  }\n}\n\nexport function addFlag(\n  flagObj: RegExpFlags,\n  flagKey: keyof Omit<RegExpFlags, keyof IRegExpAST>,\n) {\n  if (flagObj[flagKey] === true) {\n    throw \"duplicate flag \" + flagKey;\n  }\n\n  const x: boolean = flagObj[flagKey];\n  flagObj[flagKey] = true;\n}\n\nexport function ASSERT_EXISTS<T = Object>(obj: any): obj is T {\n  // istanbul ignore next\n  if (obj === undefined) {\n    throw Error(\"Internal Error - Should never get here!\");\n  }\n  return true;\n}\n\n// istanbul ignore next\nexport function ASSERT_NEVER_REACH_HERE(): any {\n  throw Error(\"Internal Error - Should never get here!\");\n}\n\nexport function isCharacter(obj: { type: string }): obj is Character {\n  return obj[\"type\"] === \"Character\";\n}\n","import { cc } from \"./utils.js\";\n\nexport const digitsCharCodes: number[] = [];\nfor (let i = cc(\"0\"); i <= cc(\"9\"); i++) {\n  digitsCharCodes.push(i);\n}\n\nexport const wordCharCodes: number[] = [cc(\"_\")].concat(digitsCharCodes);\nfor (let i = cc(\"a\"); i <= cc(\"z\"); i++) {\n  wordCharCodes.push(i);\n}\n\nfor (let i = cc(\"A\"); i <= cc(\"Z\"); i++) {\n  wordCharCodes.push(i);\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#character-classes\nexport const whitespaceCodes: number[] = [\n  cc(\" \"),\n  cc(\"\\f\"),\n  cc(\"\\n\"),\n  cc(\"\\r\"),\n  cc(\"\\t\"),\n  cc(\"\\v\"),\n  cc(\"\\t\"),\n  cc(\"\\u00a0\"),\n  cc(\"\\u1680\"),\n  cc(\"\\u2000\"),\n  cc(\"\\u2001\"),\n  cc(\"\\u2002\"),\n  cc(\"\\u2003\"),\n  cc(\"\\u2004\"),\n  cc(\"\\u2005\"),\n  cc(\"\\u2006\"),\n  cc(\"\\u2007\"),\n  cc(\"\\u2008\"),\n  cc(\"\\u2009\"),\n  cc(\"\\u200a\"),\n  cc(\"\\u2028\"),\n  cc(\"\\u2029\"),\n  cc(\"\\u202f\"),\n  cc(\"\\u205f\"),\n  cc(\"\\u3000\"),\n  cc(\"\\ufeff\"),\n];\n","import type {\n  Alternative,\n  Assertion,\n  Atom,\n  Character,\n  Disjunction,\n  Group,\n  GroupBackReference,\n  Location,\n  Quantifier,\n  Range,\n  RegExpFlags,\n  RegExpPattern,\n  Set,\n  Term,\n} from \"../types\";\nimport {\n  addFlag,\n  ASSERT_EXISTS,\n  ASSERT_NEVER_REACH_HERE,\n  cc,\n  insertToSet,\n  isCharacter,\n} from \"./utils.js\";\nimport {\n  digitsCharCodes,\n  whitespaceCodes,\n  wordCharCodes,\n} from \"./character-classes.js\";\n\n// consts and utilities\nconst hexDigitPattern = /[0-9a-fA-F]/;\nconst decimalPattern = /[0-9]/;\nconst decimalPatternNoZero = /[1-9]/;\n\n// https://hackernoon.com/the-madness-of-parsing-real-world-javascript-regexps-d9ee336df983\n// https://www.ecma-international.org/ecma-262/8.0/index.html#prod-Pattern\nexport class RegExpParser {\n  protected idx: number = 0;\n  protected input: string = \"\";\n  protected groupIdx: number = 0;\n\n  protected saveState() {\n    return {\n      idx: this.idx,\n      input: this.input,\n      groupIdx: this.groupIdx,\n    };\n  }\n\n  protected restoreState(newState: {\n    idx: number;\n    input: string;\n    groupIdx: number;\n  }) {\n    this.idx = newState.idx;\n    this.input = newState.input;\n    this.groupIdx = newState.groupIdx;\n  }\n\n  public pattern(input: string): RegExpPattern {\n    // parser state\n    this.idx = 0;\n    this.input = input;\n    this.groupIdx = 0;\n\n    this.consumeChar(\"/\");\n    const value = this.disjunction();\n    this.consumeChar(\"/\");\n\n    const flags: RegExpFlags = {\n      type: \"Flags\",\n      loc: { begin: this.idx, end: input.length },\n      global: false,\n      ignoreCase: false,\n      multiLine: false,\n      unicode: false,\n      sticky: false,\n    };\n\n    while (this.isRegExpFlag()) {\n      switch (this.popChar()) {\n        case \"g\":\n          addFlag(flags, \"global\");\n          break;\n        case \"i\":\n          addFlag(flags, \"ignoreCase\");\n          break;\n        case \"m\":\n          addFlag(flags, \"multiLine\");\n          break;\n        case \"u\":\n          addFlag(flags, \"unicode\");\n          break;\n        case \"y\":\n          addFlag(flags, \"sticky\");\n          break;\n      }\n    }\n\n    if (this.idx !== this.input.length) {\n      throw Error(\"Redundant input: \" + this.input.substring(this.idx));\n    }\n    return {\n      type: \"Pattern\",\n      flags: flags,\n      value: value,\n      loc: this.loc(0),\n    };\n  }\n\n  protected disjunction(): Disjunction {\n    const alts = [];\n    const begin = this.idx;\n\n    alts.push(this.alternative());\n\n    while (this.peekChar() === \"|\") {\n      this.consumeChar(\"|\");\n      alts.push(this.alternative());\n    }\n\n    return { type: \"Disjunction\", value: alts, loc: this.loc(begin) };\n  }\n\n  protected alternative(): Alternative {\n    const terms = [];\n    const begin = this.idx;\n\n    while (this.isTerm()) {\n      terms.push(this.term());\n    }\n\n    return { type: \"Alternative\", value: terms, loc: this.loc(begin) };\n  }\n\n  protected term(): Term {\n    if (this.isAssertion()) {\n      return this.assertion();\n    } else {\n      return this.atom();\n    }\n  }\n\n  protected assertion(): Assertion {\n    const begin = this.idx;\n    switch (this.popChar()) {\n      case \"^\":\n        return {\n          type: \"StartAnchor\",\n          loc: this.loc(begin),\n        };\n      case \"$\":\n        return { type: \"EndAnchor\", loc: this.loc(begin) };\n      // '\\b' or '\\B'\n      case \"\\\\\":\n        switch (this.popChar()) {\n          case \"b\":\n            return {\n              type: \"WordBoundary\",\n              loc: this.loc(begin),\n            };\n          case \"B\":\n            return {\n              type: \"NonWordBoundary\",\n              loc: this.loc(begin),\n            };\n        }\n        // istanbul ignore next\n        throw Error(\"Invalid Assertion Escape\");\n      // '(?=' or '(?!'\n      case \"(\":\n        this.consumeChar(\"?\");\n\n        let type: \"Lookahead\" | \"NegativeLookahead\" | undefined;\n        switch (this.popChar()) {\n          case \"=\":\n            type = \"Lookahead\";\n            break;\n          case \"!\":\n            type = \"NegativeLookahead\";\n            break;\n        }\n        ASSERT_EXISTS(type);\n\n        const disjunction = this.disjunction();\n\n        this.consumeChar(\")\");\n\n        return {\n          type: type!,\n          value: disjunction,\n          loc: this.loc(begin),\n        };\n    }\n    // istanbul ignore next\n    return ASSERT_NEVER_REACH_HERE();\n  }\n\n  protected quantifier(\n    isBacktracking: boolean = false,\n  ): Quantifier | undefined {\n    let range: Partial<Quantifier> | undefined = undefined;\n    const begin = this.idx;\n    switch (this.popChar()) {\n      case \"*\":\n        range = {\n          atLeast: 0,\n          atMost: Infinity,\n        };\n        break;\n      case \"+\":\n        range = {\n          atLeast: 1,\n          atMost: Infinity,\n        };\n        break;\n      case \"?\":\n        range = {\n          atLeast: 0,\n          atMost: 1,\n        };\n        break;\n      case \"{\":\n        const atLeast = this.integerIncludingZero();\n        switch (this.popChar()) {\n          case \"}\":\n            range = {\n              atLeast: atLeast,\n              atMost: atLeast,\n            };\n            break;\n          case \",\":\n            let atMost;\n            if (this.isDigit()) {\n              atMost = this.integerIncludingZero();\n              range = {\n                atLeast: atLeast,\n                atMost: atMost,\n              };\n            } else {\n              range = {\n                atLeast: atLeast,\n                atMost: Infinity,\n              };\n            }\n            this.consumeChar(\"}\");\n            break;\n        }\n        // throwing exceptions from \"ASSERT_EXISTS\" during backtracking\n        // causes severe performance degradations\n        if (isBacktracking === true && range === undefined) {\n          return undefined;\n        }\n        ASSERT_EXISTS(range);\n        break;\n    }\n\n    // throwing exceptions from \"ASSERT_EXISTS\" during backtracking\n    // causes severe performance degradations\n    if (isBacktracking === true && range === undefined) {\n      return undefined;\n    }\n\n    // istanbul ignore else\n    if (ASSERT_EXISTS(range)) {\n      if (this.peekChar(0) === \"?\") {\n        this.consumeChar(\"?\");\n        range.greedy = false;\n      } else {\n        range.greedy = true;\n      }\n\n      range.type = \"Quantifier\";\n      range.loc = this.loc(begin);\n      return range as Quantifier;\n    }\n  }\n\n  protected atom(): Atom {\n    let atom: Omit<Atom, \"loc\" | \"type\"> | undefined;\n    const begin = this.idx;\n    switch (this.peekChar()) {\n      case \".\":\n        atom = this.dotAll();\n        break;\n      case \"\\\\\":\n        atom = this.atomEscape();\n        break;\n      case \"[\":\n        atom = this.characterClass();\n        break;\n      case \"(\":\n        atom = this.group();\n        break;\n    }\n\n    if (atom === undefined && this.isPatternCharacter()) {\n      atom = this.patternCharacter();\n    }\n\n    // istanbul ignore else\n    if (ASSERT_EXISTS<Atom>(atom)) {\n      atom.loc = this.loc(begin);\n\n      if (this.isQuantifier()) {\n        atom.quantifier = this.quantifier();\n      }\n\n      return atom;\n    }\n\n    // istanbul ignore next\n    return ASSERT_NEVER_REACH_HERE();\n  }\n\n  protected dotAll(): Omit<Set, \"loc\"> {\n    this.consumeChar(\".\");\n    return {\n      type: \"Set\",\n      complement: true,\n      value: [cc(\"\\n\"), cc(\"\\r\"), cc(\"\\u2028\"), cc(\"\\u2029\")],\n    };\n  }\n\n  protected atomEscape(): Omit<GroupBackReference | Set | Character, \"loc\"> {\n    this.consumeChar(\"\\\\\");\n\n    switch (this.peekChar()) {\n      case \"1\":\n      case \"2\":\n      case \"3\":\n      case \"4\":\n      case \"5\":\n      case \"6\":\n      case \"7\":\n      case \"8\":\n      case \"9\":\n        return this.decimalEscapeAtom();\n      case \"d\":\n      case \"D\":\n      case \"s\":\n      case \"S\":\n      case \"w\":\n      case \"W\":\n        return this.characterClassEscape();\n      case \"f\":\n      case \"n\":\n      case \"r\":\n      case \"t\":\n      case \"v\":\n        return this.controlEscapeAtom();\n      case \"c\":\n        return this.controlLetterEscapeAtom();\n      case \"0\":\n        return this.nulCharacterAtom();\n      case \"x\":\n        return this.hexEscapeSequenceAtom();\n      case \"u\":\n        return this.regExpUnicodeEscapeSequenceAtom();\n      default:\n        return this.identityEscapeAtom();\n    }\n  }\n\n  protected decimalEscapeAtom(): Omit<GroupBackReference, \"loc\"> {\n    const value = this.positiveInteger();\n\n    return { type: \"GroupBackReference\", value: value };\n  }\n\n  protected characterClassEscape(): Omit<Set, \"loc\"> {\n    let set: (number | Range)[] | undefined;\n    let complement = false;\n    switch (this.popChar()) {\n      case \"d\":\n        set = digitsCharCodes;\n        break;\n      case \"D\":\n        set = digitsCharCodes;\n        complement = true;\n        break;\n      case \"s\":\n        set = whitespaceCodes;\n        break;\n      case \"S\":\n        set = whitespaceCodes;\n        complement = true;\n        break;\n      case \"w\":\n        set = wordCharCodes;\n        break;\n      case \"W\":\n        set = wordCharCodes;\n        complement = true;\n        break;\n    }\n\n    // istanbul ignore else\n    if (ASSERT_EXISTS(set)) {\n      return { type: \"Set\", value: set, complement: complement };\n    }\n    // istanbul ignore next\n    return ASSERT_NEVER_REACH_HERE();\n  }\n\n  protected controlEscapeAtom(): Omit<Character, \"loc\"> {\n    let escapeCode;\n    switch (this.popChar()) {\n      case \"f\":\n        escapeCode = cc(\"\\f\");\n        break;\n      case \"n\":\n        escapeCode = cc(\"\\n\");\n        break;\n      case \"r\":\n        escapeCode = cc(\"\\r\");\n        break;\n      case \"t\":\n        escapeCode = cc(\"\\t\");\n        break;\n      case \"v\":\n        escapeCode = cc(\"\\v\");\n        break;\n    }\n\n    // istanbul ignore else\n    if (ASSERT_EXISTS(escapeCode)) {\n      return { type: \"Character\", value: escapeCode };\n    }\n    // istanbul ignore next\n    return ASSERT_NEVER_REACH_HERE();\n  }\n\n  protected controlLetterEscapeAtom(): Omit<Character, \"loc\"> {\n    this.consumeChar(\"c\");\n    const letter = this.popChar();\n    if (/[a-zA-Z]/.test(letter) === false) {\n      throw Error(\"Invalid \");\n    }\n\n    const letterCode = letter.toUpperCase().charCodeAt(0) - 64;\n    return { type: \"Character\", value: letterCode };\n  }\n\n  protected nulCharacterAtom(): Omit<Character, \"loc\"> {\n    // TODO implement '[lookahead  DecimalDigit]'\n    // TODO: for the deprecated octal escape sequence\n    this.consumeChar(\"0\");\n    return { type: \"Character\", value: cc(\"\\0\") };\n  }\n\n  protected hexEscapeSequenceAtom(): Omit<Character, \"loc\"> {\n    this.consumeChar(\"x\");\n    return this.parseHexDigits(2);\n  }\n\n  protected regExpUnicodeEscapeSequenceAtom(): Omit<Character, \"loc\"> {\n    this.consumeChar(\"u\");\n    return this.parseHexDigits(4);\n  }\n\n  protected identityEscapeAtom(): Omit<Character, \"loc\"> {\n    // TODO: implement \"SourceCharacter but not UnicodeIDContinue\"\n    // // http://unicode.org/reports/tr31/#Specific_Character_Adjustments\n    const escapedChar = this.popChar();\n    return { type: \"Character\", value: cc(escapedChar) };\n  }\n\n  protected classPatternCharacterAtom(): Omit<Character, \"loc\"> {\n    switch (this.peekChar()) {\n      // istanbul ignore next\n      case \"\\n\":\n      // istanbul ignore next\n      case \"\\r\":\n      // istanbul ignore next\n      case \"\\u2028\":\n      // istanbul ignore next\n      case \"\\u2029\":\n      // istanbul ignore next\n      case \"\\\\\":\n      // istanbul ignore next\n      case \"]\":\n        throw Error(\"TBD\");\n      default:\n        const nextChar = this.popChar();\n        return { type: \"Character\", value: cc(nextChar) };\n    }\n  }\n\n  protected characterClass(): Omit<Set, \"loc\"> {\n    const set: (number | Range)[] = [];\n    let complement = false;\n    this.consumeChar(\"[\");\n    if (this.peekChar(0) === \"^\") {\n      this.consumeChar(\"^\");\n      complement = true;\n    }\n\n    while (this.isClassAtom()) {\n      const from = this.classAtom();\n      const isFromSingleChar = from.type === \"Character\";\n      if (isCharacter(from) && this.isRangeDash()) {\n        this.consumeChar(\"-\");\n        const to = this.classAtom();\n        const isToSingleChar = to.type === \"Character\";\n\n        // a range can only be used when both sides are single characters\n        if (isCharacter(to)) {\n          if (to.value < from.value) {\n            throw Error(\"Range out of order in character class\");\n          }\n          set.push({ from: from.value, to: to.value });\n        } else {\n          // literal dash\n          insertToSet(from.value, set);\n          set.push(cc(\"-\"));\n          insertToSet(to.value, set);\n        }\n      } else {\n        insertToSet(from.value, set);\n      }\n    }\n\n    this.consumeChar(\"]\");\n\n    return { type: \"Set\", complement: complement, value: set };\n  }\n\n  protected classAtom(): Omit<Character | Set, \"loc\"> {\n    switch (this.peekChar()) {\n      // istanbul ignore next\n      case \"]\":\n      // istanbul ignore next\n      case \"\\n\":\n      // istanbul ignore next\n      case \"\\r\":\n      // istanbul ignore next\n      case \"\\u2028\":\n      // istanbul ignore next\n      case \"\\u2029\":\n        throw Error(\"TBD\");\n      case \"\\\\\":\n        return this.classEscape();\n      default:\n        return this.classPatternCharacterAtom();\n    }\n  }\n\n  protected classEscape(): Omit<Character | Set, \"loc\"> {\n    this.consumeChar(\"\\\\\");\n    switch (this.peekChar()) {\n      // Matches a backspace.\n      // (Not to be confused with \\b word boundary outside characterClass)\n      case \"b\":\n        this.consumeChar(\"b\");\n        return { type: \"Character\", value: cc(\"\\u0008\") };\n      case \"d\":\n      case \"D\":\n      case \"s\":\n      case \"S\":\n      case \"w\":\n      case \"W\":\n        return this.characterClassEscape();\n      case \"f\":\n      case \"n\":\n      case \"r\":\n      case \"t\":\n      case \"v\":\n        return this.controlEscapeAtom();\n      case \"c\":\n        return this.controlLetterEscapeAtom();\n      case \"0\":\n        return this.nulCharacterAtom();\n      case \"x\":\n        return this.hexEscapeSequenceAtom();\n      case \"u\":\n        return this.regExpUnicodeEscapeSequenceAtom();\n      default:\n        return this.identityEscapeAtom();\n    }\n  }\n\n  protected group(): Omit<Group, \"loc\"> {\n    let capturing = true;\n    this.consumeChar(\"(\");\n    switch (this.peekChar(0)) {\n      case \"?\":\n        this.consumeChar(\"?\");\n        this.consumeChar(\":\");\n        capturing = false;\n        break;\n      default:\n        this.groupIdx++;\n        break;\n    }\n    const value = this.disjunction();\n    this.consumeChar(\")\");\n\n    const groupAst: Omit<Group, \"loc\"> = {\n      type: \"Group\",\n      capturing: capturing,\n      value: value,\n    };\n\n    if (capturing) {\n      groupAst[\"idx\"] = this.groupIdx;\n    }\n\n    return groupAst;\n  }\n\n  protected positiveInteger(): number {\n    let number = this.popChar();\n\n    // istanbul ignore next - can't ever get here due to previous lookahead checks\n    // still implementing this error checking in case this ever changes.\n    if (decimalPatternNoZero.test(number) === false) {\n      throw Error(\"Expecting a positive integer\");\n    }\n\n    while (decimalPattern.test(this.peekChar(0))) {\n      number += this.popChar();\n    }\n\n    return parseInt(number, 10);\n  }\n\n  protected integerIncludingZero(): number {\n    let number = this.popChar();\n    if (decimalPattern.test(number) === false) {\n      throw Error(\"Expecting an integer\");\n    }\n\n    while (decimalPattern.test(this.peekChar(0))) {\n      number += this.popChar();\n    }\n\n    return parseInt(number, 10);\n  }\n\n  protected patternCharacter(): Omit<Character, \"loc\"> {\n    const nextChar = this.popChar();\n    switch (nextChar) {\n      // istanbul ignore next\n      case \"\\n\":\n      // istanbul ignore next\n      case \"\\r\":\n      // istanbul ignore next\n      case \"\\u2028\":\n      // istanbul ignore next\n      case \"\\u2029\":\n      // istanbul ignore next\n      case \"^\":\n      // istanbul ignore next\n      case \"$\":\n      // istanbul ignore next\n      case \"\\\\\":\n      // istanbul ignore next\n      case \".\":\n      // istanbul ignore next\n      case \"*\":\n      // istanbul ignore next\n      case \"+\":\n      // istanbul ignore next\n      case \"?\":\n      // istanbul ignore next\n      case \"(\":\n      // istanbul ignore next\n      case \")\":\n      // istanbul ignore next\n      case \"[\":\n      // istanbul ignore next\n      case \"|\":\n        // istanbul ignore next\n        throw Error(\"TBD\");\n      default:\n        return { type: \"Character\", value: cc(nextChar) };\n    }\n  }\n  protected isRegExpFlag(): boolean {\n    switch (this.peekChar(0)) {\n      case \"g\":\n      case \"i\":\n      case \"m\":\n      case \"u\":\n      case \"y\":\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  protected isRangeDash(): boolean {\n    return this.peekChar() === \"-\" && this.isClassAtom(1);\n  }\n\n  protected isDigit(): boolean {\n    return decimalPattern.test(this.peekChar(0));\n  }\n\n  protected isClassAtom(howMuch = 0): boolean {\n    switch (this.peekChar(howMuch)) {\n      case \"]\":\n      case \"\\n\":\n      case \"\\r\":\n      case \"\\u2028\":\n      case \"\\u2029\":\n        return false;\n      default:\n        return true;\n    }\n  }\n\n  protected isTerm() {\n    return this.isAtom() || this.isAssertion();\n  }\n\n  protected isAtom(): boolean {\n    if (this.isPatternCharacter()) {\n      return true;\n    }\n\n    switch (this.peekChar(0)) {\n      case \".\":\n      case \"\\\\\": // atomEscape\n      case \"[\": // characterClass\n      // TODO: isAtom must be called before isAssertion - disambiguate\n      case \"(\": // group\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  protected isAssertion(): boolean {\n    switch (this.peekChar(0)) {\n      case \"^\":\n      case \"$\":\n        return true;\n      // '\\b' or '\\B'\n      case \"\\\\\":\n        switch (this.peekChar(1)) {\n          case \"b\":\n          case \"B\":\n            return true;\n          default:\n            return false;\n        }\n      // '(?=' or '(?!'\n      case \"(\":\n        return (\n          this.peekChar(1) === \"?\" &&\n          (this.peekChar(2) === \"=\" || this.peekChar(2) === \"!\")\n        );\n      default:\n        return false;\n    }\n  }\n\n  protected isQuantifier(): boolean {\n    const prevState = this.saveState();\n    try {\n      return this.quantifier(true) !== undefined;\n    } catch (e) {\n      return false;\n    } finally {\n      this.restoreState(prevState);\n    }\n  }\n\n  protected isPatternCharacter(): boolean {\n    switch (this.peekChar()) {\n      case \"^\":\n      case \"$\":\n      case \"\\\\\":\n      case \".\":\n      case \"*\":\n      case \"+\":\n      case \"?\":\n      case \"(\":\n      case \")\":\n      case \"[\":\n      case \"|\":\n      case \"/\":\n      case \"\\n\":\n      case \"\\r\":\n      case \"\\u2028\":\n      case \"\\u2029\":\n        return false;\n      default:\n        return true;\n    }\n  }\n\n  protected parseHexDigits(howMany: number): Omit<Character, \"loc\"> {\n    let hexString = \"\";\n    for (let i = 0; i < howMany; i++) {\n      const hexChar = this.popChar();\n      if (hexDigitPattern.test(hexChar) === false) {\n        throw Error(\"Expecting a HexDecimal digits\");\n      }\n      hexString += hexChar;\n    }\n    const charCode = parseInt(hexString, 16);\n    return { type: \"Character\", value: charCode };\n  }\n\n  protected peekChar(howMuch = 0): string {\n    return this.input[this.idx + howMuch];\n  }\n\n  protected popChar(): string {\n    const nextChar = this.peekChar(0);\n    this.consumeChar(undefined);\n    return nextChar;\n  }\n\n  protected consumeChar(char: string | undefined): void {\n    if (char !== undefined && this.input[this.idx] !== char) {\n      throw Error(\n        \"Expected: '\" +\n          char +\n          \"' but found: '\" +\n          this.input[this.idx] +\n          \"' at offset: \" +\n          this.idx,\n      );\n    }\n\n    if (this.idx >= this.input.length) {\n      throw Error(\"Unexpected end of input\");\n    }\n    this.idx++;\n  }\n\n  protected loc(begin: number): Location {\n    return { begin: begin, end: this.idx };\n  }\n}\n","import type {\n  Alternative,\n  Assertion,\n  Character,\n  Disjunction,\n  Group,\n  GroupBackReference,\n  IRegExpAST,\n  Quantifier,\n  RegExpAstPart,\n  RegExpFlags,\n  RegExpPattern,\n  Set,\n} from \"../types\";\n\nexport class BaseRegExpVisitor {\n  public visitChildren(node: IRegExpAST) {\n    for (const key in node) {\n      const child = (node as any)[key];\n      /* istanbul ignore else */\n      if (node.hasOwnProperty(key)) {\n        if (child.type !== undefined) {\n          this.visit(child);\n        } else if (Array.isArray(child)) {\n          child.forEach((subChild) => {\n            this.visit(subChild);\n          }, this);\n        }\n      }\n    }\n  }\n\n  public visit(node: RegExpAstPart): void {\n    switch (node.type) {\n      case \"Pattern\":\n        this.visitPattern(node);\n        break;\n      case \"Flags\":\n        this.visitFlags(node);\n        break;\n      case \"Disjunction\":\n        this.visitDisjunction(node);\n        break;\n      case \"Alternative\":\n        this.visitAlternative(node);\n        break;\n      case \"StartAnchor\":\n        this.visitStartAnchor(node);\n        break;\n      case \"EndAnchor\":\n        this.visitEndAnchor(node);\n        break;\n      case \"WordBoundary\":\n        this.visitWordBoundary(node);\n        break;\n      case \"NonWordBoundary\":\n        this.visitNonWordBoundary(node);\n        break;\n      case \"Lookahead\":\n        this.visitLookahead(node);\n        break;\n      case \"NegativeLookahead\":\n        this.visitNegativeLookahead(node);\n        break;\n      case \"Character\":\n        this.visitCharacter(node);\n        break;\n      case \"Set\":\n        this.visitSet(node);\n        break;\n      case \"Group\":\n        this.visitGroup(node);\n        break;\n      case \"GroupBackReference\":\n        this.visitGroupBackReference(node);\n        break;\n      case \"Quantifier\":\n        this.visitQuantifier(node);\n        break;\n    }\n\n    this.visitChildren(node);\n  }\n\n  public visitPattern(node: RegExpPattern): void {}\n\n  public visitFlags(node: RegExpFlags): void {}\n\n  public visitDisjunction(node: Disjunction): void {}\n\n  public visitAlternative(node: Alternative): void {}\n\n  // Assertion\n  public visitStartAnchor(node: Assertion): void {}\n\n  public visitEndAnchor(node: Assertion): void {}\n\n  public visitWordBoundary(node: Assertion): void {}\n\n  public visitNonWordBoundary(node: Assertion): void {}\n\n  public visitLookahead(node: Assertion): void {}\n\n  public visitNegativeLookahead(node: Assertion): void {}\n\n  // atoms\n  public visitCharacter(node: Character): void {}\n\n  public visitSet(node: Set): void {}\n\n  public visitGroup(node: Group): void {}\n\n  public visitGroupBackReference(node: GroupBackReference): void {}\n\n  public visitQuantifier(node: Quantifier): void {}\n}\n","import {\n  Alternative,\n  Assertion,\n  Atom,\n  Disjunction,\n  RegExpParser,\n  RegExpPattern,\n} from \"@chevrotain/regexp-to-ast\";\n\nlet regExpAstCache: { [regex: string]: RegExpPattern } = {};\nconst regExpParser = new RegExpParser();\n\n// this should be moved to regexp-to-ast\nexport type ASTNode =\n  | RegExpPattern\n  | Disjunction\n  | Alternative\n  | Assertion\n  | Atom;\n\nexport function getRegExpAst(regExp: RegExp): RegExpPattern {\n  const regExpStr = regExp.toString();\n  if (regExpAstCache.hasOwnProperty(regExpStr)) {\n    return regExpAstCache[regExpStr];\n  } else {\n    const regExpAst = regExpParser.pattern(regExpStr);\n    regExpAstCache[regExpStr] = regExpAst;\n    return regExpAst;\n  }\n}\n\nexport function clearRegExpParserCache() {\n  regExpAstCache = {};\n}\n","import {\n  Alternative,\n  Atom,\n  BaseRegExpVisitor,\n  Character,\n  Disjunction,\n  Group,\n  Set,\n} from \"@chevrotain/regexp-to-ast\";\nimport { every, find, forEach, includes, isArray, values } from \"lodash-es\";\nimport { PRINT_ERROR, PRINT_WARNING } from \"@chevrotain/utils\";\nimport { ASTNode, getRegExpAst } from \"./reg_exp_parser.js\";\nimport { charCodeToOptimizedIndex, minOptimizationVal } from \"./lexer.js\";\n\nconst complementErrorMessage =\n  \"Complement Sets are not supported for first char optimization\";\nexport const failedOptimizationPrefixMsg =\n  'Unable to use \"first char\" lexer optimizations:\\n';\n\nexport function getOptimizedStartCodesIndices(\n  regExp: RegExp,\n  ensureOptimizations = false,\n): number[] {\n  try {\n    const ast = getRegExpAst(regExp);\n    const firstChars = firstCharOptimizedIndices(\n      ast.value,\n      {},\n      ast.flags.ignoreCase,\n    );\n    return firstChars;\n  } catch (e) {\n    /* istanbul ignore next */\n    // Testing this relies on the regexp-to-ast library having a bug... */\n    // TODO: only the else branch needs to be ignored, try to fix with newer prettier / tsc\n    if (e.message === complementErrorMessage) {\n      if (ensureOptimizations) {\n        PRINT_WARNING(\n          `${failedOptimizationPrefixMsg}` +\n            `\\tUnable to optimize: < ${regExp.toString()} >\\n` +\n            \"\\tComplement Sets cannot be automatically optimized.\\n\" +\n            \"\\tThis will disable the lexer's first char optimizations.\\n\" +\n            \"\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.\",\n        );\n      }\n    } else {\n      let msgSuffix = \"\";\n      if (ensureOptimizations) {\n        msgSuffix =\n          \"\\n\\tThis will disable the lexer's first char optimizations.\\n\" +\n          \"\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.\";\n      }\n      PRINT_ERROR(\n        `${failedOptimizationPrefixMsg}\\n` +\n          `\\tFailed parsing: < ${regExp.toString()} >\\n` +\n          `\\tUsing the @chevrotain/regexp-to-ast library\\n` +\n          \"\\tPlease open an issue at: https://github.com/chevrotain/chevrotain/issues\" +\n          msgSuffix,\n      );\n    }\n  }\n\n  return [];\n}\n\nexport function firstCharOptimizedIndices(\n  ast: ASTNode,\n  result: { [charCode: number]: number },\n  ignoreCase: boolean,\n): number[] {\n  switch (ast.type) {\n    case \"Disjunction\":\n      for (let i = 0; i < ast.value.length; i++) {\n        firstCharOptimizedIndices(ast.value[i], result, ignoreCase);\n      }\n      break;\n    case \"Alternative\":\n      const terms = ast.value;\n      for (let i = 0; i < terms.length; i++) {\n        const term = terms[i];\n\n        // skip terms that cannot effect the first char results\n        switch (term.type) {\n          case \"EndAnchor\":\n          // A group back reference cannot affect potential starting char.\n          // because if a back reference is the first production than automatically\n          // the group being referenced has had to come BEFORE so its codes have already been added\n          case \"GroupBackReference\":\n          // assertions do not affect potential starting codes\n          case \"Lookahead\":\n          case \"NegativeLookahead\":\n          case \"StartAnchor\":\n          case \"WordBoundary\":\n          case \"NonWordBoundary\":\n            continue;\n        }\n\n        const atom = term;\n        switch (atom.type) {\n          case \"Character\":\n            addOptimizedIdxToResult(atom.value, result, ignoreCase);\n            break;\n          case \"Set\":\n            if (atom.complement === true) {\n              throw Error(complementErrorMessage);\n            }\n            forEach(atom.value, (code) => {\n              if (typeof code === \"number\") {\n                addOptimizedIdxToResult(code, result, ignoreCase);\n              } else {\n                // range\n                const range = code as any;\n                // cannot optimize when ignoreCase is\n                if (ignoreCase === true) {\n                  for (\n                    let rangeCode = range.from;\n                    rangeCode <= range.to;\n                    rangeCode++\n                  ) {\n                    addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                  }\n                }\n                // Optimization (2 orders of magnitude less work for very large ranges)\n                else {\n                  // handle unoptimized values\n                  for (\n                    let rangeCode = range.from;\n                    rangeCode <= range.to && rangeCode < minOptimizationVal;\n                    rangeCode++\n                  ) {\n                    addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                  }\n\n                  // Less common charCode where we optimize for faster init time, by using larger \"buckets\"\n                  if (range.to >= minOptimizationVal) {\n                    const minUnOptVal =\n                      range.from >= minOptimizationVal\n                        ? range.from\n                        : minOptimizationVal;\n                    const maxUnOptVal = range.to;\n                    const minOptIdx = charCodeToOptimizedIndex(minUnOptVal);\n                    const maxOptIdx = charCodeToOptimizedIndex(maxUnOptVal);\n\n                    for (\n                      let currOptIdx = minOptIdx;\n                      currOptIdx <= maxOptIdx;\n                      currOptIdx++\n                    ) {\n                      result[currOptIdx] = currOptIdx;\n                    }\n                  }\n                }\n              }\n            });\n            break;\n          case \"Group\":\n            firstCharOptimizedIndices(atom.value, result, ignoreCase);\n            break;\n          /* istanbul ignore next */\n          default:\n            throw Error(\"Non Exhaustive Match\");\n        }\n\n        // reached a mandatory production, no more **start** codes can be found on this alternative\n        const isOptionalQuantifier =\n          atom.quantifier !== undefined && atom.quantifier.atLeast === 0;\n        if (\n          // A group may be optional due to empty contents /(?:)/\n          // or if everything inside it is optional /((a)?)/\n          (atom.type === \"Group\" && isWholeOptional(atom) === false) ||\n          // If this term is not a group it may only be optional if it has an optional quantifier\n          (atom.type !== \"Group\" && isOptionalQuantifier === false)\n        ) {\n          break;\n        }\n      }\n      break;\n    /* istanbul ignore next */\n    default:\n      throw Error(\"non exhaustive match!\");\n  }\n\n  // console.log(Object.keys(result).length)\n  return values(result);\n}\n\nfunction addOptimizedIdxToResult(\n  code: number,\n  result: { [charCode: number]: number },\n  ignoreCase: boolean,\n) {\n  const optimizedCharIdx = charCodeToOptimizedIndex(code);\n  result[optimizedCharIdx] = optimizedCharIdx;\n\n  if (ignoreCase === true) {\n    handleIgnoreCase(code, result);\n  }\n}\n\nfunction handleIgnoreCase(\n  code: number,\n  result: { [charCode: number]: number },\n) {\n  const char = String.fromCharCode(code);\n  const upperChar = char.toUpperCase();\n  /* istanbul ignore else */\n  if (upperChar !== char) {\n    const optimizedCharIdx = charCodeToOptimizedIndex(upperChar.charCodeAt(0));\n    result[optimizedCharIdx] = optimizedCharIdx;\n  } else {\n    const lowerChar = char.toLowerCase();\n    if (lowerChar !== char) {\n      const optimizedCharIdx = charCodeToOptimizedIndex(\n        lowerChar.charCodeAt(0),\n      );\n      result[optimizedCharIdx] = optimizedCharIdx;\n    }\n  }\n}\n\nfunction findCode(setNode: Set, targetCharCodes: number[]) {\n  return find(setNode.value, (codeOrRange) => {\n    if (typeof codeOrRange === \"number\") {\n      return includes(targetCharCodes, codeOrRange);\n    } else {\n      // range\n      const range = <any>codeOrRange;\n      return (\n        find(\n          targetCharCodes,\n          (targetCode) => range.from <= targetCode && targetCode <= range.to,\n        ) !== undefined\n      );\n    }\n  });\n}\n\nfunction isWholeOptional(ast: any): boolean {\n  const quantifier = (ast as Atom).quantifier;\n  if (quantifier && quantifier.atLeast === 0) {\n    return true;\n  }\n\n  if (!ast.value) {\n    return false;\n  }\n\n  return isArray(ast.value)\n    ? every(ast.value, isWholeOptional)\n    : isWholeOptional(ast.value);\n}\n\nclass CharCodeFinder extends BaseRegExpVisitor {\n  found: boolean = false;\n\n  constructor(private targetCharCodes: number[]) {\n    super();\n  }\n\n  visitChildren(node: ASTNode) {\n    // No need to keep looking...\n    if (this.found === true) {\n      return;\n    }\n\n    // switch lookaheads as they do not actually consume any characters thus\n    // finding a charCode at lookahead context does not mean that regexp can actually contain it in a match.\n    switch (node.type) {\n      case \"Lookahead\":\n        this.visitLookahead(node);\n        return;\n      case \"NegativeLookahead\":\n        this.visitNegativeLookahead(node);\n        return;\n    }\n\n    super.visitChildren(node);\n  }\n\n  visitCharacter(node: Character) {\n    if (includes(this.targetCharCodes, node.value)) {\n      this.found = true;\n    }\n  }\n\n  visitSet(node: Set) {\n    if (node.complement) {\n      if (findCode(node, this.targetCharCodes) === undefined) {\n        this.found = true;\n      }\n    } else {\n      if (findCode(node, this.targetCharCodes) !== undefined) {\n        this.found = true;\n      }\n    }\n  }\n}\n\nexport function canMatchCharCode(\n  charCodes: number[],\n  pattern: RegExp | string,\n) {\n  if (pattern instanceof RegExp) {\n    const ast = getRegExpAst(pattern);\n    const charCodeFinder = new CharCodeFinder(charCodes);\n    charCodeFinder.visit(ast);\n    return charCodeFinder.found;\n  } else {\n    return (\n      find(<any>pattern, (char) => {\n        return includes(charCodes, (<string>char).charCodeAt(0));\n      }) !== undefined\n    );\n  }\n}\n","import { BaseRegExpVisitor } from \"@chevrotain/regexp-to-ast\";\nimport {\n  IRegExpExec,\n  Lexer,\n  LexerDefinitionErrorType,\n} from \"./lexer_public.js\";\nimport {\n  compact,\n  defaults,\n  difference,\n  filter,\n  find,\n  first,\n  flatten,\n  forEach,\n  has,\n  includes,\n  indexOf,\n  isArray,\n  isEmpty,\n  isFunction,\n  isRegExp,\n  isString,\n  isUndefined,\n  keys,\n  map,\n  reduce,\n  reject,\n  values,\n} from \"lodash-es\";\nimport { PRINT_ERROR } from \"@chevrotain/utils\";\nimport {\n  canMatchCharCode,\n  failedOptimizationPrefixMsg,\n  getOptimizedStartCodesIndices,\n} from \"./reg_exp.js\";\nimport {\n  ILexerDefinitionError,\n  ILineTerminatorsTester,\n  IMultiModeLexerDefinition,\n  IToken,\n  TokenType,\n} from \"@chevrotain/types\";\nimport { getRegExpAst } from \"./reg_exp_parser.js\";\n\nconst PATTERN = \"PATTERN\";\nexport const DEFAULT_MODE = \"defaultMode\";\nexport const MODES = \"modes\";\n\nexport interface IPatternConfig {\n  pattern: IRegExpExec | string;\n  longerAlt: number[] | undefined;\n  canLineTerminator: boolean;\n  isCustom: boolean;\n  short: number | false;\n  group: string | undefined | false;\n  push: string | undefined;\n  pop: boolean;\n  tokenType: TokenType;\n  tokenTypeIdx: number;\n}\n\nexport interface IAnalyzeResult {\n  patternIdxToConfig: IPatternConfig[];\n  charCodeToPatternIdxToConfig: { [charCode: number]: IPatternConfig[] };\n  emptyGroups: { [groupName: string]: IToken[] };\n  hasCustom: boolean;\n  canBeOptimized: boolean;\n}\n\nexport let SUPPORT_STICKY =\n  typeof (<any>new RegExp(\"(?:)\")).sticky === \"boolean\";\n\nexport function disableSticky() {\n  SUPPORT_STICKY = false;\n}\n\nexport function enableSticky() {\n  SUPPORT_STICKY = true;\n}\n\nexport function analyzeTokenTypes(\n  tokenTypes: TokenType[],\n  options: {\n    positionTracking?: \"full\" | \"onlyStart\" | \"onlyOffset\";\n    ensureOptimizations?: boolean;\n    lineTerminatorCharacters?: (number | string)[];\n    // TODO: should `useSticky` be an argument here?\n    useSticky?: boolean;\n    safeMode?: boolean;\n    tracer?: (msg: string, action: () => void) => void;\n  },\n): IAnalyzeResult {\n  options = defaults(options, {\n    useSticky: SUPPORT_STICKY,\n    debug: false as boolean,\n    safeMode: false as boolean,\n    positionTracking: \"full\",\n    lineTerminatorCharacters: [\"\\r\", \"\\n\"],\n    tracer: (msg: string, action: Function) => action(),\n  });\n\n  const tracer = options.tracer!;\n\n  tracer(\"initCharCodeToOptimizedIndexMap\", () => {\n    initCharCodeToOptimizedIndexMap();\n  });\n\n  let onlyRelevantTypes: TokenType[];\n  tracer(\"Reject Lexer.NA\", () => {\n    onlyRelevantTypes = reject(tokenTypes, (currType) => {\n      return currType[PATTERN] === Lexer.NA;\n    });\n  });\n\n  let hasCustom = false;\n  let allTransformedPatterns: (IRegExpExec | string)[];\n  tracer(\"Transform Patterns\", () => {\n    hasCustom = false;\n    allTransformedPatterns = map(\n      onlyRelevantTypes,\n      (currType): IRegExpExec | string => {\n        const currPattern = currType[PATTERN];\n\n        /* istanbul ignore else */\n        if (isRegExp(currPattern)) {\n          const regExpSource = currPattern.source;\n          if (\n            regExpSource.length === 1 &&\n            // only these regExp meta characters which can appear in a length one regExp\n            regExpSource !== \"^\" &&\n            regExpSource !== \"$\" &&\n            regExpSource !== \".\" &&\n            !currPattern.ignoreCase\n          ) {\n            return regExpSource;\n          } else if (\n            regExpSource.length === 2 &&\n            regExpSource[0] === \"\\\\\" &&\n            // not a meta character\n            !includes(\n              [\n                \"d\",\n                \"D\",\n                \"s\",\n                \"S\",\n                \"t\",\n                \"r\",\n                \"n\",\n                \"t\",\n                \"0\",\n                \"c\",\n                \"b\",\n                \"B\",\n                \"f\",\n                \"v\",\n                \"w\",\n                \"W\",\n              ],\n              regExpSource[1],\n            )\n          ) {\n            // escaped meta Characters: /\\+/ /\\[/\n            // or redundant escaping: /\\a/\n            // without the escaping \"\\\"\n            return regExpSource[1];\n          } else {\n            return options.useSticky\n              ? addStickyFlag(currPattern)\n              : addStartOfInput(currPattern);\n          }\n        } else if (isFunction(currPattern)) {\n          hasCustom = true;\n          // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object\n          return { exec: currPattern };\n        } else if (typeof currPattern === \"object\") {\n          hasCustom = true;\n          // ICustomPattern\n          return currPattern;\n        } else if (typeof currPattern === \"string\") {\n          if (currPattern.length === 1) {\n            return currPattern;\n          } else {\n            const escapedRegExpString = currPattern.replace(\n              /[\\\\^$.*+?()[\\]{}|]/g,\n              \"\\\\$&\",\n            );\n            const wrappedRegExp = new RegExp(escapedRegExpString);\n            return options.useSticky\n              ? addStickyFlag(wrappedRegExp)\n              : addStartOfInput(wrappedRegExp);\n          }\n        } else {\n          throw Error(\"non exhaustive match\");\n        }\n      },\n    );\n  });\n\n  let patternIdxToType: number[];\n  let patternIdxToGroup: (string | undefined | false)[];\n  let patternIdxToLongerAltIdxArr: (number[] | undefined)[];\n  let patternIdxToPushMode: (string | undefined)[];\n  let patternIdxToPopMode: boolean[];\n  tracer(\"misc mapping\", () => {\n    patternIdxToType = map(\n      onlyRelevantTypes,\n      (currType) => currType.tokenTypeIdx!,\n    );\n\n    patternIdxToGroup = map(onlyRelevantTypes, (clazz: any) => {\n      const groupName = clazz.GROUP;\n      /* istanbul ignore next */\n      if (groupName === Lexer.SKIPPED) {\n        return undefined;\n      } else if (isString(groupName)) {\n        return groupName;\n      } else if (isUndefined(groupName)) {\n        return false;\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    });\n\n    patternIdxToLongerAltIdxArr = map(onlyRelevantTypes, (clazz: any) => {\n      const longerAltType = clazz.LONGER_ALT;\n\n      if (longerAltType) {\n        const longerAltIdxArr = isArray(longerAltType)\n          ? map(longerAltType, (type: any) => indexOf(onlyRelevantTypes, type))\n          : [indexOf(onlyRelevantTypes, longerAltType)];\n        return longerAltIdxArr;\n      }\n    });\n\n    patternIdxToPushMode = map(\n      onlyRelevantTypes,\n      (clazz: any) => clazz.PUSH_MODE,\n    );\n\n    patternIdxToPopMode = map(onlyRelevantTypes, (clazz: any) =>\n      has(clazz, \"POP_MODE\"),\n    );\n  });\n\n  let patternIdxToCanLineTerminator: boolean[];\n  tracer(\"Line Terminator Handling\", () => {\n    const lineTerminatorCharCodes = getCharCodes(\n      options.lineTerminatorCharacters!,\n    );\n    patternIdxToCanLineTerminator = map(onlyRelevantTypes, (tokType) => false);\n    if (options.positionTracking !== \"onlyOffset\") {\n      patternIdxToCanLineTerminator = map(onlyRelevantTypes, (tokType) => {\n        if (has(tokType, \"LINE_BREAKS\")) {\n          return !!tokType.LINE_BREAKS;\n        } else {\n          return (\n            checkLineBreaksIssues(tokType, lineTerminatorCharCodes) === false &&\n            canMatchCharCode(\n              lineTerminatorCharCodes,\n              tokType.PATTERN as RegExp | string,\n            )\n          );\n        }\n      });\n    }\n  });\n\n  let patternIdxToIsCustom: boolean[];\n  let patternIdxToShort: (number | false)[];\n  let emptyGroups!: { [groupName: string]: IToken[] };\n  let patternIdxToConfig!: IPatternConfig[];\n  tracer(\"Misc Mapping #2\", () => {\n    patternIdxToIsCustom = map(onlyRelevantTypes, isCustomPattern);\n    patternIdxToShort = map(allTransformedPatterns, isShortPattern);\n\n    emptyGroups = reduce(\n      onlyRelevantTypes,\n      (acc, clazz: any) => {\n        const groupName = clazz.GROUP;\n        if (isString(groupName) && !(groupName === Lexer.SKIPPED)) {\n          acc[groupName] = [];\n        }\n        return acc;\n      },\n      {} as { [groupName: string]: IToken[] },\n    );\n\n    patternIdxToConfig = map(\n      allTransformedPatterns,\n      (x, idx): IPatternConfig => {\n        return {\n          pattern: allTransformedPatterns[idx],\n          longerAlt: patternIdxToLongerAltIdxArr[idx],\n          canLineTerminator: patternIdxToCanLineTerminator[idx],\n          isCustom: patternIdxToIsCustom[idx],\n          short: patternIdxToShort[idx],\n          group: patternIdxToGroup[idx],\n          push: patternIdxToPushMode[idx],\n          pop: patternIdxToPopMode[idx],\n          tokenTypeIdx: patternIdxToType[idx],\n          tokenType: onlyRelevantTypes[idx],\n        };\n      },\n    );\n  });\n\n  let canBeOptimized = true;\n  let charCodeToPatternIdxToConfig: { [charCode: number]: IPatternConfig[] } =\n    [];\n\n  if (!options.safeMode) {\n    tracer(\"First Char Optimization\", () => {\n      charCodeToPatternIdxToConfig = reduce(\n        onlyRelevantTypes,\n        (result, currTokType, idx) => {\n          if (typeof currTokType.PATTERN === \"string\") {\n            const charCode = currTokType.PATTERN.charCodeAt(0);\n            const optimizedIdx = charCodeToOptimizedIndex(charCode);\n            addToMapOfArrays(result, optimizedIdx, patternIdxToConfig[idx]);\n          } else if (isArray(currTokType.START_CHARS_HINT)) {\n            let lastOptimizedIdx: number;\n            forEach(currTokType.START_CHARS_HINT, (charOrInt) => {\n              const charCode =\n                typeof charOrInt === \"string\"\n                  ? charOrInt.charCodeAt(0)\n                  : charOrInt;\n              const currOptimizedIdx = charCodeToOptimizedIndex(charCode);\n              // Avoid adding the config multiple times\n              /* istanbul ignore else */\n              // - Difficult to check this scenario effects as it is only a performance\n              //   optimization that does not change correctness\n              if (lastOptimizedIdx !== currOptimizedIdx) {\n                lastOptimizedIdx = currOptimizedIdx;\n                addToMapOfArrays(\n                  result,\n                  currOptimizedIdx,\n                  patternIdxToConfig[idx],\n                );\n              }\n            });\n          } else if (isRegExp(currTokType.PATTERN)) {\n            if (currTokType.PATTERN.unicode) {\n              canBeOptimized = false;\n              if (options.ensureOptimizations) {\n                PRINT_ERROR(\n                  `${failedOptimizationPrefixMsg}` +\n                    `\\tUnable to analyze < ${currTokType.PATTERN.toString()} > pattern.\\n` +\n                    \"\\tThe regexp unicode flag is not currently supported by the regexp-to-ast library.\\n\" +\n                    \"\\tThis will disable the lexer's first char optimizations.\\n\" +\n                    \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE\",\n                );\n              }\n            } else {\n              const optimizedCodes = getOptimizedStartCodesIndices(\n                currTokType.PATTERN,\n                options.ensureOptimizations,\n              );\n              /* istanbul ignore if */\n              // start code will only be empty given an empty regExp or failure of regexp-to-ast library\n              // the first should be a different validation and the second cannot be tested.\n              if (isEmpty(optimizedCodes)) {\n                // we cannot understand what codes may start possible matches\n                // The optimization correctness requires knowing start codes for ALL patterns.\n                // Not actually sure this is an error, no debug message\n                canBeOptimized = false;\n              }\n              forEach(optimizedCodes, (code) => {\n                addToMapOfArrays(result, code, patternIdxToConfig[idx]);\n              });\n            }\n          } else {\n            if (options.ensureOptimizations) {\n              PRINT_ERROR(\n                `${failedOptimizationPrefixMsg}` +\n                  `\\tTokenType: <${currTokType.name}> is using a custom token pattern without providing <start_chars_hint> parameter.\\n` +\n                  \"\\tThis will disable the lexer's first char optimizations.\\n\" +\n                  \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE\",\n              );\n            }\n            canBeOptimized = false;\n          }\n\n          return result;\n        },\n        [] as { [charCode: number]: IPatternConfig[] },\n      );\n    });\n  }\n\n  return {\n    emptyGroups: emptyGroups,\n    patternIdxToConfig: patternIdxToConfig,\n    charCodeToPatternIdxToConfig: charCodeToPatternIdxToConfig,\n    hasCustom: hasCustom,\n    canBeOptimized: canBeOptimized,\n  };\n}\n\nexport function validatePatterns(\n  tokenTypes: TokenType[],\n  validModesNames: string[],\n): ILexerDefinitionError[] {\n  let errors: ILexerDefinitionError[] = [];\n\n  const missingResult = findMissingPatterns(tokenTypes);\n  errors = errors.concat(missingResult.errors);\n\n  const invalidResult = findInvalidPatterns(missingResult.valid);\n  const validTokenTypes = invalidResult.valid;\n  errors = errors.concat(invalidResult.errors);\n\n  errors = errors.concat(validateRegExpPattern(validTokenTypes));\n\n  errors = errors.concat(findInvalidGroupType(validTokenTypes));\n\n  errors = errors.concat(\n    findModesThatDoNotExist(validTokenTypes, validModesNames),\n  );\n\n  errors = errors.concat(findUnreachablePatterns(validTokenTypes));\n\n  return errors;\n}\n\nfunction validateRegExpPattern(\n  tokenTypes: TokenType[],\n): ILexerDefinitionError[] {\n  let errors: ILexerDefinitionError[] = [];\n  const withRegExpPatterns = filter(tokenTypes, (currTokType) =>\n    isRegExp(currTokType[PATTERN]),\n  );\n\n  errors = errors.concat(findEndOfInputAnchor(withRegExpPatterns));\n\n  errors = errors.concat(findStartOfInputAnchor(withRegExpPatterns));\n\n  errors = errors.concat(findUnsupportedFlags(withRegExpPatterns));\n\n  errors = errors.concat(findDuplicatePatterns(withRegExpPatterns));\n\n  errors = errors.concat(findEmptyMatchRegExps(withRegExpPatterns));\n\n  return errors;\n}\n\nexport interface ILexerFilterResult {\n  errors: ILexerDefinitionError[];\n  valid: TokenType[];\n}\n\nexport function findMissingPatterns(\n  tokenTypes: TokenType[],\n): ILexerFilterResult {\n  const tokenTypesWithMissingPattern = filter(tokenTypes, (currType) => {\n    return !has(currType, PATTERN);\n  });\n\n  const errors = map(tokenTypesWithMissingPattern, (currType) => {\n    return {\n      message:\n        \"Token Type: ->\" +\n        currType.name +\n        \"<- missing static 'PATTERN' property\",\n      type: LexerDefinitionErrorType.MISSING_PATTERN,\n      tokenTypes: [currType],\n    };\n  });\n\n  const valid = difference(tokenTypes, tokenTypesWithMissingPattern);\n  return { errors, valid };\n}\n\nexport function findInvalidPatterns(\n  tokenTypes: TokenType[],\n): ILexerFilterResult {\n  const tokenTypesWithInvalidPattern = filter(tokenTypes, (currType) => {\n    const pattern = currType[PATTERN];\n    return (\n      !isRegExp(pattern) &&\n      !isFunction(pattern) &&\n      !has(pattern, \"exec\") &&\n      !isString(pattern)\n    );\n  });\n\n  const errors = map(tokenTypesWithInvalidPattern, (currType) => {\n    return {\n      message:\n        \"Token Type: ->\" +\n        currType.name +\n        \"<- static 'PATTERN' can only be a RegExp, a\" +\n        \" Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.\",\n      type: LexerDefinitionErrorType.INVALID_PATTERN,\n      tokenTypes: [currType],\n    };\n  });\n\n  const valid = difference(tokenTypes, tokenTypesWithInvalidPattern);\n  return { errors, valid };\n}\n\nconst end_of_input = /[^\\\\][$]/;\n\nexport function findEndOfInputAnchor(\n  tokenTypes: TokenType[],\n): ILexerDefinitionError[] {\n  class EndAnchorFinder extends BaseRegExpVisitor {\n    found = false;\n\n    visitEndAnchor(node: unknown) {\n      this.found = true;\n    }\n  }\n\n  const invalidRegex = filter(tokenTypes, (currType) => {\n    const pattern = currType.PATTERN;\n\n    try {\n      const regexpAst = getRegExpAst(pattern as RegExp);\n      const endAnchorVisitor = new EndAnchorFinder();\n      endAnchorVisitor.visit(regexpAst);\n\n      return endAnchorVisitor.found;\n    } catch (e) {\n      // old behavior in case of runtime exceptions with regexp-to-ast.\n      /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/\n      return end_of_input.test((pattern as RegExp).source);\n    }\n  });\n\n  const errors = map(invalidRegex, (currType) => {\n    return {\n      message:\n        \"Unexpected RegExp Anchor Error:\\n\" +\n        \"\\tToken Type: ->\" +\n        currType.name +\n        \"<- static 'PATTERN' cannot contain end of input anchor '$'\\n\" +\n        \"\\tSee chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS\" +\n        \"\\tfor details.\",\n      type: LexerDefinitionErrorType.EOI_ANCHOR_FOUND,\n      tokenTypes: [currType],\n    };\n  });\n\n  return errors;\n}\n\nexport function findEmptyMatchRegExps(\n  tokenTypes: TokenType[],\n): ILexerDefinitionError[] {\n  const matchesEmptyString = filter(tokenTypes, (currType) => {\n    const pattern = currType.PATTERN as RegExp;\n    return pattern.test(\"\");\n  });\n\n  const errors = map(matchesEmptyString, (currType) => {\n    return {\n      message:\n        \"Token Type: ->\" +\n        currType.name +\n        \"<- static 'PATTERN' must not match an empty string\",\n      type: LexerDefinitionErrorType.EMPTY_MATCH_PATTERN,\n      tokenTypes: [currType],\n    };\n  });\n\n  return errors;\n}\n\nconst start_of_input = /[^\\\\[][\\^]|^\\^/;\n\nexport function findStartOfInputAnchor(\n  tokenTypes: TokenType[],\n): ILexerDefinitionError[] {\n  class StartAnchorFinder extends BaseRegExpVisitor {\n    found = false;\n\n    visitStartAnchor(node: unknown) {\n      this.found = true;\n    }\n  }\n\n  const invalidRegex = filter(tokenTypes, (currType) => {\n    const pattern = currType.PATTERN as RegExp;\n    try {\n      const regexpAst = getRegExpAst(pattern);\n      const startAnchorVisitor = new StartAnchorFinder();\n      startAnchorVisitor.visit(regexpAst);\n\n      return startAnchorVisitor.found;\n    } catch (e) {\n      // old behavior in case of runtime exceptions with regexp-to-ast.\n      /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/\n      return start_of_input.test(pattern.source);\n    }\n  });\n\n  const errors = map(invalidRegex, (currType) => {\n    return {\n      message:\n        \"Unexpected RegExp Anchor Error:\\n\" +\n        \"\\tToken Type: ->\" +\n        currType.name +\n        \"<- static 'PATTERN' cannot contain start of input anchor '^'\\n\" +\n        \"\\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS\" +\n        \"\\tfor details.\",\n      type: LexerDefinitionErrorType.SOI_ANCHOR_FOUND,\n      tokenTypes: [currType],\n    };\n  });\n\n  return errors;\n}\n\nexport function findUnsupportedFlags(\n  tokenTypes: TokenType[],\n): ILexerDefinitionError[] {\n  const invalidFlags = filter(tokenTypes, (currType) => {\n    const pattern = currType[PATTERN];\n    return pattern instanceof RegExp && (pattern.multiline || pattern.global);\n  });\n\n  const errors = map(invalidFlags, (currType) => {\n    return {\n      message:\n        \"Token Type: ->\" +\n        currType.name +\n        \"<- static 'PATTERN' may NOT contain global('g') or multiline('m')\",\n      type: LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND,\n      tokenTypes: [currType],\n    };\n  });\n\n  return errors;\n}\n\n// This can only test for identical duplicate RegExps, not semantically equivalent ones.\nexport function findDuplicatePatterns(\n  tokenTypes: TokenType[],\n): ILexerDefinitionError[] {\n  const found: TokenType[] = [];\n  let identicalPatterns = map(tokenTypes, (outerType: any) => {\n    return reduce(\n      tokenTypes,\n      (result, innerType) => {\n        if (\n          outerType.PATTERN.source === (innerType.PATTERN as RegExp).source &&\n          !includes(found, innerType) &&\n          innerType.PATTERN !== Lexer.NA\n        ) {\n          // this avoids duplicates in the result, each Token Type may only appear in one \"set\"\n          // in essence we are creating Equivalence classes on equality relation.\n          found.push(innerType);\n          result.push(innerType);\n          return result;\n        }\n        return result;\n      },\n      [] as TokenType[],\n    );\n  });\n\n  identicalPatterns = compact(identicalPatterns);\n\n  const duplicatePatterns = filter(identicalPatterns, (currIdenticalSet) => {\n    return currIdenticalSet.length > 1;\n  });\n\n  const errors = map(duplicatePatterns, (setOfIdentical: any) => {\n    const tokenTypeNames = map(setOfIdentical, (currType: any) => {\n      return currType.name;\n    });\n\n    const dupPatternSrc = (<any>first(setOfIdentical)).PATTERN;\n    return {\n      message:\n        `The same RegExp pattern ->${dupPatternSrc}<-` +\n        `has been used in all of the following Token Types: ${tokenTypeNames.join(\n          \", \",\n        )} <-`,\n      type: LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND,\n      tokenTypes: setOfIdentical,\n    };\n  });\n\n  return errors;\n}\n\nexport function findInvalidGroupType(\n  tokenTypes: TokenType[],\n): ILexerDefinitionError[] {\n  const invalidTypes = filter(tokenTypes, (clazz: any) => {\n    if (!has(clazz, \"GROUP\")) {\n      return false;\n    }\n    const group = clazz.GROUP;\n\n    return group !== Lexer.SKIPPED && group !== Lexer.NA && !isString(group);\n  });\n\n  const errors = map(invalidTypes, (currType) => {\n    return {\n      message:\n        \"Token Type: ->\" +\n        currType.name +\n        \"<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String\",\n      type: LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND,\n      tokenTypes: [currType],\n    };\n  });\n\n  return errors;\n}\n\nexport function findModesThatDoNotExist(\n  tokenTypes: TokenType[],\n  validModes: string[],\n): ILexerDefinitionError[] {\n  const invalidModes = filter(tokenTypes, (clazz: any) => {\n    return (\n      clazz.PUSH_MODE !== undefined && !includes(validModes, clazz.PUSH_MODE)\n    );\n  });\n\n  const errors = map(invalidModes, (tokType) => {\n    const msg =\n      `Token Type: ->${tokType.name}<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->${tokType.PUSH_MODE}<-` +\n      `which does not exist`;\n    return {\n      message: msg,\n      type: LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST,\n      tokenTypes: [tokType],\n    };\n  });\n\n  return errors;\n}\n\nexport function findUnreachablePatterns(\n  tokenTypes: TokenType[],\n): ILexerDefinitionError[] {\n  const errors: ILexerDefinitionError[] = [];\n\n  const canBeTested = reduce(\n    tokenTypes,\n    (result, tokType, idx) => {\n      const pattern = tokType.PATTERN;\n\n      if (pattern === Lexer.NA) {\n        return result;\n      }\n\n      // a more comprehensive validation for all forms of regExps would require\n      // deeper regExp analysis capabilities\n      if (isString(pattern)) {\n        result.push({ str: pattern, idx, tokenType: tokType });\n      } else if (isRegExp(pattern) && noMetaChar(pattern)) {\n        result.push({ str: pattern.source, idx, tokenType: tokType });\n      }\n      return result;\n    },\n    [] as { str: string; idx: number; tokenType: TokenType }[],\n  );\n\n  forEach(tokenTypes, (tokType, testIdx) => {\n    forEach(canBeTested, ({ str, idx, tokenType }) => {\n      if (testIdx < idx && testTokenType(str, tokType.PATTERN)) {\n        const msg =\n          `Token: ->${tokenType.name}<- can never be matched.\\n` +\n          `Because it appears AFTER the Token Type ->${tokType.name}<-` +\n          `in the lexer's definition.\\n` +\n          `See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE`;\n        errors.push({\n          message: msg,\n          type: LexerDefinitionErrorType.UNREACHABLE_PATTERN,\n          tokenTypes: [tokType, tokenType],\n        });\n      }\n    });\n  });\n\n  return errors;\n}\n\nfunction testTokenType(str: string, pattern: any): boolean {\n  /* istanbul ignore else */\n  if (isRegExp(pattern)) {\n    const regExpArray = pattern.exec(str);\n    return regExpArray !== null && regExpArray.index === 0;\n  } else if (isFunction(pattern)) {\n    // maintain the API of custom patterns\n    return pattern(str, 0, [], {});\n  } else if (has(pattern, \"exec\")) {\n    // maintain the API of custom patterns\n    return pattern.exec(str, 0, [], {});\n  } else if (typeof pattern === \"string\") {\n    return pattern === str;\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\n\nfunction noMetaChar(regExp: RegExp): boolean {\n  //https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp\n  const metaChars = [\n    \".\",\n    \"\\\\\",\n    \"[\",\n    \"]\",\n    \"|\",\n    \"^\",\n    \"$\",\n    \"(\",\n    \")\",\n    \"?\",\n    \"*\",\n    \"+\",\n    \"{\",\n  ];\n  return (\n    find(metaChars, (char) => regExp.source.indexOf(char) !== -1) === undefined\n  );\n}\n\nexport function addStartOfInput(pattern: RegExp): RegExp {\n  const flags = pattern.ignoreCase ? \"i\" : \"\";\n  // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.\n  // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)\n  return new RegExp(`^(?:${pattern.source})`, flags);\n}\n\nexport function addStickyFlag(pattern: RegExp): RegExp {\n  const flags = pattern.ignoreCase ? \"iy\" : \"y\";\n  // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.\n  // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)\n  return new RegExp(`${pattern.source}`, flags);\n}\n\nexport function performRuntimeChecks(\n  lexerDefinition: IMultiModeLexerDefinition,\n  trackLines: boolean,\n  lineTerminatorCharacters: (number | string)[],\n): ILexerDefinitionError[] {\n  const errors: ILexerDefinitionError[] = [];\n\n  // some run time checks to help the end users.\n  if (!has(lexerDefinition, DEFAULT_MODE)) {\n    errors.push({\n      message:\n        \"A MultiMode Lexer cannot be initialized without a <\" +\n        DEFAULT_MODE +\n        \"> property in its definition\\n\",\n      type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE,\n    });\n  }\n  if (!has(lexerDefinition, MODES)) {\n    errors.push({\n      message:\n        \"A MultiMode Lexer cannot be initialized without a <\" +\n        MODES +\n        \"> property in its definition\\n\",\n      type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY,\n    });\n  }\n\n  if (\n    has(lexerDefinition, MODES) &&\n    has(lexerDefinition, DEFAULT_MODE) &&\n    !has(lexerDefinition.modes, lexerDefinition.defaultMode)\n  ) {\n    errors.push({\n      message:\n        `A MultiMode Lexer cannot be initialized with a ${DEFAULT_MODE}: <${lexerDefinition.defaultMode}>` +\n        `which does not exist\\n`,\n      type: LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST,\n    });\n  }\n\n  if (has(lexerDefinition, MODES)) {\n    forEach(lexerDefinition.modes, (currModeValue, currModeName) => {\n      forEach(currModeValue, (currTokType, currIdx) => {\n        if (isUndefined(currTokType)) {\n          errors.push({\n            message:\n              `A Lexer cannot be initialized using an undefined Token Type. Mode:` +\n              `<${currModeName}> at index: <${currIdx}>\\n`,\n            type: LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED,\n          });\n        } else if (has(currTokType, \"LONGER_ALT\")) {\n          const longerAlt = isArray(currTokType.LONGER_ALT)\n            ? currTokType.LONGER_ALT\n            : [currTokType.LONGER_ALT];\n          forEach(longerAlt, (currLongerAlt) => {\n            if (\n              !isUndefined(currLongerAlt) &&\n              !includes(currModeValue, currLongerAlt)\n            ) {\n              errors.push({\n                message: `A MultiMode Lexer cannot be initialized with a longer_alt <${currLongerAlt.name}> on token <${currTokType.name}> outside of mode <${currModeName}>\\n`,\n                type: LexerDefinitionErrorType.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE,\n              });\n            }\n          });\n        }\n      });\n    });\n  }\n\n  return errors;\n}\n\nexport function performWarningRuntimeChecks(\n  lexerDefinition: IMultiModeLexerDefinition,\n  trackLines: boolean,\n  lineTerminatorCharacters: (number | string)[],\n): ILexerDefinitionError[] {\n  const warnings = [];\n  let hasAnyLineBreak = false;\n  const allTokenTypes = compact(flatten(values(lexerDefinition.modes)));\n\n  const concreteTokenTypes = reject(\n    allTokenTypes,\n    (currType) => currType[PATTERN] === Lexer.NA,\n  );\n  const terminatorCharCodes = getCharCodes(lineTerminatorCharacters);\n  if (trackLines) {\n    forEach(concreteTokenTypes, (tokType) => {\n      const currIssue = checkLineBreaksIssues(tokType, terminatorCharCodes);\n      if (currIssue !== false) {\n        const message = buildLineBreakIssueMessage(tokType, currIssue);\n        const warningDescriptor = {\n          message,\n          type: currIssue.issue,\n          tokenType: tokType,\n        };\n        warnings.push(warningDescriptor);\n      } else {\n        // we don't want to attempt to scan if the user explicitly specified the line_breaks option.\n        if (has(tokType, \"LINE_BREAKS\")) {\n          if (tokType.LINE_BREAKS === true) {\n            hasAnyLineBreak = true;\n          }\n        } else {\n          if (\n            canMatchCharCode(terminatorCharCodes, tokType.PATTERN as RegExp)\n          ) {\n            hasAnyLineBreak = true;\n          }\n        }\n      }\n    });\n  }\n\n  if (trackLines && !hasAnyLineBreak) {\n    warnings.push({\n      message:\n        \"Warning: No LINE_BREAKS Found.\\n\" +\n        \"\\tThis Lexer has been defined to track line and column information,\\n\" +\n        \"\\tBut none of the Token Types can be identified as matching a line terminator.\\n\" +\n        \"\\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \\n\" +\n        \"\\tfor details.\",\n      type: LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS,\n    });\n  }\n  return warnings;\n}\n\nexport function cloneEmptyGroups(emptyGroups: {\n  [groupName: string]: IToken;\n}): { [groupName: string]: IToken } {\n  const clonedResult: any = {};\n  const groupKeys = keys(emptyGroups);\n\n  forEach(groupKeys, (currKey) => {\n    const currGroupValue = emptyGroups[currKey];\n\n    /* istanbul ignore else */\n    if (isArray(currGroupValue)) {\n      clonedResult[currKey] = [];\n    } else {\n      throw Error(\"non exhaustive match\");\n    }\n  });\n\n  return clonedResult;\n}\n\n// TODO: refactor to avoid duplication\nexport function isCustomPattern(tokenType: TokenType): boolean {\n  const pattern = tokenType.PATTERN;\n  /* istanbul ignore else */\n  if (isRegExp(pattern)) {\n    return false;\n  } else if (isFunction(pattern)) {\n    // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object\n    return true;\n  } else if (has(pattern, \"exec\")) {\n    // ICustomPattern\n    return true;\n  } else if (isString(pattern)) {\n    return false;\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\n\nexport function isShortPattern(pattern: any): number | false {\n  if (isString(pattern) && pattern.length === 1) {\n    return pattern.charCodeAt(0);\n  } else {\n    return false;\n  }\n}\n\n/**\n * Faster than using a RegExp for default newline detection during lexing.\n */\nexport const LineTerminatorOptimizedTester: ILineTerminatorsTester = {\n  // implements /\\n|\\r\\n?/g.test\n  test: function (text) {\n    const len = text.length;\n    for (let i = this.lastIndex; i < len; i++) {\n      const c = text.charCodeAt(i);\n      if (c === 10) {\n        this.lastIndex = i + 1;\n        return true;\n      } else if (c === 13) {\n        if (text.charCodeAt(i + 1) === 10) {\n          this.lastIndex = i + 2;\n        } else {\n          this.lastIndex = i + 1;\n        }\n        return true;\n      }\n    }\n    return false;\n  },\n\n  lastIndex: 0,\n};\n\nfunction checkLineBreaksIssues(\n  tokType: TokenType,\n  lineTerminatorCharCodes: number[],\n):\n  | {\n      issue:\n        | LexerDefinitionErrorType.IDENTIFY_TERMINATOR\n        | LexerDefinitionErrorType.CUSTOM_LINE_BREAK;\n      errMsg?: string;\n    }\n  | false {\n  if (has(tokType, \"LINE_BREAKS\")) {\n    // if the user explicitly declared the line_breaks option we will respect their choice\n    // and assume it is correct.\n    return false;\n  } else {\n    /* istanbul ignore else */\n    if (isRegExp(tokType.PATTERN)) {\n      try {\n        // TODO: why is the casting suddenly needed?\n        canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN as RegExp);\n      } catch (e) {\n        /* istanbul ignore next - to test this we would have to mock <canMatchCharCode> to throw an error */\n        return {\n          issue: LexerDefinitionErrorType.IDENTIFY_TERMINATOR,\n          errMsg: (e as Error).message,\n        };\n      }\n      return false;\n    } else if (isString(tokType.PATTERN)) {\n      // string literal patterns can always be analyzed to detect line terminator usage\n      return false;\n    } else if (isCustomPattern(tokType)) {\n      // custom token types\n      return { issue: LexerDefinitionErrorType.CUSTOM_LINE_BREAK };\n    } else {\n      throw Error(\"non exhaustive match\");\n    }\n  }\n}\n\nexport function buildLineBreakIssueMessage(\n  tokType: TokenType,\n  details: {\n    issue:\n      | LexerDefinitionErrorType.IDENTIFY_TERMINATOR\n      | LexerDefinitionErrorType.CUSTOM_LINE_BREAK;\n    errMsg?: string;\n  },\n): string {\n  /* istanbul ignore else */\n  if (details.issue === LexerDefinitionErrorType.IDENTIFY_TERMINATOR) {\n    return (\n      \"Warning: unable to identify line terminator usage in pattern.\\n\" +\n      `\\tThe problem is in the <${tokType.name}> Token Type\\n` +\n      `\\t Root cause: ${details.errMsg}.\\n` +\n      \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR\"\n    );\n  } else if (details.issue === LexerDefinitionErrorType.CUSTOM_LINE_BREAK) {\n    return (\n      \"Warning: A Custom Token Pattern should specify the <line_breaks> option.\\n\" +\n      `\\tThe problem is in the <${tokType.name}> Token Type\\n` +\n      \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK\"\n    );\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\n\nfunction getCharCodes(charsOrCodes: (number | string)[]): number[] {\n  const charCodes = map(charsOrCodes, (numOrString) => {\n    if (isString(numOrString)) {\n      return numOrString.charCodeAt(0);\n    } else {\n      return numOrString;\n    }\n  });\n\n  return charCodes;\n}\n\nfunction addToMapOfArrays<T>(\n  map: Record<number, T[]>,\n  key: number,\n  value: T,\n): void {\n  if (map[key] === undefined) {\n    map[key] = [value];\n  } else {\n    map[key].push(value);\n  }\n}\n\nexport const minOptimizationVal = 256;\n\n/**\n * We are mapping charCode above ASCI (256) into buckets each in the size of 256.\n * This is because ASCI are the most common start chars so each one of those will get its own\n * possible token configs vector.\n *\n * Tokens starting with charCodes \"above\" ASCI are uncommon, so we can \"afford\"\n * to place these into buckets of possible token configs, What we gain from\n * this is avoiding the case of creating an optimization 'charCodeToPatternIdxToConfig'\n * which would contain 10,000+ arrays of small size (e.g unicode Identifiers scenario).\n * Our 'charCodeToPatternIdxToConfig' max size will now be:\n * 256 + (2^16 / 2^8) - 1 === 511\n *\n * note the hack for fast division integer part extraction\n * See: https://stackoverflow.com/a/4228528\n */\nlet charCodeToOptimizedIdxMap: number[] = [];\nexport function charCodeToOptimizedIndex(charCode: number): number {\n  return charCode < minOptimizationVal\n    ? charCode\n    : charCodeToOptimizedIdxMap[charCode];\n}\n\n/**\n * This is a compromise between cold start / hot running performance\n * Creating this array takes ~3ms on a modern machine,\n * But if we perform the computation at runtime as needed the CSS Lexer benchmark\n * performance degrades by ~10%\n *\n * TODO: Perhaps it should be lazy initialized only if a charCode > 255 is used.\n */\nfunction initCharCodeToOptimizedIndexMap() {\n  if (isEmpty(charCodeToOptimizedIdxMap)) {\n    charCodeToOptimizedIdxMap = new Array(65536);\n    for (let i = 0; i < 65536; i++) {\n      charCodeToOptimizedIdxMap[i] = i > 255 ? 255 + ~~(i / 255) : i;\n    }\n  }\n}\n","import {\n  clone,\n  compact,\n  difference,\n  flatten,\n  forEach,\n  has,\n  includes,\n  isArray,\n  isEmpty,\n  map,\n} from \"lodash-es\";\nimport { IToken, TokenType } from \"@chevrotain/types\";\n\nexport function tokenStructuredMatcher(\n  tokInstance: IToken,\n  tokConstructor: TokenType,\n) {\n  const instanceType = tokInstance.tokenTypeIdx;\n  if (instanceType === tokConstructor.tokenTypeIdx) {\n    return true;\n  } else {\n    return (\n      tokConstructor.isParent === true &&\n      tokConstructor.categoryMatchesMap![instanceType] === true\n    );\n  }\n}\n\n// Optimized tokenMatcher in case our grammar does not use token categories\n// Being so tiny it is much more likely to be in-lined and this avoid the function call overhead\nexport function tokenStructuredMatcherNoCategories(\n  token: IToken,\n  tokType: TokenType,\n) {\n  return token.tokenTypeIdx === tokType.tokenTypeIdx;\n}\n\nexport let tokenShortNameIdx = 1;\nexport const tokenIdxToClass: { [tokenIdx: number]: TokenType } = {};\n\nexport function augmentTokenTypes(tokenTypes: TokenType[]): void {\n  // collect the parent Token Types as well.\n  const tokenTypesAndParents = expandCategories(tokenTypes);\n\n  // add required tokenType and categoryMatches properties\n  assignTokenDefaultProps(tokenTypesAndParents);\n\n  // fill up the categoryMatches\n  assignCategoriesMapProp(tokenTypesAndParents);\n  assignCategoriesTokensProp(tokenTypesAndParents);\n\n  forEach(tokenTypesAndParents, (tokType) => {\n    tokType.isParent = tokType.categoryMatches!.length > 0;\n  });\n}\n\nexport function expandCategories(tokenTypes: TokenType[]): TokenType[] {\n  let result = clone(tokenTypes);\n\n  let categories = tokenTypes;\n  let searching = true;\n  while (searching) {\n    categories = compact(\n      flatten(map(categories, (currTokType) => currTokType.CATEGORIES)),\n    );\n\n    const newCategories = difference(categories, result);\n\n    result = result.concat(newCategories);\n\n    if (isEmpty(newCategories)) {\n      searching = false;\n    } else {\n      categories = newCategories;\n    }\n  }\n  return result;\n}\n\nexport function assignTokenDefaultProps(tokenTypes: TokenType[]): void {\n  forEach(tokenTypes, (currTokType) => {\n    if (!hasShortKeyProperty(currTokType)) {\n      tokenIdxToClass[tokenShortNameIdx] = currTokType;\n      (<any>currTokType).tokenTypeIdx = tokenShortNameIdx++;\n    }\n\n    // CATEGORIES? : TokenType | TokenType[]\n    if (\n      hasCategoriesProperty(currTokType) &&\n      !isArray(currTokType.CATEGORIES)\n      // &&\n      // !isUndefined(currTokType.CATEGORIES.PATTERN)\n    ) {\n      currTokType.CATEGORIES = [currTokType.CATEGORIES as unknown as TokenType];\n    }\n\n    if (!hasCategoriesProperty(currTokType)) {\n      currTokType.CATEGORIES = [];\n    }\n\n    if (!hasExtendingTokensTypesProperty(currTokType)) {\n      currTokType.categoryMatches = [];\n    }\n\n    if (!hasExtendingTokensTypesMapProperty(currTokType)) {\n      currTokType.categoryMatchesMap = {};\n    }\n  });\n}\n\nexport function assignCategoriesTokensProp(tokenTypes: TokenType[]): void {\n  forEach(tokenTypes, (currTokType) => {\n    // avoid duplications\n    currTokType.categoryMatches = [];\n    forEach(currTokType.categoryMatchesMap!, (val, key) => {\n      currTokType.categoryMatches!.push(\n        tokenIdxToClass[key as unknown as number].tokenTypeIdx!,\n      );\n    });\n  });\n}\n\nexport function assignCategoriesMapProp(tokenTypes: TokenType[]): void {\n  forEach(tokenTypes, (currTokType) => {\n    singleAssignCategoriesToksMap([], currTokType);\n  });\n}\n\nexport function singleAssignCategoriesToksMap(\n  path: TokenType[],\n  nextNode: TokenType,\n): void {\n  forEach(path, (pathNode) => {\n    nextNode.categoryMatchesMap![pathNode.tokenTypeIdx!] = true;\n  });\n\n  forEach(nextNode.CATEGORIES, (nextCategory) => {\n    const newPath = path.concat(nextNode);\n    // avoids infinite loops due to cyclic categories.\n    if (!includes(newPath, nextCategory)) {\n      singleAssignCategoriesToksMap(newPath, nextCategory);\n    }\n  });\n}\n\nexport function hasShortKeyProperty(tokType: TokenType): boolean {\n  return has(tokType, \"tokenTypeIdx\");\n}\n\nexport function hasCategoriesProperty(tokType: TokenType): boolean {\n  return has(tokType, \"CATEGORIES\");\n}\n\nexport function hasExtendingTokensTypesProperty(tokType: TokenType): boolean {\n  return has(tokType, \"categoryMatches\");\n}\n\nexport function hasExtendingTokensTypesMapProperty(\n  tokType: TokenType,\n): boolean {\n  return has(tokType, \"categoryMatchesMap\");\n}\n\nexport function isTokenType(tokType: TokenType): boolean {\n  return has(tokType, \"tokenTypeIdx\");\n}\n","import { ILexerErrorMessageProvider, IToken } from \"@chevrotain/types\";\n\nexport const defaultLexerErrorProvider: ILexerErrorMessageProvider = {\n  buildUnableToPopLexerModeMessage(token: IToken): string {\n    return `Unable to pop Lexer Mode after encountering Token ->${token.image}<- The Mode Stack is empty`;\n  },\n\n  buildUnexpectedCharactersMessage(\n    fullText: string,\n    startOffset: number,\n    length: number,\n    line?: number,\n    column?: number,\n  ): string {\n    return (\n      `unexpected character: ->${fullText.charAt(\n        startOffset,\n      )}<- at offset: ${startOffset},` + ` skipped ${length} characters.`\n    );\n  },\n};\n","import {\n  analyzeTokenTypes,\n  charCodeToOptimizedIndex,\n  cloneEmptyGroups,\n  DEFAULT_MODE,\n  IAnalyzeResult,\n  IPatternConfig,\n  LineTerminatorOptimizedTester,\n  performRuntimeChecks,\n  performWarningRuntimeChecks,\n  SUPPORT_STICKY,\n  validatePatterns,\n} from \"./lexer.js\";\nimport {\n  assign,\n  clone,\n  forEach,\n  identity,\n  isArray,\n  isEmpty,\n  isUndefined,\n  keys,\n  last,\n  map,\n  noop,\n  reduce,\n  reject,\n} from \"lodash-es\";\nimport { PRINT_WARNING, timer, toFastProperties } from \"@chevrotain/utils\";\nimport { augmentTokenTypes } from \"./tokens.js\";\nimport {\n  CustomPatternMatcherFunc,\n  CustomPatternMatcherReturn,\n  ILexerConfig,\n  ILexerDefinitionError,\n  ILexingError,\n  IMultiModeLexerDefinition,\n  IToken,\n  TokenType,\n} from \"@chevrotain/types\";\nimport { defaultLexerErrorProvider } from \"./lexer_errors_public.js\";\nimport { clearRegExpParserCache } from \"./reg_exp_parser.js\";\n\nexport interface ILexingResult {\n  tokens: IToken[];\n  groups: { [groupName: string]: IToken[] };\n  errors: ILexingError[];\n}\n\nexport enum LexerDefinitionErrorType {\n  MISSING_PATTERN,\n  INVALID_PATTERN,\n  EOI_ANCHOR_FOUND,\n  UNSUPPORTED_FLAGS_FOUND,\n  DUPLICATE_PATTERNS_FOUND,\n  INVALID_GROUP_TYPE_FOUND,\n  PUSH_MODE_DOES_NOT_EXIST,\n  MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE,\n  MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY,\n  MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST,\n  LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED,\n  SOI_ANCHOR_FOUND,\n  EMPTY_MATCH_PATTERN,\n  NO_LINE_BREAKS_FLAGS,\n  UNREACHABLE_PATTERN,\n  IDENTIFY_TERMINATOR,\n  CUSTOM_LINE_BREAK,\n  MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE,\n}\n\nexport interface IRegExpExec {\n  exec: CustomPatternMatcherFunc;\n}\n\nconst DEFAULT_LEXER_CONFIG: Required<ILexerConfig> = {\n  deferDefinitionErrorsHandling: false,\n  positionTracking: \"full\",\n  lineTerminatorsPattern: /\\n|\\r\\n?/g,\n  lineTerminatorCharacters: [\"\\n\", \"\\r\"],\n  ensureOptimizations: false,\n  safeMode: false,\n  errorMessageProvider: defaultLexerErrorProvider,\n  traceInitPerf: false,\n  skipValidations: false,\n  recoveryEnabled: true,\n};\n\nObject.freeze(DEFAULT_LEXER_CONFIG);\n\nexport class Lexer {\n  public static SKIPPED =\n    \"This marks a skipped Token pattern, this means each token identified by it will\" +\n    \"be consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.\";\n\n  public static NA = /NOT_APPLICABLE/;\n  public lexerDefinitionErrors: ILexerDefinitionError[] = [];\n  public lexerDefinitionWarning: ILexerDefinitionError[] = [];\n\n  protected patternIdxToConfig: Record<string, IPatternConfig[]> = {};\n  protected charCodeToPatternIdxToConfig: {\n    [modeName: string]: { [charCode: number]: IPatternConfig[] };\n  } = {};\n\n  protected modes: string[] = [];\n  protected defaultMode!: string;\n  protected emptyGroups: { [groupName: string]: IToken } = {};\n\n  private config: Required<ILexerConfig>;\n  private trackStartLines: boolean = true;\n  private trackEndLines: boolean = true;\n  private hasCustom: boolean = false;\n  private canModeBeOptimized: Record<string, boolean> = {};\n\n  private traceInitPerf!: boolean | number;\n  private traceInitMaxIdent!: number;\n  private traceInitIndent: number;\n\n  constructor(\n    protected lexerDefinition: TokenType[] | IMultiModeLexerDefinition,\n    config: ILexerConfig = DEFAULT_LEXER_CONFIG,\n  ) {\n    if (typeof config === \"boolean\") {\n      throw Error(\n        \"The second argument to the Lexer constructor is now an ILexerConfig Object.\\n\" +\n          \"a boolean 2nd argument is no longer supported\",\n      );\n    }\n\n    // todo: defaults func?\n    this.config = assign({}, DEFAULT_LEXER_CONFIG, config) as any;\n\n    const traceInitVal = this.config.traceInitPerf;\n    if (traceInitVal === true) {\n      this.traceInitMaxIdent = Infinity;\n      this.traceInitPerf = true;\n    } else if (typeof traceInitVal === \"number\") {\n      this.traceInitMaxIdent = traceInitVal;\n      this.traceInitPerf = true;\n    }\n    this.traceInitIndent = -1;\n\n    this.TRACE_INIT(\"Lexer Constructor\", () => {\n      let actualDefinition!: IMultiModeLexerDefinition;\n      let hasOnlySingleMode = true;\n      this.TRACE_INIT(\"Lexer Config handling\", () => {\n        if (\n          this.config.lineTerminatorsPattern ===\n          DEFAULT_LEXER_CONFIG.lineTerminatorsPattern\n        ) {\n          // optimized built-in implementation for the defaults definition of lineTerminators\n          this.config.lineTerminatorsPattern = LineTerminatorOptimizedTester;\n        } else {\n          if (\n            this.config.lineTerminatorCharacters ===\n            DEFAULT_LEXER_CONFIG.lineTerminatorCharacters\n          ) {\n            throw Error(\n              \"Error: Missing <lineTerminatorCharacters> property on the Lexer config.\\n\" +\n                \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS\",\n            );\n          }\n        }\n\n        if (config.safeMode && config.ensureOptimizations) {\n          throw Error(\n            '\"safeMode\" and \"ensureOptimizations\" flags are mutually exclusive.',\n          );\n        }\n\n        this.trackStartLines = /full|onlyStart/i.test(\n          this.config.positionTracking,\n        );\n        this.trackEndLines = /full/i.test(this.config.positionTracking);\n\n        // Convert SingleModeLexerDefinition into a IMultiModeLexerDefinition.\n        if (isArray(lexerDefinition)) {\n          actualDefinition = {\n            modes: { defaultMode: clone(lexerDefinition) },\n            defaultMode: DEFAULT_MODE,\n          };\n        } else {\n          // no conversion needed, input should already be a IMultiModeLexerDefinition\n          hasOnlySingleMode = false;\n          actualDefinition = clone(<IMultiModeLexerDefinition>lexerDefinition);\n        }\n      });\n\n      if (this.config.skipValidations === false) {\n        this.TRACE_INIT(\"performRuntimeChecks\", () => {\n          this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(\n            performRuntimeChecks(\n              actualDefinition,\n              this.trackStartLines,\n              this.config.lineTerminatorCharacters,\n            ),\n          );\n        });\n\n        this.TRACE_INIT(\"performWarningRuntimeChecks\", () => {\n          this.lexerDefinitionWarning = this.lexerDefinitionWarning.concat(\n            performWarningRuntimeChecks(\n              actualDefinition,\n              this.trackStartLines,\n              this.config.lineTerminatorCharacters,\n            ),\n          );\n        });\n      }\n\n      // for extra robustness to avoid throwing an none informative error message\n      actualDefinition.modes = actualDefinition.modes\n        ? actualDefinition.modes\n        : {};\n\n      // an error of undefined TokenTypes will be detected in \"performRuntimeChecks\" above.\n      // this transformation is to increase robustness in the case of partially invalid lexer definition.\n      forEach(actualDefinition.modes, (currModeValue, currModeName) => {\n        actualDefinition.modes[currModeName] = reject<TokenType>(\n          currModeValue,\n          (currTokType) => isUndefined(currTokType),\n        );\n      });\n\n      const allModeNames = keys(actualDefinition.modes);\n\n      forEach(\n        actualDefinition.modes,\n        (currModDef: TokenType[], currModName) => {\n          this.TRACE_INIT(`Mode: <${currModName}> processing`, () => {\n            this.modes.push(currModName);\n\n            if (this.config.skipValidations === false) {\n              this.TRACE_INIT(`validatePatterns`, () => {\n                this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(\n                  validatePatterns(currModDef, allModeNames),\n                );\n              });\n            }\n\n            // If definition errors were encountered, the analysis phase may fail unexpectedly/\n            // Considering a lexer with definition errors may never be used, there is no point\n            // to performing the analysis anyhow...\n            if (isEmpty(this.lexerDefinitionErrors)) {\n              augmentTokenTypes(currModDef);\n\n              let currAnalyzeResult!: IAnalyzeResult;\n              this.TRACE_INIT(`analyzeTokenTypes`, () => {\n                currAnalyzeResult = analyzeTokenTypes(currModDef, {\n                  lineTerminatorCharacters:\n                    this.config.lineTerminatorCharacters,\n                  positionTracking: config.positionTracking,\n                  ensureOptimizations: config.ensureOptimizations,\n                  safeMode: config.safeMode,\n                  tracer: this.TRACE_INIT,\n                });\n              });\n\n              this.patternIdxToConfig[currModName] =\n                currAnalyzeResult.patternIdxToConfig;\n\n              this.charCodeToPatternIdxToConfig[currModName] =\n                currAnalyzeResult.charCodeToPatternIdxToConfig;\n\n              this.emptyGroups = assign(\n                {},\n                this.emptyGroups,\n                currAnalyzeResult.emptyGroups,\n              ) as any;\n\n              this.hasCustom = currAnalyzeResult.hasCustom || this.hasCustom;\n\n              this.canModeBeOptimized[currModName] =\n                currAnalyzeResult.canBeOptimized;\n            }\n          });\n        },\n      );\n\n      this.defaultMode = actualDefinition.defaultMode;\n\n      if (\n        !isEmpty(this.lexerDefinitionErrors) &&\n        !this.config.deferDefinitionErrorsHandling\n      ) {\n        const allErrMessages = map(this.lexerDefinitionErrors, (error) => {\n          return error.message;\n        });\n        const allErrMessagesString = allErrMessages.join(\n          \"-----------------------\\n\",\n        );\n        throw new Error(\n          \"Errors detected in definition of Lexer:\\n\" + allErrMessagesString,\n        );\n      }\n\n      // Only print warning if there are no errors, This will avoid pl\n      forEach(this.lexerDefinitionWarning, (warningDescriptor) => {\n        PRINT_WARNING(warningDescriptor.message);\n      });\n\n      this.TRACE_INIT(\"Choosing sub-methods implementations\", () => {\n        // Choose the relevant internal implementations for this specific parser.\n        // These implementations should be in-lined by the JavaScript engine\n        // to provide optimal performance in each scenario.\n        if (SUPPORT_STICKY) {\n          this.chopInput = <any>identity;\n          this.match = this.matchWithTest;\n        } else {\n          this.updateLastIndex = noop;\n          this.match = this.matchWithExec;\n        }\n\n        if (hasOnlySingleMode) {\n          this.handleModes = noop;\n        }\n\n        if (this.trackStartLines === false) {\n          this.computeNewColumn = identity;\n        }\n\n        if (this.trackEndLines === false) {\n          this.updateTokenEndLineColumnLocation = noop;\n        }\n\n        if (/full/i.test(this.config.positionTracking)) {\n          this.createTokenInstance = this.createFullToken;\n        } else if (/onlyStart/i.test(this.config.positionTracking)) {\n          this.createTokenInstance = this.createStartOnlyToken;\n        } else if (/onlyOffset/i.test(this.config.positionTracking)) {\n          this.createTokenInstance = this.createOffsetOnlyToken;\n        } else {\n          throw Error(\n            `Invalid <positionTracking> config option: \"${this.config.positionTracking}\"`,\n          );\n        }\n\n        if (this.hasCustom) {\n          this.addToken = this.addTokenUsingPush;\n          this.handlePayload = this.handlePayloadWithCustom;\n        } else {\n          this.addToken = this.addTokenUsingMemberAccess;\n          this.handlePayload = this.handlePayloadNoCustom;\n        }\n      });\n\n      this.TRACE_INIT(\"Failed Optimization Warnings\", () => {\n        const unOptimizedModes = reduce(\n          this.canModeBeOptimized,\n          (cannotBeOptimized, canBeOptimized, modeName) => {\n            if (canBeOptimized === false) {\n              cannotBeOptimized.push(modeName);\n            }\n            return cannotBeOptimized;\n          },\n          [] as string[],\n        );\n\n        if (config.ensureOptimizations && !isEmpty(unOptimizedModes)) {\n          throw Error(\n            `Lexer Modes: < ${unOptimizedModes.join(\n              \", \",\n            )} > cannot be optimized.\\n` +\n              '\\t Disable the \"ensureOptimizations\" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\\n' +\n              \"\\t Or inspect the console log for details on how to resolve these issues.\",\n          );\n        }\n      });\n\n      this.TRACE_INIT(\"clearRegExpParserCache\", () => {\n        clearRegExpParserCache();\n      });\n\n      this.TRACE_INIT(\"toFastProperties\", () => {\n        toFastProperties(this);\n      });\n    });\n  }\n\n  public tokenize(\n    text: string,\n    initialMode: string = this.defaultMode,\n  ): ILexingResult {\n    if (!isEmpty(this.lexerDefinitionErrors)) {\n      const allErrMessages = map(this.lexerDefinitionErrors, (error) => {\n        return error.message;\n      });\n      const allErrMessagesString = allErrMessages.join(\n        \"-----------------------\\n\",\n      );\n      throw new Error(\n        \"Unable to Tokenize because Errors detected in definition of Lexer:\\n\" +\n          allErrMessagesString,\n      );\n    }\n\n    return this.tokenizeInternal(text, initialMode);\n  }\n\n  // There is quite a bit of duplication between this and \"tokenizeInternalLazy\"\n  // This is intentional due to performance considerations.\n  // this method also used quite a bit of `!` none null assertions because it is too optimized\n  // for `tsc` to always understand it is \"safe\"\n  private tokenizeInternal(text: string, initialMode: string): ILexingResult {\n    let i,\n      j,\n      k,\n      matchAltImage,\n      longerAlt,\n      matchedImage: string | null,\n      payload,\n      altPayload,\n      imageLength,\n      group,\n      tokType,\n      newToken: IToken,\n      errLength,\n      droppedChar,\n      msg,\n      match;\n    const orgText = text;\n    const orgLength = orgText.length;\n    let offset = 0;\n    let matchedTokensIndex = 0;\n    // initializing the tokensArray to the \"guessed\" size.\n    // guessing too little will still reduce the number of array re-sizes on pushes.\n    // guessing too large (Tested by guessing x4 too large) may cost a bit more of memory\n    // but would still have a faster runtime by avoiding (All but one) array resizing.\n    const guessedNumberOfTokens = this.hasCustom\n      ? 0 // will break custom token pattern APIs the matchedTokens array will contain undefined elements.\n      : Math.floor(text.length / 10);\n    const matchedTokens = new Array(guessedNumberOfTokens);\n    const errors: ILexingError[] = [];\n    let line = this.trackStartLines ? 1 : undefined;\n    let column = this.trackStartLines ? 1 : undefined;\n    const groups: any = cloneEmptyGroups(this.emptyGroups);\n    const trackLines = this.trackStartLines;\n    const lineTerminatorPattern = this.config.lineTerminatorsPattern;\n\n    let currModePatternsLength = 0;\n    let patternIdxToConfig: IPatternConfig[] = [];\n    let currCharCodeToPatternIdxToConfig: {\n      [charCode: number]: IPatternConfig[];\n    } = [];\n\n    const modeStack: string[] = [];\n\n    const emptyArray: IPatternConfig[] = [];\n    Object.freeze(emptyArray);\n    let getPossiblePatterns!: (charCode: number) => IPatternConfig[];\n\n    function getPossiblePatternsSlow() {\n      return patternIdxToConfig;\n    }\n\n    function getPossiblePatternsOptimized(charCode: number): IPatternConfig[] {\n      const optimizedCharIdx = charCodeToOptimizedIndex(charCode);\n      const possiblePatterns =\n        currCharCodeToPatternIdxToConfig[optimizedCharIdx];\n      if (possiblePatterns === undefined) {\n        return emptyArray;\n      } else {\n        return possiblePatterns;\n      }\n    }\n\n    const pop_mode = (popToken: IToken) => {\n      // TODO: perhaps avoid this error in the edge case there is no more input?\n      if (\n        modeStack.length === 1 &&\n        // if we have both a POP_MODE and a PUSH_MODE this is in-fact a \"transition\"\n        // So no error should occur.\n        popToken.tokenType.PUSH_MODE === undefined\n      ) {\n        // if we try to pop the last mode there lexer will no longer have ANY mode.\n        // thus the pop is ignored, an error will be created and the lexer will continue parsing in the previous mode.\n        const msg =\n          this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(\n            popToken,\n          );\n\n        errors.push({\n          offset: popToken.startOffset,\n          line: popToken.startLine,\n          column: popToken.startColumn,\n          length: popToken.image.length,\n          message: msg,\n        });\n      } else {\n        modeStack.pop();\n        const newMode = last(modeStack)!;\n        patternIdxToConfig = this.patternIdxToConfig[newMode];\n        currCharCodeToPatternIdxToConfig =\n          this.charCodeToPatternIdxToConfig[newMode];\n        currModePatternsLength = patternIdxToConfig.length;\n        const modeCanBeOptimized =\n          this.canModeBeOptimized[newMode] && this.config.safeMode === false;\n\n        if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n          getPossiblePatterns = getPossiblePatternsOptimized;\n        } else {\n          getPossiblePatterns = getPossiblePatternsSlow;\n        }\n      }\n    };\n\n    function push_mode(this: Lexer, newMode: string) {\n      modeStack.push(newMode);\n      currCharCodeToPatternIdxToConfig =\n        this.charCodeToPatternIdxToConfig[newMode];\n\n      patternIdxToConfig = this.patternIdxToConfig[newMode];\n      currModePatternsLength = patternIdxToConfig.length;\n\n      currModePatternsLength = patternIdxToConfig.length;\n      const modeCanBeOptimized =\n        this.canModeBeOptimized[newMode] && this.config.safeMode === false;\n\n      if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n        getPossiblePatterns = getPossiblePatternsOptimized;\n      } else {\n        getPossiblePatterns = getPossiblePatternsSlow;\n      }\n    }\n\n    // this pattern seems to avoid a V8 de-optimization, although that de-optimization does not\n    // seem to matter performance wise.\n    push_mode.call(this, initialMode);\n\n    let currConfig!: IPatternConfig;\n\n    const recoveryEnabled = this.config.recoveryEnabled;\n\n    while (offset < orgLength) {\n      matchedImage = null;\n\n      const nextCharCode = orgText.charCodeAt(offset);\n      const chosenPatternIdxToConfig = getPossiblePatterns(nextCharCode);\n      const chosenPatternsLength = chosenPatternIdxToConfig.length;\n\n      for (i = 0; i < chosenPatternsLength; i++) {\n        currConfig = chosenPatternIdxToConfig[i];\n        const currPattern = currConfig.pattern;\n        payload = null;\n\n        // manually in-lined because > 600 chars won't be in-lined in V8\n        const singleCharCode = currConfig.short;\n        if (singleCharCode !== false) {\n          if (nextCharCode === singleCharCode) {\n            // single character string\n            matchedImage = currPattern as string;\n          }\n        } else if (currConfig.isCustom === true) {\n          match = (currPattern as IRegExpExec).exec(\n            orgText,\n            offset,\n            matchedTokens,\n            groups,\n          );\n          if (match !== null) {\n            matchedImage = match[0];\n            if ((match as CustomPatternMatcherReturn).payload !== undefined) {\n              payload = (match as CustomPatternMatcherReturn).payload;\n            }\n          } else {\n            matchedImage = null;\n          }\n        } else {\n          this.updateLastIndex(currPattern as RegExp, offset);\n          matchedImage = this.match(currPattern as RegExp, text, offset);\n        }\n\n        if (matchedImage !== null) {\n          // even though this pattern matched we must try a another longer alternative.\n          // this can be used to prioritize keywords over identifiers\n          longerAlt = currConfig.longerAlt;\n          if (longerAlt !== undefined) {\n            // TODO: micro optimize, avoid extra prop access\n            // by saving/linking longerAlt on the original config?\n            const longerAltLength = longerAlt.length;\n            for (k = 0; k < longerAltLength; k++) {\n              const longerAltConfig = patternIdxToConfig[longerAlt[k]];\n              const longerAltPattern = longerAltConfig.pattern;\n              altPayload = null;\n\n              // single Char can never be a longer alt so no need to test it.\n              // manually in-lined because > 600 chars won't be in-lined in V8\n              if (longerAltConfig.isCustom === true) {\n                match = (longerAltPattern as IRegExpExec).exec(\n                  orgText,\n                  offset,\n                  matchedTokens,\n                  groups,\n                );\n                if (match !== null) {\n                  matchAltImage = match[0];\n                  if (\n                    (match as CustomPatternMatcherReturn).payload !== undefined\n                  ) {\n                    altPayload = (match as CustomPatternMatcherReturn).payload;\n                  }\n                } else {\n                  matchAltImage = null;\n                }\n              } else {\n                this.updateLastIndex(longerAltPattern as RegExp, offset);\n                matchAltImage = this.match(\n                  longerAltPattern as RegExp,\n                  text,\n                  offset,\n                );\n              }\n\n              if (matchAltImage && matchAltImage.length > matchedImage.length) {\n                matchedImage = matchAltImage;\n                payload = altPayload;\n                currConfig = longerAltConfig;\n                // Exit the loop early after matching one of the longer alternatives\n                // The first matched alternative takes precedence\n                break;\n              }\n            }\n          }\n          break;\n        }\n      }\n\n      // successful match\n      if (matchedImage !== null) {\n        imageLength = matchedImage.length;\n        group = currConfig.group;\n        if (group !== undefined) {\n          tokType = currConfig.tokenTypeIdx;\n          // TODO: \"offset + imageLength\" and the new column may be computed twice in case of \"full\" location information inside\n          // createFullToken method\n          newToken = this.createTokenInstance(\n            matchedImage,\n            offset,\n            tokType,\n            currConfig.tokenType,\n            line,\n            column,\n            imageLength,\n          );\n\n          this.handlePayload(newToken, payload);\n\n          // TODO: optimize NOOP in case there are no special groups?\n          if (group === false) {\n            matchedTokensIndex = this.addToken(\n              matchedTokens,\n              matchedTokensIndex,\n              newToken,\n            );\n          } else {\n            groups[group].push(newToken);\n          }\n        }\n        text = this.chopInput(text, imageLength);\n        offset = offset + imageLength;\n\n        // TODO: with newlines the column may be assigned twice\n        column = this.computeNewColumn(column!, imageLength);\n\n        if (trackLines === true && currConfig.canLineTerminator === true) {\n          let numOfLTsInMatch = 0;\n          let foundTerminator;\n          let lastLTEndOffset: number;\n          lineTerminatorPattern.lastIndex = 0;\n          do {\n            foundTerminator = lineTerminatorPattern.test(matchedImage);\n            if (foundTerminator === true) {\n              lastLTEndOffset = lineTerminatorPattern.lastIndex - 1;\n              numOfLTsInMatch++;\n            }\n          } while (foundTerminator === true);\n\n          if (numOfLTsInMatch !== 0) {\n            line = line! + numOfLTsInMatch;\n            column = imageLength - lastLTEndOffset!;\n            this.updateTokenEndLineColumnLocation(\n              newToken!,\n              group!,\n              lastLTEndOffset!,\n              numOfLTsInMatch,\n              line,\n              column,\n              imageLength,\n            );\n          }\n        }\n        // will be NOOP if no modes present\n        this.handleModes(currConfig, pop_mode, push_mode, newToken!);\n      } else {\n        // error recovery, drop characters until we identify a valid token's start point\n        const errorStartOffset = offset;\n        const errorLine = line;\n        const errorColumn = column;\n        let foundResyncPoint = recoveryEnabled === false;\n\n        while (foundResyncPoint === false && offset < orgLength) {\n          // Identity Func (when sticky flag is enabled)\n          text = this.chopInput(text, 1);\n          offset++;\n          for (j = 0; j < currModePatternsLength; j++) {\n            const currConfig = patternIdxToConfig[j];\n            const currPattern = currConfig.pattern;\n\n            // manually in-lined because > 600 chars won't be in-lined in V8\n            const singleCharCode = currConfig.short;\n            if (singleCharCode !== false) {\n              if (orgText.charCodeAt(offset) === singleCharCode) {\n                // single character string\n                foundResyncPoint = true;\n              }\n            } else if (currConfig.isCustom === true) {\n              foundResyncPoint =\n                (currPattern as IRegExpExec).exec(\n                  orgText,\n                  offset,\n                  matchedTokens,\n                  groups,\n                ) !== null;\n            } else {\n              this.updateLastIndex(currPattern as RegExp, offset);\n              foundResyncPoint = (currPattern as RegExp).exec(text) !== null;\n            }\n\n            if (foundResyncPoint === true) {\n              break;\n            }\n          }\n        }\n\n        errLength = offset - errorStartOffset;\n        column = this.computeNewColumn(column!, errLength);\n        // at this point we either re-synced or reached the end of the input text\n        msg = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(\n          orgText,\n          errorStartOffset,\n          errLength,\n          errorLine,\n          errorColumn,\n        );\n        errors.push({\n          offset: errorStartOffset,\n          line: errorLine,\n          column: errorColumn,\n          length: errLength,\n          message: msg,\n        });\n\n        if (recoveryEnabled === false) {\n          break;\n        }\n      }\n    }\n\n    // if we do have custom patterns which push directly into the\n    // TODO: custom tokens should not push directly??\n    if (!this.hasCustom) {\n      // if we guessed a too large size for the tokens array this will shrink it to the right size.\n      matchedTokens.length = matchedTokensIndex;\n    }\n\n    return {\n      tokens: matchedTokens,\n      groups: groups,\n      errors: errors,\n    };\n  }\n\n  private handleModes(\n    config: IPatternConfig,\n    pop_mode: (tok: IToken) => void,\n    push_mode: (this: Lexer, pushMode: string) => void,\n    newToken: IToken,\n  ) {\n    if (config.pop === true) {\n      // need to save the PUSH_MODE property as if the mode is popped\n      // patternIdxToPopMode is updated to reflect the new mode after popping the stack\n      const pushMode = config.push;\n      pop_mode(newToken);\n      if (pushMode !== undefined) {\n        push_mode.call(this, pushMode);\n      }\n    } else if (config.push !== undefined) {\n      push_mode.call(this, config.push);\n    }\n  }\n\n  private chopInput(text: string, length: number): string {\n    return text.substring(length);\n  }\n\n  private updateLastIndex(regExp: RegExp, newLastIndex: number): void {\n    regExp.lastIndex = newLastIndex;\n  }\n\n  // TODO: decrease this under 600 characters? inspect stripping comments option in TSC compiler\n  private updateTokenEndLineColumnLocation(\n    newToken: IToken,\n    group: string | false,\n    lastLTIdx: number,\n    numOfLTsInMatch: number,\n    line: number,\n    column: number,\n    imageLength: number,\n  ): void {\n    let lastCharIsLT, fixForEndingInLT;\n    if (group !== undefined) {\n      // a none skipped multi line Token, need to update endLine/endColumn\n      lastCharIsLT = lastLTIdx === imageLength - 1;\n      fixForEndingInLT = lastCharIsLT ? -1 : 0;\n      if (!(numOfLTsInMatch === 1 && lastCharIsLT === true)) {\n        // if a token ends in a LT that last LT only affects the line numbering of following Tokens\n        newToken.endLine = line + fixForEndingInLT;\n        // the last LT in a token does not affect the endColumn either as the [columnStart ... columnEnd)\n        // inclusive to exclusive range.\n        newToken.endColumn = column - 1 + -fixForEndingInLT;\n      }\n      // else single LT in the last character of a token, no need to modify the endLine/EndColumn\n    }\n  }\n\n  private computeNewColumn(oldColumn: number, imageLength: number) {\n    return oldColumn + imageLength;\n  }\n\n  // Place holder, will be replaced by the correct variant according to the locationTracking option at runtime.\n  /* istanbul ignore next - place holder */\n  private createTokenInstance!: (...args: any[]) => IToken;\n\n  private createOffsetOnlyToken(\n    image: string,\n    startOffset: number,\n    tokenTypeIdx: number,\n    tokenType: TokenType,\n  ) {\n    return {\n      image,\n      startOffset,\n      tokenTypeIdx,\n      tokenType,\n    };\n  }\n\n  private createStartOnlyToken(\n    image: string,\n    startOffset: number,\n    tokenTypeIdx: number,\n    tokenType: TokenType,\n    startLine: number,\n    startColumn: number,\n  ) {\n    return {\n      image,\n      startOffset,\n      startLine,\n      startColumn,\n      tokenTypeIdx,\n      tokenType,\n    };\n  }\n\n  private createFullToken(\n    image: string,\n    startOffset: number,\n    tokenTypeIdx: number,\n    tokenType: TokenType,\n    startLine: number,\n    startColumn: number,\n    imageLength: number,\n  ): IToken {\n    return {\n      image,\n      startOffset,\n      endOffset: startOffset + imageLength - 1,\n      startLine,\n      endLine: startLine,\n      startColumn,\n      endColumn: startColumn + imageLength - 1,\n      tokenTypeIdx,\n      tokenType,\n    };\n  }\n\n  // Place holder, will be replaced by the correct variant according to the locationTracking option at runtime.\n  /* istanbul ignore next - place holder */\n  private addToken!: (\n    tokenVector: IToken[],\n    index: number,\n    tokenToAdd: IToken,\n  ) => number;\n\n  private addTokenUsingPush(\n    tokenVector: IToken[],\n    index: number,\n    tokenToAdd: IToken,\n  ): number {\n    tokenVector.push(tokenToAdd);\n    return index;\n  }\n\n  private addTokenUsingMemberAccess(\n    tokenVector: IToken[],\n    index: number,\n    tokenToAdd: IToken,\n  ): number {\n    tokenVector[index] = tokenToAdd;\n    index++;\n    return index;\n  }\n\n  // Place holder, will be replaced by the correct variant according to the hasCustom flag option at runtime.\n  private handlePayload: (token: IToken, payload: any) => void;\n\n  private handlePayloadNoCustom(token: IToken, payload: any): void {}\n\n  private handlePayloadWithCustom(token: IToken, payload: any): void {\n    if (payload !== null) {\n      token.payload = payload;\n    }\n  }\n\n  // place holder to be replaced with chosen alternative at runtime\n  private match!: (\n    pattern: RegExp,\n    text: string,\n    offset: number,\n  ) => string | null;\n\n  private matchWithTest(\n    pattern: RegExp,\n    text: string,\n    offset: number,\n  ): string | null {\n    const found = pattern.test(text);\n    if (found === true) {\n      return text.substring(offset, pattern.lastIndex);\n    }\n    return null;\n  }\n\n  private matchWithExec(pattern: RegExp, text: string): string | null {\n    const regExpArray = pattern.exec(text);\n    return regExpArray !== null ? regExpArray[0] : null;\n  }\n\n  // Duplicated from the parser's perf trace trait to allow future extraction\n  // of the lexer to a separate package.\n  TRACE_INIT = <T>(phaseDesc: string, phaseImpl: () => T): T => {\n    // No need to optimize this using NOOP pattern because\n    // It is not called in a hot spot...\n    if (this.traceInitPerf === true) {\n      this.traceInitIndent++;\n      const indent = new Array(this.traceInitIndent + 1).join(\"\\t\");\n      if (this.traceInitIndent < this.traceInitMaxIdent) {\n        console.log(`${indent}--> <${phaseDesc}>`);\n      }\n      const { time, value } = timer(phaseImpl);\n      /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */\n      const traceMethod = time > 10 ? console.warn : console.log;\n      if (this.traceInitIndent < this.traceInitMaxIdent) {\n        traceMethod(`${indent}<-- <${phaseDesc}> time: ${time}ms`);\n      }\n      this.traceInitIndent--;\n      return value;\n    } else {\n      return phaseImpl();\n    }\n  };\n}\n","import { has, isString, isUndefined } from \"lodash-es\";\nimport { Lexer } from \"./lexer_public.js\";\nimport { augmentTokenTypes, tokenStructuredMatcher } from \"./tokens.js\";\nimport { IToken, ITokenConfig, TokenType } from \"@chevrotain/types\";\n\nexport function tokenLabel(tokType: TokenType): string {\n  if (hasTokenLabel(tokType)) {\n    return tokType.LABEL;\n  } else {\n    return tokType.name;\n  }\n}\n\nexport function tokenName(tokType: TokenType): string {\n  return tokType.name;\n}\n\nexport function hasTokenLabel(\n  obj: TokenType,\n): obj is TokenType & Pick<Required<TokenType>, \"LABEL\"> {\n  return isString(obj.LABEL) && obj.LABEL !== \"\";\n}\n\nconst PARENT = \"parent\";\nconst CATEGORIES = \"categories\";\nconst LABEL = \"label\";\nconst GROUP = \"group\";\nconst PUSH_MODE = \"push_mode\";\nconst POP_MODE = \"pop_mode\";\nconst LONGER_ALT = \"longer_alt\";\nconst LINE_BREAKS = \"line_breaks\";\nconst START_CHARS_HINT = \"start_chars_hint\";\n\nexport function createToken(config: ITokenConfig): TokenType {\n  return createTokenInternal(config);\n}\n\nfunction createTokenInternal(config: ITokenConfig): TokenType {\n  const pattern = config.pattern;\n\n  const tokenType: TokenType = <any>{};\n  tokenType.name = config.name;\n\n  if (!isUndefined(pattern)) {\n    tokenType.PATTERN = pattern;\n  }\n\n  if (has(config, PARENT)) {\n    throw (\n      \"The parent property is no longer supported.\\n\" +\n      \"See: https://github.com/chevrotain/chevrotain/issues/564#issuecomment-349062346 for details.\"\n    );\n  }\n\n  if (has(config, CATEGORIES)) {\n    // casting to ANY as this will be fixed inside `augmentTokenTypes``\n    tokenType.CATEGORIES = <any>config[CATEGORIES];\n  }\n\n  augmentTokenTypes([tokenType]);\n\n  if (has(config, LABEL)) {\n    tokenType.LABEL = config[LABEL];\n  }\n\n  if (has(config, GROUP)) {\n    tokenType.GROUP = config[GROUP];\n  }\n\n  if (has(config, POP_MODE)) {\n    tokenType.POP_MODE = config[POP_MODE];\n  }\n\n  if (has(config, PUSH_MODE)) {\n    tokenType.PUSH_MODE = config[PUSH_MODE];\n  }\n\n  if (has(config, LONGER_ALT)) {\n    tokenType.LONGER_ALT = config[LONGER_ALT];\n  }\n\n  if (has(config, LINE_BREAKS)) {\n    tokenType.LINE_BREAKS = config[LINE_BREAKS];\n  }\n\n  if (has(config, START_CHARS_HINT)) {\n    tokenType.START_CHARS_HINT = config[START_CHARS_HINT];\n  }\n\n  return tokenType;\n}\n\nexport const EOF = createToken({ name: \"EOF\", pattern: Lexer.NA });\naugmentTokenTypes([EOF]);\n\nexport function createTokenInstance(\n  tokType: TokenType,\n  image: string,\n  startOffset: number,\n  endOffset: number,\n  startLine: number,\n  endLine: number,\n  startColumn: number,\n  endColumn: number,\n): IToken {\n  return {\n    image,\n    startOffset,\n    endOffset,\n    startLine,\n    endLine,\n    startColumn,\n    endColumn,\n    tokenTypeIdx: (<any>tokType).tokenTypeIdx,\n    tokenType: tokType,\n  };\n}\n\nexport function tokenMatcher(token: IToken, tokType: TokenType): boolean {\n  return tokenStructuredMatcher(token, tokType);\n}\n","import { hasTokenLabel, tokenLabel } from \"../scan/tokens_public.js\";\nimport { first, map, reduce } from \"lodash-es\";\nimport {\n  Alternation,\n  getProductionDslName,\n  NonTerminal,\n  Rule,\n  Terminal,\n} from \"@chevrotain/gast\";\nimport {\n  IParserErrorMessageProvider,\n  IProductionWithOccurrence,\n  TokenType,\n} from \"@chevrotain/types\";\nimport {\n  IGrammarResolverErrorMessageProvider,\n  IGrammarValidatorErrorMessageProvider,\n} from \"./grammar/types.js\";\n\nexport const defaultParserErrorProvider: IParserErrorMessageProvider = {\n  buildMismatchTokenMessage({ expected, actual, previous, ruleName }): string {\n    const hasLabel = hasTokenLabel(expected);\n    const expectedMsg = hasLabel\n      ? `--> ${tokenLabel(expected)} <--`\n      : `token of type --> ${expected.name} <--`;\n\n    const msg = `Expecting ${expectedMsg} but found --> '${actual.image}' <--`;\n\n    return msg;\n  },\n\n  buildNotAllInputParsedMessage({ firstRedundant, ruleName }): string {\n    return \"Redundant input, expecting EOF but found: \" + firstRedundant.image;\n  },\n\n  buildNoViableAltMessage({\n    expectedPathsPerAlt,\n    actual,\n    previous,\n    customUserDescription,\n    ruleName,\n  }): string {\n    const errPrefix = \"Expecting: \";\n    // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n    const actualText = first(actual)!.image;\n    const errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n\n    if (customUserDescription) {\n      return errPrefix + customUserDescription + errSuffix;\n    } else {\n      const allLookAheadPaths = reduce(\n        expectedPathsPerAlt,\n        (result, currAltPaths) => result.concat(currAltPaths),\n        [] as TokenType[][],\n      );\n      const nextValidTokenSequences = map(\n        allLookAheadPaths,\n        (currPath) =>\n          `[${map(currPath, (currTokenType) => tokenLabel(currTokenType)).join(\n            \", \",\n          )}]`,\n      );\n      const nextValidSequenceItems = map(\n        nextValidTokenSequences,\n        (itemMsg, idx) => `  ${idx + 1}. ${itemMsg}`,\n      );\n      const calculatedDescription = `one of these possible Token sequences:\\n${nextValidSequenceItems.join(\n        \"\\n\",\n      )}`;\n\n      return errPrefix + calculatedDescription + errSuffix;\n    }\n  },\n\n  buildEarlyExitMessage({\n    expectedIterationPaths,\n    actual,\n    customUserDescription,\n    ruleName,\n  }): string {\n    const errPrefix = \"Expecting: \";\n    // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n    const actualText = first(actual)!.image;\n    const errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n\n    if (customUserDescription) {\n      return errPrefix + customUserDescription + errSuffix;\n    } else {\n      const nextValidTokenSequences = map(\n        expectedIterationPaths,\n        (currPath) =>\n          `[${map(currPath, (currTokenType) => tokenLabel(currTokenType)).join(\n            \",\",\n          )}]`,\n      );\n      const calculatedDescription =\n        `expecting at least one iteration which starts with one of these possible Token sequences::\\n  ` +\n        `<${nextValidTokenSequences.join(\" ,\")}>`;\n\n      return errPrefix + calculatedDescription + errSuffix;\n    }\n  },\n};\n\nObject.freeze(defaultParserErrorProvider);\n\nexport const defaultGrammarResolverErrorProvider: IGrammarResolverErrorMessageProvider =\n  {\n    buildRuleNotFoundError(\n      topLevelRule: Rule,\n      undefinedRule: NonTerminal,\n    ): string {\n      const msg =\n        \"Invalid grammar, reference to a rule which is not defined: ->\" +\n        undefinedRule.nonTerminalName +\n        \"<-\\n\" +\n        \"inside top level rule: ->\" +\n        topLevelRule.name +\n        \"<-\";\n      return msg;\n    },\n  };\n\nexport const defaultGrammarValidatorErrorProvider: IGrammarValidatorErrorMessageProvider =\n  {\n    buildDuplicateFoundError(\n      topLevelRule: Rule,\n      duplicateProds: IProductionWithOccurrence[],\n    ): string {\n      function getExtraProductionArgument(\n        prod: IProductionWithOccurrence,\n      ): string {\n        if (prod instanceof Terminal) {\n          return prod.terminalType.name;\n        } else if (prod instanceof NonTerminal) {\n          return prod.nonTerminalName;\n        } else {\n          return \"\";\n        }\n      }\n\n      const topLevelName = topLevelRule.name;\n      const duplicateProd = first(duplicateProds)!;\n      const index = duplicateProd.idx;\n      const dslName = getProductionDslName(duplicateProd);\n      const extraArgument = getExtraProductionArgument(duplicateProd);\n\n      const hasExplicitIndex = index > 0;\n      let msg = `->${dslName}${hasExplicitIndex ? index : \"\"}<- ${\n        extraArgument ? `with argument: ->${extraArgument}<-` : \"\"\n      }\n                  appears more than once (${\n                    duplicateProds.length\n                  } times) in the top level rule: ->${topLevelName}<-.                  \n                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES \n                  `;\n\n      // white space trimming time! better to trim afterwards as it allows to use WELL formatted multi line template strings...\n      msg = msg.replace(/[ \\t]+/g, \" \");\n      msg = msg.replace(/\\s\\s+/g, \"\\n\");\n\n      return msg;\n    },\n\n    buildNamespaceConflictError(rule: Rule): string {\n      const errMsg =\n        `Namespace conflict found in grammar.\\n` +\n        `The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <${rule.name}>.\\n` +\n        `To resolve this make sure each Terminal and Non-Terminal names are unique\\n` +\n        `This is easy to accomplish by using the convention that Terminal names start with an uppercase letter\\n` +\n        `and Non-Terminal names start with a lower case letter.`;\n\n      return errMsg;\n    },\n\n    buildAlternationPrefixAmbiguityError(options: {\n      topLevelRule: Rule;\n      prefixPath: TokenType[];\n      ambiguityIndices: number[];\n      alternation: Alternation;\n    }): string {\n      const pathMsg = map(options.prefixPath, (currTok) =>\n        tokenLabel(currTok),\n      ).join(\", \");\n      const occurrence =\n        options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n      const errMsg =\n        `Ambiguous alternatives: <${options.ambiguityIndices.join(\n          \" ,\",\n        )}> due to common lookahead prefix\\n` +\n        `in <OR${occurrence}> inside <${options.topLevelRule.name}> Rule,\\n` +\n        `<${pathMsg}> may appears as a prefix path in all these alternatives.\\n` +\n        `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\\n` +\n        `For Further details.`;\n\n      return errMsg;\n    },\n\n    buildAlternationAmbiguityError(options: {\n      topLevelRule: Rule;\n      prefixPath: TokenType[];\n      ambiguityIndices: number[];\n      alternation: Alternation;\n    }): string {\n      const pathMsg = map(options.prefixPath, (currtok) =>\n        tokenLabel(currtok),\n      ).join(\", \");\n      const occurrence =\n        options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n      let currMessage =\n        `Ambiguous Alternatives Detected: <${options.ambiguityIndices.join(\n          \" ,\",\n        )}> in <OR${occurrence}>` +\n        ` inside <${options.topLevelRule.name}> Rule,\\n` +\n        `<${pathMsg}> may appears as a prefix path in all these alternatives.\\n`;\n\n      currMessage =\n        currMessage +\n        `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\\n` +\n        `For Further details.`;\n      return currMessage;\n    },\n\n    buildEmptyRepetitionError(options: {\n      topLevelRule: Rule;\n      repetition: IProductionWithOccurrence;\n    }): string {\n      let dslName = getProductionDslName(options.repetition);\n      if (options.repetition.idx !== 0) {\n        dslName += options.repetition.idx;\n      }\n\n      const errMsg =\n        `The repetition <${dslName}> within Rule <${options.topLevelRule.name}> can never consume any tokens.\\n` +\n        `This could lead to an infinite loop.`;\n\n      return errMsg;\n    },\n\n    // TODO: remove - `errors_public` from nyc.config.js exclude\n    //       once this method is fully removed from this file\n    buildTokenNameError(options: {\n      tokenType: TokenType;\n      expectedPattern: RegExp;\n    }): string {\n      /* istanbul ignore next */\n      return \"deprecated\";\n    },\n\n    buildEmptyAlternationError(options: {\n      topLevelRule: Rule;\n      alternation: Alternation;\n      emptyChoiceIdx: number;\n    }): string {\n      const errMsg =\n        `Ambiguous empty alternative: <${options.emptyChoiceIdx + 1}>` +\n        ` in <OR${options.alternation.idx}> inside <${options.topLevelRule.name}> Rule.\\n` +\n        `Only the last alternative may be an empty alternative.`;\n\n      return errMsg;\n    },\n\n    buildTooManyAlternativesError(options: {\n      topLevelRule: Rule;\n      alternation: Alternation;\n    }): string {\n      const errMsg =\n        `An Alternation cannot have more than 256 alternatives:\\n` +\n        `<OR${options.alternation.idx}> inside <${\n          options.topLevelRule.name\n        }> Rule.\\n has ${\n          options.alternation.definition.length + 1\n        } alternatives.`;\n\n      return errMsg;\n    },\n\n    buildLeftRecursionError(options: {\n      topLevelRule: Rule;\n      leftRecursionPath: Rule[];\n    }): string {\n      const ruleName = options.topLevelRule.name;\n      const pathNames = map(\n        options.leftRecursionPath,\n        (currRule) => currRule.name,\n      );\n      const leftRecursivePath = `${ruleName} --> ${pathNames\n        .concat([ruleName])\n        .join(\" --> \")}`;\n      const errMsg =\n        `Left Recursion found in grammar.\\n` +\n        `rule: <${ruleName}> can be invoked from itself (directly or indirectly)\\n` +\n        `without consuming any Tokens. The grammar path that causes this is: \\n ${leftRecursivePath}\\n` +\n        ` To fix this refactor your grammar to remove the left recursion.\\n` +\n        `see: https://en.wikipedia.org/wiki/LL_parser#Left_factoring.`;\n\n      return errMsg;\n    },\n\n    // TODO: remove - `errors_public` from nyc.config.js exclude\n    //       once this method is fully removed from this file\n    buildInvalidRuleNameError(options: {\n      topLevelRule: Rule;\n      expectedPattern: RegExp;\n    }): string {\n      /* istanbul ignore next */\n      return \"deprecated\";\n    },\n\n    buildDuplicateRuleNameError(options: {\n      topLevelRule: Rule | string;\n      grammarName: string;\n    }): string {\n      let ruleName;\n      if (options.topLevelRule instanceof Rule) {\n        ruleName = options.topLevelRule.name;\n      } else {\n        ruleName = options.topLevelRule;\n      }\n\n      const errMsg = `Duplicate definition, rule: ->${ruleName}<- is already defined in the grammar: ->${options.grammarName}<-`;\n\n      return errMsg;\n    },\n  };\n","import {\n  IParserUnresolvedRefDefinitionError,\n  ParserDefinitionErrorType,\n} from \"../parser/parser.js\";\nimport { forEach, values } from \"lodash-es\";\nimport { GAstVisitor, NonTerminal, Rule } from \"@chevrotain/gast\";\nimport {\n  IGrammarResolverErrorMessageProvider,\n  IParserDefinitionError,\n} from \"./types.js\";\n\nexport function resolveGrammar(\n  topLevels: Record<string, Rule>,\n  errMsgProvider: IGrammarResolverErrorMessageProvider,\n): IParserDefinitionError[] {\n  const refResolver = new GastRefResolverVisitor(topLevels, errMsgProvider);\n  refResolver.resolveRefs();\n  return refResolver.errors;\n}\n\nexport class GastRefResolverVisitor extends GAstVisitor {\n  public errors: IParserUnresolvedRefDefinitionError[] = [];\n  private currTopLevel: Rule;\n\n  constructor(\n    private nameToTopRule: Record<string, Rule>,\n    private errMsgProvider: IGrammarResolverErrorMessageProvider,\n  ) {\n    super();\n  }\n\n  public resolveRefs(): void {\n    forEach(values(this.nameToTopRule), (prod) => {\n      this.currTopLevel = prod;\n      prod.accept(this);\n    });\n  }\n\n  public visitNonTerminal(node: NonTerminal): void {\n    const ref = this.nameToTopRule[node.nonTerminalName];\n\n    if (!ref) {\n      const msg = this.errMsgProvider.buildRuleNotFoundError(\n        this.currTopLevel,\n        node,\n      );\n      this.errors.push({\n        message: msg,\n        type: ParserDefinitionErrorType.UNRESOLVED_SUBRULE_REF,\n        ruleName: this.currTopLevel.name,\n        unresolvedRefName: node.nonTerminalName,\n      });\n    } else {\n      node.referencedRule = ref;\n    }\n  }\n}\n","import {\n  clone,\n  drop,\n  dropRight,\n  first as _first,\n  forEach,\n  isEmpty,\n  last,\n} from \"lodash-es\";\nimport { first } from \"./first.js\";\nimport { RestWalker } from \"./rest.js\";\nimport { TokenMatcher } from \"../parser/parser.js\";\nimport {\n  Alternation,\n  Alternative,\n  NonTerminal,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Rule,\n  Terminal,\n} from \"@chevrotain/gast\";\nimport {\n  IGrammarPath,\n  IProduction,\n  ISyntacticContentAssistPath,\n  IToken,\n  ITokenGrammarPath,\n  TokenType,\n} from \"@chevrotain/types\";\n\nexport abstract class AbstractNextPossibleTokensWalker extends RestWalker {\n  protected possibleTokTypes: TokenType[] = [];\n  protected ruleStack: string[];\n  protected occurrenceStack: number[];\n\n  protected nextProductionName = \"\";\n  protected nextProductionOccurrence = 0;\n  protected found = false;\n  protected isAtEndOfPath = false;\n\n  constructor(\n    protected topProd: Rule,\n    protected path: IGrammarPath,\n  ) {\n    super();\n  }\n\n  startWalking(): TokenType[] {\n    this.found = false;\n\n    if (this.path.ruleStack[0] !== this.topProd.name) {\n      throw Error(\"The path does not start with the walker's top Rule!\");\n    }\n\n    // immutable for the win\n    this.ruleStack = clone(this.path.ruleStack).reverse(); // intelij bug requires assertion\n    this.occurrenceStack = clone(this.path.occurrenceStack).reverse(); // intelij bug requires assertion\n\n    // already verified that the first production is valid, we now seek the 2nd production\n    this.ruleStack.pop();\n    this.occurrenceStack.pop();\n\n    this.updateExpectedNext();\n    this.walk(this.topProd);\n\n    return this.possibleTokTypes;\n  }\n\n  walk(\n    prod: { definition: IProduction[] },\n    prevRest: IProduction[] = [],\n  ): void {\n    // stop scanning once we found the path\n    if (!this.found) {\n      super.walk(prod, prevRest);\n    }\n  }\n\n  walkProdRef(\n    refProd: NonTerminal,\n    currRest: IProduction[],\n    prevRest: IProduction[],\n  ): void {\n    // found the next production, need to keep walking in it\n    if (\n      refProd.referencedRule.name === this.nextProductionName &&\n      refProd.idx === this.nextProductionOccurrence\n    ) {\n      const fullRest = currRest.concat(prevRest);\n      this.updateExpectedNext();\n      this.walk(refProd.referencedRule, <any>fullRest);\n    }\n  }\n\n  updateExpectedNext(): void {\n    // need to consume the Terminal\n    if (isEmpty(this.ruleStack)) {\n      // must reset nextProductionXXX to avoid walking down another Top Level production while what we are\n      // really seeking is the last Terminal...\n      this.nextProductionName = \"\";\n      this.nextProductionOccurrence = 0;\n      this.isAtEndOfPath = true;\n    } else {\n      this.nextProductionName = this.ruleStack.pop()!;\n      this.nextProductionOccurrence = this.occurrenceStack.pop()!;\n    }\n  }\n}\n\nexport class NextAfterTokenWalker extends AbstractNextPossibleTokensWalker {\n  private nextTerminalName = \"\";\n  private nextTerminalOccurrence = 0;\n\n  constructor(\n    topProd: Rule,\n    protected path: ITokenGrammarPath,\n  ) {\n    super(topProd, path);\n    this.nextTerminalName = this.path.lastTok.name;\n    this.nextTerminalOccurrence = this.path.lastTokOccurrence;\n  }\n\n  walkTerminal(\n    terminal: Terminal,\n    currRest: IProduction[],\n    prevRest: IProduction[],\n  ): void {\n    if (\n      this.isAtEndOfPath &&\n      terminal.terminalType.name === this.nextTerminalName &&\n      terminal.idx === this.nextTerminalOccurrence &&\n      !this.found\n    ) {\n      const fullRest = currRest.concat(prevRest);\n      const restProd = new Alternative({ definition: fullRest });\n      this.possibleTokTypes = first(restProd);\n      this.found = true;\n    }\n  }\n}\n\nexport type AlternativesFirstTokens = TokenType[][];\n\nexport interface IFirstAfterRepetition {\n  token: TokenType | undefined;\n  occurrence: number | undefined;\n  isEndOfRule: boolean | undefined;\n}\n\n/**\n * This walker only \"walks\" a single \"TOP\" level in the Grammar Ast, this means\n * it never \"follows\" production refs\n */\nexport class AbstractNextTerminalAfterProductionWalker extends RestWalker {\n  protected result: IFirstAfterRepetition = {\n    token: undefined,\n    occurrence: undefined,\n    isEndOfRule: undefined,\n  };\n\n  constructor(\n    protected topRule: Rule,\n    protected occurrence: number,\n  ) {\n    super();\n  }\n\n  startWalking(): IFirstAfterRepetition {\n    this.walk(this.topRule);\n    return this.result;\n  }\n}\n\nexport class NextTerminalAfterManyWalker extends AbstractNextTerminalAfterProductionWalker {\n  walkMany(\n    manyProd: Repetition,\n    currRest: IProduction[],\n    prevRest: IProduction[],\n  ): void {\n    if (manyProd.idx === this.occurrence) {\n      const firstAfterMany = _first(currRest.concat(prevRest));\n      this.result.isEndOfRule = firstAfterMany === undefined;\n      if (firstAfterMany instanceof Terminal) {\n        this.result.token = firstAfterMany.terminalType;\n        this.result.occurrence = firstAfterMany.idx;\n      }\n    } else {\n      super.walkMany(manyProd, currRest, prevRest);\n    }\n  }\n}\n\nexport class NextTerminalAfterManySepWalker extends AbstractNextTerminalAfterProductionWalker {\n  walkManySep(\n    manySepProd: RepetitionWithSeparator,\n    currRest: IProduction[],\n    prevRest: IProduction[],\n  ): void {\n    if (manySepProd.idx === this.occurrence) {\n      const firstAfterManySep = _first(currRest.concat(prevRest));\n      this.result.isEndOfRule = firstAfterManySep === undefined;\n      if (firstAfterManySep instanceof Terminal) {\n        this.result.token = firstAfterManySep.terminalType;\n        this.result.occurrence = firstAfterManySep.idx;\n      }\n    } else {\n      super.walkManySep(manySepProd, currRest, prevRest);\n    }\n  }\n}\n\nexport class NextTerminalAfterAtLeastOneWalker extends AbstractNextTerminalAfterProductionWalker {\n  walkAtLeastOne(\n    atLeastOneProd: RepetitionMandatory,\n    currRest: IProduction[],\n    prevRest: IProduction[],\n  ): void {\n    if (atLeastOneProd.idx === this.occurrence) {\n      const firstAfterAtLeastOne = _first(currRest.concat(prevRest));\n      this.result.isEndOfRule = firstAfterAtLeastOne === undefined;\n      if (firstAfterAtLeastOne instanceof Terminal) {\n        this.result.token = firstAfterAtLeastOne.terminalType;\n        this.result.occurrence = firstAfterAtLeastOne.idx;\n      }\n    } else {\n      super.walkAtLeastOne(atLeastOneProd, currRest, prevRest);\n    }\n  }\n}\n\n// TODO: reduce code duplication in the AfterWalkers\nexport class NextTerminalAfterAtLeastOneSepWalker extends AbstractNextTerminalAfterProductionWalker {\n  walkAtLeastOneSep(\n    atleastOneSepProd: RepetitionMandatoryWithSeparator,\n    currRest: IProduction[],\n    prevRest: IProduction[],\n  ): void {\n    if (atleastOneSepProd.idx === this.occurrence) {\n      const firstAfterfirstAfterAtLeastOneSep = _first(\n        currRest.concat(prevRest),\n      );\n      this.result.isEndOfRule = firstAfterfirstAfterAtLeastOneSep === undefined;\n      if (firstAfterfirstAfterAtLeastOneSep instanceof Terminal) {\n        this.result.token = firstAfterfirstAfterAtLeastOneSep.terminalType;\n        this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx;\n      }\n    } else {\n      super.walkAtLeastOneSep(atleastOneSepProd, currRest, prevRest);\n    }\n  }\n}\n\nexport interface PartialPathAndSuffixes {\n  partialPath: TokenType[];\n  suffixDef: IProduction[];\n}\n\nexport function possiblePathsFrom(\n  targetDef: IProduction[],\n  maxLength: number,\n  currPath: TokenType[] = [],\n): PartialPathAndSuffixes[] {\n  // avoid side effects\n  currPath = clone(currPath);\n  let result: PartialPathAndSuffixes[] = [];\n  let i = 0;\n\n  // TODO: avoid inner funcs\n  function remainingPathWith(nextDef: IProduction[]) {\n    return nextDef.concat(drop(targetDef, i + 1));\n  }\n\n  // TODO: avoid inner funcs\n  function getAlternativesForProd(definition: IProduction[]) {\n    const alternatives = possiblePathsFrom(\n      remainingPathWith(definition),\n      maxLength,\n      currPath,\n    );\n    return result.concat(alternatives);\n  }\n\n  /**\n   * Mandatory productions will halt the loop as the paths computed from their recursive calls will already contain the\n   * following (rest) of the targetDef.\n   *\n   * For optional productions (Option/Repetition/...) the loop will continue to represent the paths that do not include the\n   * the optional production.\n   */\n  while (currPath.length < maxLength && i < targetDef.length) {\n    const prod = targetDef[i];\n\n    /* istanbul ignore else */\n    if (prod instanceof Alternative) {\n      return getAlternativesForProd(prod.definition);\n    } else if (prod instanceof NonTerminal) {\n      return getAlternativesForProd(prod.definition);\n    } else if (prod instanceof Option) {\n      result = getAlternativesForProd(prod.definition);\n    } else if (prod instanceof RepetitionMandatory) {\n      const newDef = prod.definition.concat([\n        new Repetition({\n          definition: prod.definition,\n        }),\n      ]);\n      return getAlternativesForProd(newDef);\n    } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n      const newDef = [\n        new Alternative({ definition: prod.definition }),\n        new Repetition({\n          definition: [new Terminal({ terminalType: prod.separator })].concat(\n            <any>prod.definition,\n          ),\n        }),\n      ];\n      return getAlternativesForProd(newDef);\n    } else if (prod instanceof RepetitionWithSeparator) {\n      const newDef = prod.definition.concat([\n        new Repetition({\n          definition: [new Terminal({ terminalType: prod.separator })].concat(\n            <any>prod.definition,\n          ),\n        }),\n      ]);\n      result = getAlternativesForProd(newDef);\n    } else if (prod instanceof Repetition) {\n      const newDef = prod.definition.concat([\n        new Repetition({\n          definition: prod.definition,\n        }),\n      ]);\n      result = getAlternativesForProd(newDef);\n    } else if (prod instanceof Alternation) {\n      forEach(prod.definition, (currAlt) => {\n        // TODO: this is a limited check for empty alternatives\n        //   It would prevent a common case of infinite loops during parser initialization.\n        //   However **in-directly** empty alternatives may still cause issues.\n        if (isEmpty(currAlt.definition) === false) {\n          result = getAlternativesForProd(currAlt.definition);\n        }\n      });\n      return result;\n    } else if (prod instanceof Terminal) {\n      currPath.push(prod.terminalType);\n    } else {\n      throw Error(\"non exhaustive match\");\n    }\n\n    i++;\n  }\n  result.push({\n    partialPath: currPath,\n    suffixDef: drop(targetDef, i),\n  });\n\n  return result;\n}\n\ninterface IPathToExamine {\n  idx: number;\n  def: IProduction[];\n  ruleStack: string[];\n  occurrenceStack: number[];\n}\n\nexport function nextPossibleTokensAfter(\n  initialDef: IProduction[],\n  tokenVector: IToken[],\n  tokMatcher: TokenMatcher,\n  maxLookAhead: number,\n): ISyntacticContentAssistPath[] {\n  const EXIT_NON_TERMINAL: any = \"EXIT_NONE_TERMINAL\";\n  // to avoid creating a new Array each time.\n  const EXIT_NON_TERMINAL_ARR = [EXIT_NON_TERMINAL];\n  const EXIT_ALTERNATIVE: any = \"EXIT_ALTERNATIVE\";\n  let foundCompletePath = false;\n\n  const tokenVectorLength = tokenVector.length;\n  const minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1;\n\n  const result: ISyntacticContentAssistPath[] = [];\n\n  const possiblePaths: IPathToExamine[] = [];\n  possiblePaths.push({\n    idx: -1,\n    def: initialDef,\n    ruleStack: [],\n    occurrenceStack: [],\n  });\n\n  while (!isEmpty(possiblePaths)) {\n    const currPath = possiblePaths.pop()!;\n\n    // skip alternatives if no more results can be found (assuming deterministic grammar with fixed lookahead)\n    if (currPath === EXIT_ALTERNATIVE) {\n      if (\n        foundCompletePath &&\n        last(possiblePaths)!.idx <= minimalAlternativesIndex\n      ) {\n        // remove irrelevant alternative\n        possiblePaths.pop();\n      }\n      continue;\n    }\n\n    const currDef = currPath.def;\n    const currIdx = currPath.idx;\n    const currRuleStack = currPath.ruleStack;\n    const currOccurrenceStack = currPath.occurrenceStack;\n\n    // For Example: an empty path could exist in a valid grammar in the case of an EMPTY_ALT\n    if (isEmpty(currDef)) {\n      continue;\n    }\n\n    const prod = currDef[0];\n    /* istanbul ignore else */\n    if (prod === EXIT_NON_TERMINAL) {\n      const nextPath = {\n        idx: currIdx,\n        def: drop(currDef),\n        ruleStack: dropRight(currRuleStack),\n        occurrenceStack: dropRight(currOccurrenceStack),\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof Terminal) {\n      /* istanbul ignore else */\n      if (currIdx < tokenVectorLength - 1) {\n        const nextIdx = currIdx + 1;\n        const actualToken = tokenVector[nextIdx];\n        if (tokMatcher!(actualToken, prod.terminalType)) {\n          const nextPath = {\n            idx: nextIdx,\n            def: drop(currDef),\n            ruleStack: currRuleStack,\n            occurrenceStack: currOccurrenceStack,\n          };\n          possiblePaths.push(nextPath);\n        }\n        // end of the line\n      } else if (currIdx === tokenVectorLength - 1) {\n        // IGNORE ABOVE ELSE\n        result.push({\n          nextTokenType: prod.terminalType,\n          nextTokenOccurrence: prod.idx,\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack,\n        });\n        foundCompletePath = true;\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    } else if (prod instanceof NonTerminal) {\n      const newRuleStack = clone(currRuleStack);\n      newRuleStack.push(prod.nonTerminalName);\n\n      const newOccurrenceStack = clone(currOccurrenceStack);\n      newOccurrenceStack.push(prod.idx);\n\n      const nextPath = {\n        idx: currIdx,\n        def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, drop(currDef)),\n        ruleStack: newRuleStack,\n        occurrenceStack: newOccurrenceStack,\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof Option) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      const nextPathWithout = {\n        idx: currIdx,\n        def: drop(currDef),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack,\n      };\n      possiblePaths.push(nextPathWithout);\n      // required marker to avoid backtracking paths whose higher priority alternatives already matched\n      possiblePaths.push(EXIT_ALTERNATIVE);\n\n      const nextPathWith = {\n        idx: currIdx,\n        def: prod.definition.concat(drop(currDef)),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack,\n      };\n      possiblePaths.push(nextPathWith);\n    } else if (prod instanceof RepetitionMandatory) {\n      // TODO:(THE NEW operators here take a while...) (convert once?)\n      const secondIteration = new Repetition({\n        definition: prod.definition,\n        idx: prod.idx,\n      });\n      const nextDef = prod.definition.concat([secondIteration], drop(currDef));\n      const nextPath = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack,\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n      // TODO:(THE NEW operators here take a while...) (convert once?)\n      const separatorGast = new Terminal({\n        terminalType: prod.separator,\n      });\n      const secondIteration = new Repetition({\n        definition: [<any>separatorGast].concat(prod.definition),\n        idx: prod.idx,\n      });\n      const nextDef = prod.definition.concat([secondIteration], drop(currDef));\n      const nextPath = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack,\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof RepetitionWithSeparator) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      const nextPathWithout = {\n        idx: currIdx,\n        def: drop(currDef),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack,\n      };\n      possiblePaths.push(nextPathWithout);\n      // required marker to avoid backtracking paths whose higher priority alternatives already matched\n      possiblePaths.push(EXIT_ALTERNATIVE);\n\n      const separatorGast = new Terminal({\n        terminalType: prod.separator,\n      });\n      const nthRepetition = new Repetition({\n        definition: [<any>separatorGast].concat(prod.definition),\n        idx: prod.idx,\n      });\n      const nextDef = prod.definition.concat([nthRepetition], drop(currDef));\n      const nextPathWith = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack,\n      };\n      possiblePaths.push(nextPathWith);\n    } else if (prod instanceof Repetition) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      const nextPathWithout = {\n        idx: currIdx,\n        def: drop(currDef),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack,\n      };\n      possiblePaths.push(nextPathWithout);\n      // required marker to avoid backtracking paths whose higher priority alternatives already matched\n      possiblePaths.push(EXIT_ALTERNATIVE);\n\n      // TODO: an empty repetition will cause infinite loops here, will the parser detect this in selfAnalysis?\n      const nthRepetition = new Repetition({\n        definition: prod.definition,\n        idx: prod.idx,\n      });\n      const nextDef = prod.definition.concat([nthRepetition], drop(currDef));\n      const nextPathWith = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack,\n      };\n      possiblePaths.push(nextPathWith);\n    } else if (prod instanceof Alternation) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      for (let i = prod.definition.length - 1; i >= 0; i--) {\n        const currAlt: any = prod.definition[i];\n        const currAltPath = {\n          idx: currIdx,\n          def: currAlt.definition.concat(drop(currDef)),\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack,\n        };\n        possiblePaths.push(currAltPath);\n        possiblePaths.push(EXIT_ALTERNATIVE);\n      }\n    } else if (prod instanceof Alternative) {\n      possiblePaths.push({\n        idx: currIdx,\n        def: prod.definition.concat(drop(currDef)),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack,\n      });\n    } else if (prod instanceof Rule) {\n      // last because we should only encounter at most a single one of these per invocation.\n      possiblePaths.push(\n        expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack),\n      );\n    } else {\n      throw Error(\"non exhaustive match\");\n    }\n  }\n  return result;\n}\n\nfunction expandTopLevelRule(\n  topRule: Rule,\n  currIdx: number,\n  currRuleStack: string[],\n  currOccurrenceStack: number[],\n): IPathToExamine {\n  const newRuleStack = clone(currRuleStack);\n  newRuleStack.push(topRule.name);\n\n  const newCurrOccurrenceStack = clone(currOccurrenceStack);\n  // top rule is always assumed to have been called with occurrence index 1\n  newCurrOccurrenceStack.push(1);\n\n  return {\n    idx: currIdx,\n    def: topRule.definition,\n    ruleStack: newRuleStack,\n    occurrenceStack: newCurrOccurrenceStack,\n  };\n}\n","import { every, flatten, forEach, has, isEmpty, map, reduce } from \"lodash-es\";\nimport { possiblePathsFrom } from \"./interpreter.js\";\nimport { RestWalker } from \"./rest.js\";\nimport { Predicate, TokenMatcher } from \"../parser/parser.js\";\nimport {\n  tokenStructuredMatcher,\n  tokenStructuredMatcherNoCategories,\n} from \"../../scan/tokens.js\";\nimport {\n  Alternation,\n  Alternative as AlternativeGAST,\n  GAstVisitor,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n} from \"@chevrotain/gast\";\nimport {\n  BaseParser,\n  IOrAlt,\n  IProduction,\n  IProductionWithOccurrence,\n  LookaheadProductionType,\n  LookaheadSequence,\n  Rule,\n  TokenType,\n} from \"@chevrotain/types\";\n\nexport enum PROD_TYPE {\n  OPTION,\n  REPETITION,\n  REPETITION_MANDATORY,\n  REPETITION_MANDATORY_WITH_SEPARATOR,\n  REPETITION_WITH_SEPARATOR,\n  ALTERNATION,\n}\n\nexport function getProdType(\n  prod: IProduction | LookaheadProductionType,\n): PROD_TYPE {\n  /* istanbul ignore else */\n  if (prod instanceof Option || prod === \"Option\") {\n    return PROD_TYPE.OPTION;\n  } else if (prod instanceof Repetition || prod === \"Repetition\") {\n    return PROD_TYPE.REPETITION;\n  } else if (\n    prod instanceof RepetitionMandatory ||\n    prod === \"RepetitionMandatory\"\n  ) {\n    return PROD_TYPE.REPETITION_MANDATORY;\n  } else if (\n    prod instanceof RepetitionMandatoryWithSeparator ||\n    prod === \"RepetitionMandatoryWithSeparator\"\n  ) {\n    return PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR;\n  } else if (\n    prod instanceof RepetitionWithSeparator ||\n    prod === \"RepetitionWithSeparator\"\n  ) {\n    return PROD_TYPE.REPETITION_WITH_SEPARATOR;\n  } else if (prod instanceof Alternation || prod === \"Alternation\") {\n    return PROD_TYPE.ALTERNATION;\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\n\nexport function getLookaheadPaths(options: {\n  occurrence: number;\n  rule: Rule;\n  prodType: LookaheadProductionType;\n  maxLookahead: number;\n}): LookaheadSequence[] {\n  const { occurrence, rule, prodType, maxLookahead } = options;\n  const type = getProdType(prodType);\n  if (type === PROD_TYPE.ALTERNATION) {\n    return getLookaheadPathsForOr(occurrence, rule, maxLookahead);\n  } else {\n    return getLookaheadPathsForOptionalProd(\n      occurrence,\n      rule,\n      type,\n      maxLookahead,\n    );\n  }\n}\n\nexport function buildLookaheadFuncForOr(\n  occurrence: number,\n  ruleGrammar: Rule,\n  maxLookahead: number,\n  hasPredicates: boolean,\n  dynamicTokensEnabled: boolean,\n  laFuncBuilder: Function,\n): (orAlts?: IOrAlt<any>[]) => number | undefined {\n  const lookAheadPaths = getLookaheadPathsForOr(\n    occurrence,\n    ruleGrammar,\n    maxLookahead,\n  );\n\n  const tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)\n    ? tokenStructuredMatcherNoCategories\n    : tokenStructuredMatcher;\n\n  return laFuncBuilder(\n    lookAheadPaths,\n    hasPredicates,\n    tokenMatcher,\n    dynamicTokensEnabled,\n  );\n}\n\n/**\n *  When dealing with an Optional production (OPTION/MANY/2nd iteration of AT_LEAST_ONE/...) we need to compare\n *  the lookahead \"inside\" the production and the lookahead immediately \"after\" it in the same top level rule (context free).\n *\n *  Example: given a production:\n *  ABC(DE)?DF\n *\n *  The optional '(DE)?' should only be entered if we see 'DE'. a single Token 'D' is not sufficient to distinguish between the two\n *  alternatives.\n *\n *  @returns A Lookahead function which will return true IFF the parser should parse the Optional production.\n */\nexport function buildLookaheadFuncForOptionalProd(\n  occurrence: number,\n  ruleGrammar: Rule,\n  k: number,\n  dynamicTokensEnabled: boolean,\n  prodType: PROD_TYPE,\n  lookaheadBuilder: (\n    lookAheadSequence: LookaheadSequence,\n    tokenMatcher: TokenMatcher,\n    dynamicTokensEnabled: boolean,\n  ) => () => boolean,\n): () => boolean {\n  const lookAheadPaths = getLookaheadPathsForOptionalProd(\n    occurrence,\n    ruleGrammar,\n    prodType,\n    k,\n  );\n\n  const tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)\n    ? tokenStructuredMatcherNoCategories\n    : tokenStructuredMatcher;\n\n  return lookaheadBuilder(\n    lookAheadPaths[0],\n    tokenMatcher,\n    dynamicTokensEnabled,\n  );\n}\n\nexport type Alternative = TokenType[][];\n\nexport function buildAlternativesLookAheadFunc(\n  alts: LookaheadSequence[],\n  hasPredicates: boolean,\n  tokenMatcher: TokenMatcher,\n  dynamicTokensEnabled: boolean,\n): (orAlts: IOrAlt<any>[]) => number | undefined {\n  const numOfAlts = alts.length;\n  const areAllOneTokenLookahead = every(alts, (currAlt) => {\n    return every(currAlt, (currPath) => {\n      return currPath.length === 1;\n    });\n  });\n\n  // This version takes into account the predicates as well.\n  if (hasPredicates) {\n    /**\n     * @returns {number} - The chosen alternative index\n     */\n    return function (\n      this: BaseParser,\n      orAlts: IOrAlt<any>[],\n    ): number | undefined {\n      // unfortunately the predicates must be extracted every single time\n      // as they cannot be cached due to references to parameters(vars) which are no longer valid.\n      // note that in the common case of no predicates, no cpu time will be wasted on this (see else block)\n      const predicates: (Predicate | undefined)[] = map(\n        orAlts,\n        (currAlt) => currAlt.GATE,\n      );\n\n      for (let t = 0; t < numOfAlts; t++) {\n        const currAlt = alts[t];\n        const currNumOfPaths = currAlt.length;\n\n        const currPredicate = predicates[t];\n        if (currPredicate !== undefined && currPredicate.call(this) === false) {\n          // if the predicate does not match there is no point in checking the paths\n          continue;\n        }\n        nextPath: for (let j = 0; j < currNumOfPaths; j++) {\n          const currPath = currAlt[j];\n          const currPathLength = currPath.length;\n          for (let i = 0; i < currPathLength; i++) {\n            const nextToken = this.LA(i + 1);\n            if (tokenMatcher(nextToken, currPath[i]) === false) {\n              // mismatch in current path\n              // try the next pth\n              continue nextPath;\n            }\n          }\n          // found a full path that matches.\n          // this will also work for an empty ALT as the loop will be skipped\n          return t;\n        }\n        // none of the paths for the current alternative matched\n        // try the next alternative\n      }\n      // none of the alternatives could be matched\n      return undefined;\n    };\n  } else if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n    // optimized (common) case of all the lookaheads paths requiring only\n    // a single token lookahead. These Optimizations cannot work if dynamically defined Tokens are used.\n    const singleTokenAlts = map(alts, (currAlt) => {\n      return flatten(currAlt);\n    });\n\n    const choiceToAlt = reduce(\n      singleTokenAlts,\n      (result, currAlt, idx) => {\n        forEach(currAlt, (currTokType) => {\n          if (!has(result, currTokType.tokenTypeIdx!)) {\n            result[currTokType.tokenTypeIdx!] = idx;\n          }\n          forEach(currTokType.categoryMatches!, (currExtendingType) => {\n            if (!has(result, currExtendingType)) {\n              result[currExtendingType] = idx;\n            }\n          });\n        });\n        return result;\n      },\n      {} as Record<number, number>,\n    );\n\n    /**\n     * @returns {number} - The chosen alternative index\n     */\n    return function (this: BaseParser): number {\n      const nextToken = this.LA(1);\n      return choiceToAlt[nextToken.tokenTypeIdx];\n    };\n  } else {\n    // optimized lookahead without needing to check the predicates at all.\n    // this causes code duplication which is intentional to improve performance.\n    /**\n     * @returns {number} - The chosen alternative index\n     */\n    return function (this: BaseParser): number | undefined {\n      for (let t = 0; t < numOfAlts; t++) {\n        const currAlt = alts[t];\n        const currNumOfPaths = currAlt.length;\n        nextPath: for (let j = 0; j < currNumOfPaths; j++) {\n          const currPath = currAlt[j];\n          const currPathLength = currPath.length;\n          for (let i = 0; i < currPathLength; i++) {\n            const nextToken = this.LA(i + 1);\n            if (tokenMatcher(nextToken, currPath[i]) === false) {\n              // mismatch in current path\n              // try the next pth\n              continue nextPath;\n            }\n          }\n          // found a full path that matches.\n          // this will also work for an empty ALT as the loop will be skipped\n          return t;\n        }\n        // none of the paths for the current alternative matched\n        // try the next alternative\n      }\n      // none of the alternatives could be matched\n      return undefined;\n    };\n  }\n}\n\nexport function buildSingleAlternativeLookaheadFunction(\n  alt: LookaheadSequence,\n  tokenMatcher: TokenMatcher,\n  dynamicTokensEnabled: boolean,\n): () => boolean {\n  const areAllOneTokenLookahead = every(alt, (currPath) => {\n    return currPath.length === 1;\n  });\n\n  const numOfPaths = alt.length;\n\n  // optimized (common) case of all the lookaheads paths requiring only\n  // a single token lookahead.\n  if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n    const singleTokensTypes = flatten(alt);\n\n    if (\n      singleTokensTypes.length === 1 &&\n      isEmpty((<any>singleTokensTypes[0]).categoryMatches)\n    ) {\n      const expectedTokenType = singleTokensTypes[0];\n      const expectedTokenUniqueKey = (<any>expectedTokenType).tokenTypeIdx;\n\n      return function (this: BaseParser): boolean {\n        return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey;\n      };\n    } else {\n      const choiceToAlt = reduce(\n        singleTokensTypes,\n        (result, currTokType, idx) => {\n          result[currTokType.tokenTypeIdx!] = true;\n          forEach(currTokType.categoryMatches!, (currExtendingType) => {\n            result[currExtendingType] = true;\n          });\n          return result;\n        },\n        [] as boolean[],\n      );\n\n      return function (this: BaseParser): boolean {\n        const nextToken = this.LA(1);\n        return choiceToAlt[nextToken.tokenTypeIdx] === true;\n      };\n    }\n  } else {\n    return function (this: BaseParser): boolean {\n      nextPath: for (let j = 0; j < numOfPaths; j++) {\n        const currPath = alt[j];\n        const currPathLength = currPath.length;\n        for (let i = 0; i < currPathLength; i++) {\n          const nextToken = this.LA(i + 1);\n          if (tokenMatcher(nextToken, currPath[i]) === false) {\n            // mismatch in current path\n            // try the next pth\n            continue nextPath;\n          }\n        }\n        // found a full path that matches.\n        return true;\n      }\n\n      // none of the paths matched\n      return false;\n    };\n  }\n}\n\nclass RestDefinitionFinderWalker extends RestWalker {\n  private restDef: IProduction[];\n\n  constructor(\n    private topProd: Rule,\n    private targetOccurrence: number,\n    private targetProdType: PROD_TYPE,\n  ) {\n    super();\n  }\n\n  startWalking(): IProduction[] {\n    this.walk(this.topProd);\n    return this.restDef;\n  }\n\n  private checkIsTarget(\n    node: IProductionWithOccurrence,\n    expectedProdType: PROD_TYPE,\n    currRest: IProduction[],\n    prevRest: IProduction[],\n  ): boolean {\n    if (\n      node.idx === this.targetOccurrence &&\n      this.targetProdType === expectedProdType\n    ) {\n      this.restDef = currRest.concat(prevRest);\n      return true;\n    }\n    // performance optimization, do not iterate over the entire Grammar ast after we have found the target\n    return false;\n  }\n\n  walkOption(\n    optionProd: Option,\n    currRest: IProduction[],\n    prevRest: IProduction[],\n  ): void {\n    if (!this.checkIsTarget(optionProd, PROD_TYPE.OPTION, currRest, prevRest)) {\n      super.walkOption(optionProd, currRest, prevRest);\n    }\n  }\n\n  walkAtLeastOne(\n    atLeastOneProd: RepetitionMandatory,\n    currRest: IProduction[],\n    prevRest: IProduction[],\n  ): void {\n    if (\n      !this.checkIsTarget(\n        atLeastOneProd,\n        PROD_TYPE.REPETITION_MANDATORY,\n        currRest,\n        prevRest,\n      )\n    ) {\n      super.walkOption(atLeastOneProd, currRest, prevRest);\n    }\n  }\n\n  walkAtLeastOneSep(\n    atLeastOneSepProd: RepetitionMandatoryWithSeparator,\n    currRest: IProduction[],\n    prevRest: IProduction[],\n  ): void {\n    if (\n      !this.checkIsTarget(\n        atLeastOneSepProd,\n        PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR,\n        currRest,\n        prevRest,\n      )\n    ) {\n      super.walkOption(atLeastOneSepProd, currRest, prevRest);\n    }\n  }\n\n  walkMany(\n    manyProd: Repetition,\n    currRest: IProduction[],\n    prevRest: IProduction[],\n  ): void {\n    if (\n      !this.checkIsTarget(manyProd, PROD_TYPE.REPETITION, currRest, prevRest)\n    ) {\n      super.walkOption(manyProd, currRest, prevRest);\n    }\n  }\n\n  walkManySep(\n    manySepProd: RepetitionWithSeparator,\n    currRest: IProduction[],\n    prevRest: IProduction[],\n  ): void {\n    if (\n      !this.checkIsTarget(\n        manySepProd,\n        PROD_TYPE.REPETITION_WITH_SEPARATOR,\n        currRest,\n        prevRest,\n      )\n    ) {\n      super.walkOption(manySepProd, currRest, prevRest);\n    }\n  }\n}\n\n/**\n * Returns the definition of a target production in a top level level rule.\n */\nclass InsideDefinitionFinderVisitor extends GAstVisitor {\n  public result: IProduction[] = [];\n\n  constructor(\n    private targetOccurrence: number,\n    private targetProdType: PROD_TYPE,\n    private targetRef?: any,\n  ) {\n    super();\n  }\n\n  private checkIsTarget(\n    node: { definition: IProduction[] } & IProductionWithOccurrence,\n    expectedProdName: PROD_TYPE,\n  ): void {\n    if (\n      node.idx === this.targetOccurrence &&\n      this.targetProdType === expectedProdName &&\n      (this.targetRef === undefined || node === this.targetRef)\n    ) {\n      this.result = node.definition;\n    }\n  }\n\n  public visitOption(node: Option): void {\n    this.checkIsTarget(node, PROD_TYPE.OPTION);\n  }\n\n  public visitRepetition(node: Repetition): void {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION);\n  }\n\n  public visitRepetitionMandatory(node: RepetitionMandatory): void {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY);\n  }\n\n  public visitRepetitionMandatoryWithSeparator(\n    node: RepetitionMandatoryWithSeparator,\n  ): void {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR);\n  }\n\n  public visitRepetitionWithSeparator(node: RepetitionWithSeparator): void {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION_WITH_SEPARATOR);\n  }\n\n  public visitAlternation(node: Alternation): void {\n    this.checkIsTarget(node, PROD_TYPE.ALTERNATION);\n  }\n}\n\nfunction initializeArrayOfArrays(size: number): any[][] {\n  const result = new Array(size);\n  for (let i = 0; i < size; i++) {\n    result[i] = [];\n  }\n  return result;\n}\n\n/**\n * A sort of hash function between a Path in the grammar and a string.\n * Note that this returns multiple \"hashes\" to support the scenario of token categories.\n * -  A single path with categories may match multiple **actual** paths.\n */\nfunction pathToHashKeys(path: TokenType[]): string[] {\n  let keys = [\"\"];\n  for (let i = 0; i < path.length; i++) {\n    const tokType = path[i];\n    const longerKeys = [];\n    for (let j = 0; j < keys.length; j++) {\n      const currShorterKey = keys[j];\n      longerKeys.push(currShorterKey + \"_\" + tokType.tokenTypeIdx);\n      for (let t = 0; t < tokType.categoryMatches!.length; t++) {\n        const categoriesKeySuffix = \"_\" + tokType.categoryMatches![t];\n        longerKeys.push(currShorterKey + categoriesKeySuffix);\n      }\n    }\n    keys = longerKeys;\n  }\n  return keys;\n}\n\n/**\n * Imperative style due to being called from a hot spot\n */\nfunction isUniquePrefixHash(\n  altKnownPathsKeys: Record<string, boolean>[],\n  searchPathKeys: string[],\n  idx: number,\n): boolean {\n  for (\n    let currAltIdx = 0;\n    currAltIdx < altKnownPathsKeys.length;\n    currAltIdx++\n  ) {\n    // We only want to test vs the other alternatives\n    if (currAltIdx === idx) {\n      continue;\n    }\n    const otherAltKnownPathsKeys = altKnownPathsKeys[currAltIdx];\n    for (let searchIdx = 0; searchIdx < searchPathKeys.length; searchIdx++) {\n      const searchKey = searchPathKeys[searchIdx];\n      if (otherAltKnownPathsKeys[searchKey] === true) {\n        return false;\n      }\n    }\n  }\n  // None of the SearchPathKeys were found in any of the other alternatives\n  return true;\n}\n\nexport function lookAheadSequenceFromAlternatives(\n  altsDefs: IProduction[],\n  k: number,\n): LookaheadSequence[] {\n  const partialAlts = map(altsDefs, (currAlt) =>\n    possiblePathsFrom([currAlt], 1),\n  );\n  const finalResult = initializeArrayOfArrays(partialAlts.length);\n  const altsHashes = map(partialAlts, (currAltPaths) => {\n    const dict: { [key: string]: boolean } = {};\n    forEach(currAltPaths, (item) => {\n      const keys = pathToHashKeys(item.partialPath);\n      forEach(keys, (currKey) => {\n        dict[currKey] = true;\n      });\n    });\n    return dict;\n  });\n  let newData = partialAlts;\n\n  // maxLookahead loop\n  for (let pathLength = 1; pathLength <= k; pathLength++) {\n    const currDataset = newData;\n    newData = initializeArrayOfArrays(currDataset.length);\n\n    // alternatives loop\n    for (let altIdx = 0; altIdx < currDataset.length; altIdx++) {\n      const currAltPathsAndSuffixes = currDataset[altIdx];\n      // paths in current alternative loop\n      for (\n        let currPathIdx = 0;\n        currPathIdx < currAltPathsAndSuffixes.length;\n        currPathIdx++\n      ) {\n        const currPathPrefix = currAltPathsAndSuffixes[currPathIdx].partialPath;\n        const suffixDef = currAltPathsAndSuffixes[currPathIdx].suffixDef;\n        const prefixKeys = pathToHashKeys(currPathPrefix);\n        const isUnique = isUniquePrefixHash(altsHashes, prefixKeys, altIdx);\n        // End of the line for this path.\n        if (isUnique || isEmpty(suffixDef) || currPathPrefix.length === k) {\n          const currAltResult = finalResult[altIdx];\n          // TODO: Can we implement a containsPath using Maps/Dictionaries?\n          if (containsPath(currAltResult, currPathPrefix) === false) {\n            currAltResult.push(currPathPrefix);\n            // Update all new  keys for the current path.\n            for (let j = 0; j < prefixKeys.length; j++) {\n              const currKey = prefixKeys[j];\n              altsHashes[altIdx][currKey] = true;\n            }\n          }\n        }\n        // Expand longer paths\n        else {\n          const newPartialPathsAndSuffixes = possiblePathsFrom(\n            suffixDef,\n            pathLength + 1,\n            currPathPrefix,\n          );\n          newData[altIdx] = newData[altIdx].concat(newPartialPathsAndSuffixes);\n\n          // Update keys for new known paths\n          forEach(newPartialPathsAndSuffixes, (item) => {\n            const prefixKeys = pathToHashKeys(item.partialPath);\n            forEach(prefixKeys, (key) => {\n              altsHashes[altIdx][key] = true;\n            });\n          });\n        }\n      }\n    }\n  }\n\n  return finalResult;\n}\n\nexport function getLookaheadPathsForOr(\n  occurrence: number,\n  ruleGrammar: Rule,\n  k: number,\n  orProd?: Alternation,\n): LookaheadSequence[] {\n  const visitor = new InsideDefinitionFinderVisitor(\n    occurrence,\n    PROD_TYPE.ALTERNATION,\n    orProd,\n  );\n  ruleGrammar.accept(visitor);\n  return lookAheadSequenceFromAlternatives(visitor.result, k);\n}\n\nexport function getLookaheadPathsForOptionalProd(\n  occurrence: number,\n  ruleGrammar: Rule,\n  prodType: PROD_TYPE,\n  k: number,\n): LookaheadSequence[] {\n  const insideDefVisitor = new InsideDefinitionFinderVisitor(\n    occurrence,\n    prodType,\n  );\n  ruleGrammar.accept(insideDefVisitor);\n  const insideDef = insideDefVisitor.result;\n\n  const afterDefWalker = new RestDefinitionFinderWalker(\n    ruleGrammar,\n    occurrence,\n    prodType,\n  );\n  const afterDef = afterDefWalker.startWalking();\n\n  const insideFlat = new AlternativeGAST({ definition: insideDef });\n  const afterFlat = new AlternativeGAST({ definition: afterDef });\n\n  return lookAheadSequenceFromAlternatives([insideFlat, afterFlat], k);\n}\n\nexport function containsPath(\n  alternative: Alternative,\n  searchPath: TokenType[],\n): boolean {\n  compareOtherPath: for (let i = 0; i < alternative.length; i++) {\n    const otherPath = alternative[i];\n    if (otherPath.length !== searchPath.length) {\n      continue;\n    }\n    for (let j = 0; j < otherPath.length; j++) {\n      const searchTok = searchPath[j];\n      const otherTok = otherPath[j];\n\n      const matchingTokens =\n        searchTok === otherTok ||\n        otherTok.categoryMatchesMap![searchTok.tokenTypeIdx!] !== undefined;\n      if (matchingTokens === false) {\n        continue compareOtherPath;\n      }\n    }\n    return true;\n  }\n\n  return false;\n}\n\nexport function isStrictPrefixOfPath(\n  prefix: TokenType[],\n  other: TokenType[],\n): boolean {\n  return (\n    prefix.length < other.length &&\n    every(prefix, (tokType, idx) => {\n      const otherTokType = other[idx];\n      return (\n        tokType === otherTokType ||\n        otherTokType.categoryMatchesMap![tokType.tokenTypeIdx!]\n      );\n    })\n  );\n}\n\nexport function areTokenCategoriesNotUsed(\n  lookAheadPaths: LookaheadSequence[],\n): boolean {\n  return every(lookAheadPaths, (singleAltPaths) =>\n    every(singleAltPaths, (singlePath) =>\n      every(singlePath, (token) => isEmpty(token.categoryMatches!)),\n    ),\n  );\n}\n","import {\n  clone,\n  compact,\n  difference,\n  drop,\n  dropRight,\n  filter,\n  first,\n  flatMap,\n  flatten,\n  forEach,\n  groupBy,\n  includes,\n  isEmpty,\n  map,\n  pickBy,\n  reduce,\n  reject,\n  values,\n} from \"lodash-es\";\nimport {\n  IParserAmbiguousAlternativesDefinitionError,\n  IParserDuplicatesDefinitionError,\n  IParserEmptyAlternativeDefinitionError,\n  ParserDefinitionErrorType,\n} from \"../parser/parser.js\";\nimport {\n  Alternation,\n  Alternative as AlternativeGAST,\n  GAstVisitor,\n  getProductionDslName,\n  isOptionalProd,\n  NonTerminal,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Terminal,\n} from \"@chevrotain/gast\";\nimport {\n  Alternative,\n  containsPath,\n  getLookaheadPathsForOptionalProd,\n  getLookaheadPathsForOr,\n  getProdType,\n  isStrictPrefixOfPath,\n} from \"./lookahead.js\";\nimport { nextPossibleTokensAfter } from \"./interpreter.js\";\nimport {\n  ILookaheadStrategy,\n  IProduction,\n  IProductionWithOccurrence,\n  Rule,\n  TokenType,\n} from \"@chevrotain/types\";\nimport {\n  IGrammarValidatorErrorMessageProvider,\n  IParserDefinitionError,\n} from \"./types.js\";\nimport { tokenStructuredMatcher } from \"../../scan/tokens.js\";\n\nexport function validateLookahead(options: {\n  lookaheadStrategy: ILookaheadStrategy;\n  rules: Rule[];\n  tokenTypes: TokenType[];\n  grammarName: string;\n}): IParserDefinitionError[] {\n  const lookaheadValidationErrorMessages = options.lookaheadStrategy.validate({\n    rules: options.rules,\n    tokenTypes: options.tokenTypes,\n    grammarName: options.grammarName,\n  });\n  return map(lookaheadValidationErrorMessages, (errorMessage) => ({\n    type: ParserDefinitionErrorType.CUSTOM_LOOKAHEAD_VALIDATION,\n    ...errorMessage,\n  }));\n}\n\nexport function validateGrammar(\n  topLevels: Rule[],\n  tokenTypes: TokenType[],\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\n  grammarName: string,\n): IParserDefinitionError[] {\n  const duplicateErrors: IParserDefinitionError[] = flatMap(\n    topLevels,\n    (currTopLevel) =>\n      validateDuplicateProductions(currTopLevel, errMsgProvider),\n  );\n\n  const termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(\n    topLevels,\n    tokenTypes,\n    errMsgProvider,\n  );\n\n  const tooManyAltsErrors = flatMap(topLevels, (curRule) =>\n    validateTooManyAlts(curRule, errMsgProvider),\n  );\n\n  const duplicateRulesError = flatMap(topLevels, (curRule) =>\n    validateRuleDoesNotAlreadyExist(\n      curRule,\n      topLevels,\n      grammarName,\n      errMsgProvider,\n    ),\n  );\n\n  return duplicateErrors.concat(\n    termsNamespaceConflictErrors,\n    tooManyAltsErrors,\n    duplicateRulesError,\n  );\n}\n\nfunction validateDuplicateProductions(\n  topLevelRule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\n): IParserDuplicatesDefinitionError[] {\n  const collectorVisitor = new OccurrenceValidationCollector();\n  topLevelRule.accept(collectorVisitor);\n  const allRuleProductions = collectorVisitor.allProductions;\n\n  const productionGroups = groupBy(\n    allRuleProductions,\n    identifyProductionForDuplicates,\n  );\n\n  const duplicates: any = pickBy(productionGroups, (currGroup) => {\n    return currGroup.length > 1;\n  });\n\n  const errors = map(values(duplicates), (currDuplicates: any) => {\n    const firstProd: any = first(currDuplicates);\n    const msg = errMsgProvider.buildDuplicateFoundError(\n      topLevelRule,\n      currDuplicates,\n    );\n    const dslName = getProductionDslName(firstProd);\n    const defError: IParserDuplicatesDefinitionError = {\n      message: msg,\n      type: ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,\n      ruleName: topLevelRule.name,\n      dslName: dslName,\n      occurrence: firstProd.idx,\n    };\n\n    const param = getExtraProductionArgument(firstProd);\n    if (param) {\n      defError.parameter = param;\n    }\n\n    return defError;\n  });\n  return errors;\n}\n\nexport function identifyProductionForDuplicates(\n  prod: IProductionWithOccurrence,\n): string {\n  return `${getProductionDslName(prod)}_#_${\n    prod.idx\n  }_#_${getExtraProductionArgument(prod)}`;\n}\n\nfunction getExtraProductionArgument(prod: IProductionWithOccurrence): string {\n  if (prod instanceof Terminal) {\n    return prod.terminalType.name;\n  } else if (prod instanceof NonTerminal) {\n    return prod.nonTerminalName;\n  } else {\n    return \"\";\n  }\n}\n\nexport class OccurrenceValidationCollector extends GAstVisitor {\n  public allProductions: IProductionWithOccurrence[] = [];\n\n  public visitNonTerminal(subrule: NonTerminal): void {\n    this.allProductions.push(subrule);\n  }\n\n  public visitOption(option: Option): void {\n    this.allProductions.push(option);\n  }\n\n  public visitRepetitionWithSeparator(manySep: RepetitionWithSeparator): void {\n    this.allProductions.push(manySep);\n  }\n\n  public visitRepetitionMandatory(atLeastOne: RepetitionMandatory): void {\n    this.allProductions.push(atLeastOne);\n  }\n\n  public visitRepetitionMandatoryWithSeparator(\n    atLeastOneSep: RepetitionMandatoryWithSeparator,\n  ): void {\n    this.allProductions.push(atLeastOneSep);\n  }\n\n  public visitRepetition(many: Repetition): void {\n    this.allProductions.push(many);\n  }\n\n  public visitAlternation(or: Alternation): void {\n    this.allProductions.push(or);\n  }\n\n  public visitTerminal(terminal: Terminal): void {\n    this.allProductions.push(terminal);\n  }\n}\n\nexport function validateRuleDoesNotAlreadyExist(\n  rule: Rule,\n  allRules: Rule[],\n  className: string,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\n): IParserDefinitionError[] {\n  const errors = [];\n  const occurrences = reduce(\n    allRules,\n    (result, curRule) => {\n      if (curRule.name === rule.name) {\n        return result + 1;\n      }\n      return result;\n    },\n    0,\n  );\n  if (occurrences > 1) {\n    const errMsg = errMsgProvider.buildDuplicateRuleNameError({\n      topLevelRule: rule,\n      grammarName: className,\n    });\n    errors.push({\n      message: errMsg,\n      type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n      ruleName: rule.name,\n    });\n  }\n\n  return errors;\n}\n\n// TODO: is there anyway to get only the rule names of rules inherited from the super grammars?\n// This is not part of the IGrammarErrorProvider because the validation cannot be performed on\n// The grammar structure, only at runtime.\nexport function validateRuleIsOverridden(\n  ruleName: string,\n  definedRulesNames: string[],\n  className: string,\n): IParserDefinitionError[] {\n  const errors = [];\n  let errMsg;\n\n  if (!includes(definedRulesNames, ruleName)) {\n    errMsg =\n      `Invalid rule override, rule: ->${ruleName}<- cannot be overridden in the grammar: ->${className}<-` +\n      `as it is not defined in any of the super grammars `;\n    errors.push({\n      message: errMsg,\n      type: ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,\n      ruleName: ruleName,\n    });\n  }\n\n  return errors;\n}\n\nexport function validateNoLeftRecursion(\n  topRule: Rule,\n  currRule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\n  path: Rule[] = [],\n): IParserDefinitionError[] {\n  const errors: IParserDefinitionError[] = [];\n  const nextNonTerminals = getFirstNoneTerminal(currRule.definition);\n  if (isEmpty(nextNonTerminals)) {\n    return [];\n  } else {\n    const ruleName = topRule.name;\n    const foundLeftRecursion = includes(nextNonTerminals, topRule);\n    if (foundLeftRecursion) {\n      errors.push({\n        message: errMsgProvider.buildLeftRecursionError({\n          topLevelRule: topRule,\n          leftRecursionPath: path,\n        }),\n        type: ParserDefinitionErrorType.LEFT_RECURSION,\n        ruleName: ruleName,\n      });\n    }\n\n    // we are only looking for cyclic paths leading back to the specific topRule\n    // other cyclic paths are ignored, we still need this difference to avoid infinite loops...\n    const validNextSteps = difference(nextNonTerminals, path.concat([topRule]));\n    const errorsFromNextSteps = flatMap(validNextSteps, (currRefRule) => {\n      const newPath = clone(path);\n      newPath.push(currRefRule);\n      return validateNoLeftRecursion(\n        topRule,\n        currRefRule,\n        errMsgProvider,\n        newPath,\n      );\n    });\n\n    return errors.concat(errorsFromNextSteps);\n  }\n}\n\nexport function getFirstNoneTerminal(definition: IProduction[]): Rule[] {\n  let result: Rule[] = [];\n  if (isEmpty(definition)) {\n    return result;\n  }\n  const firstProd = first(definition);\n\n  /* istanbul ignore else */\n  if (firstProd instanceof NonTerminal) {\n    result.push(firstProd.referencedRule);\n  } else if (\n    firstProd instanceof AlternativeGAST ||\n    firstProd instanceof Option ||\n    firstProd instanceof RepetitionMandatory ||\n    firstProd instanceof RepetitionMandatoryWithSeparator ||\n    firstProd instanceof RepetitionWithSeparator ||\n    firstProd instanceof Repetition\n  ) {\n    result = result.concat(\n      getFirstNoneTerminal(<IProduction[]>firstProd.definition),\n    );\n  } else if (firstProd instanceof Alternation) {\n    // each sub definition in alternation is a FLAT\n    result = flatten(\n      map(firstProd.definition, (currSubDef) =>\n        getFirstNoneTerminal((<AlternativeGAST>currSubDef).definition),\n      ),\n    );\n  } else if (firstProd instanceof Terminal) {\n    // nothing to see, move along\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n\n  const isFirstOptional = isOptionalProd(firstProd);\n  const hasMore = definition.length > 1;\n  if (isFirstOptional && hasMore) {\n    const rest = drop(definition);\n    return result.concat(getFirstNoneTerminal(rest));\n  } else {\n    return result;\n  }\n}\n\nclass OrCollector extends GAstVisitor {\n  public alternations: Alternation[] = [];\n\n  public visitAlternation(node: Alternation): void {\n    this.alternations.push(node);\n  }\n}\n\nexport function validateEmptyOrAlternative(\n  topLevelRule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\n): IParserEmptyAlternativeDefinitionError[] {\n  const orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  const ors = orCollector.alternations;\n\n  const errors = flatMap<Alternation, IParserEmptyAlternativeDefinitionError>(\n    ors,\n    (currOr) => {\n      const exceptLast = dropRight(currOr.definition);\n      return flatMap(exceptLast, (currAlternative, currAltIdx) => {\n        const possibleFirstInAlt = nextPossibleTokensAfter(\n          [currAlternative],\n          [],\n          tokenStructuredMatcher,\n          1,\n        );\n        if (isEmpty(possibleFirstInAlt)) {\n          return [\n            {\n              message: errMsgProvider.buildEmptyAlternationError({\n                topLevelRule: topLevelRule,\n                alternation: currOr,\n                emptyChoiceIdx: currAltIdx,\n              }),\n              type: ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,\n              ruleName: topLevelRule.name,\n              occurrence: currOr.idx,\n              alternative: currAltIdx + 1,\n            },\n          ];\n        } else {\n          return [];\n        }\n      });\n    },\n  );\n\n  return errors;\n}\n\nexport function validateAmbiguousAlternationAlternatives(\n  topLevelRule: Rule,\n  globalMaxLookahead: number,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\n): IParserAmbiguousAlternativesDefinitionError[] {\n  const orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  let ors = orCollector.alternations;\n\n  // New Handling of ignoring ambiguities\n  // - https://github.com/chevrotain/chevrotain/issues/869\n  ors = reject(ors, (currOr) => currOr.ignoreAmbiguities === true);\n\n  const errors = flatMap(ors, (currOr: Alternation) => {\n    const currOccurrence = currOr.idx;\n    const actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;\n    const alternatives = getLookaheadPathsForOr(\n      currOccurrence,\n      topLevelRule,\n      actualMaxLookahead,\n      currOr,\n    );\n    const altsAmbiguityErrors = checkAlternativesAmbiguities(\n      alternatives,\n      currOr,\n      topLevelRule,\n      errMsgProvider,\n    );\n    const altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(\n      alternatives,\n      currOr,\n      topLevelRule,\n      errMsgProvider,\n    );\n\n    return altsAmbiguityErrors.concat(altsPrefixAmbiguityErrors);\n  });\n\n  return errors;\n}\n\nexport class RepetitionCollector extends GAstVisitor {\n  public allProductions: (IProductionWithOccurrence & {\n    maxLookahead?: number;\n  })[] = [];\n\n  public visitRepetitionWithSeparator(manySep: RepetitionWithSeparator): void {\n    this.allProductions.push(manySep);\n  }\n\n  public visitRepetitionMandatory(atLeastOne: RepetitionMandatory): void {\n    this.allProductions.push(atLeastOne);\n  }\n\n  public visitRepetitionMandatoryWithSeparator(\n    atLeastOneSep: RepetitionMandatoryWithSeparator,\n  ): void {\n    this.allProductions.push(atLeastOneSep);\n  }\n\n  public visitRepetition(many: Repetition): void {\n    this.allProductions.push(many);\n  }\n}\n\nexport function validateTooManyAlts(\n  topLevelRule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\n): IParserDefinitionError[] {\n  const orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  const ors = orCollector.alternations;\n\n  const errors = flatMap(ors, (currOr) => {\n    if (currOr.definition.length > 255) {\n      return [\n        {\n          message: errMsgProvider.buildTooManyAlternativesError({\n            topLevelRule: topLevelRule,\n            alternation: currOr,\n          }),\n          type: ParserDefinitionErrorType.TOO_MANY_ALTS,\n          ruleName: topLevelRule.name,\n          occurrence: currOr.idx,\n        },\n      ];\n    } else {\n      return [];\n    }\n  });\n\n  return errors;\n}\n\nexport function validateSomeNonEmptyLookaheadPath(\n  topLevelRules: Rule[],\n  maxLookahead: number,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\n): IParserDefinitionError[] {\n  const errors: IParserDefinitionError[] = [];\n  forEach(topLevelRules, (currTopRule) => {\n    const collectorVisitor = new RepetitionCollector();\n    currTopRule.accept(collectorVisitor);\n    const allRuleProductions = collectorVisitor.allProductions;\n    forEach(allRuleProductions, (currProd) => {\n      const prodType = getProdType(currProd);\n      const actualMaxLookahead = currProd.maxLookahead || maxLookahead;\n      const currOccurrence = currProd.idx;\n      const paths = getLookaheadPathsForOptionalProd(\n        currOccurrence,\n        currTopRule,\n        prodType,\n        actualMaxLookahead,\n      );\n      const pathsInsideProduction = paths[0];\n      if (isEmpty(flatten(pathsInsideProduction))) {\n        const errMsg = errMsgProvider.buildEmptyRepetitionError({\n          topLevelRule: currTopRule,\n          repetition: currProd,\n        });\n        errors.push({\n          message: errMsg,\n          type: ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,\n          ruleName: currTopRule.name,\n        });\n      }\n    });\n  });\n\n  return errors;\n}\n\nexport interface IAmbiguityDescriptor {\n  alts: number[];\n  path: TokenType[];\n}\n\nfunction checkAlternativesAmbiguities(\n  alternatives: Alternative[],\n  alternation: Alternation,\n  rule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\n): IParserAmbiguousAlternativesDefinitionError[] {\n  const foundAmbiguousPaths: Alternative = [];\n  const identicalAmbiguities = reduce(\n    alternatives,\n    (result, currAlt, currAltIdx) => {\n      // ignore (skip) ambiguities with this alternative\n      if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {\n        return result;\n      }\n\n      forEach(currAlt, (currPath) => {\n        const altsCurrPathAppearsIn = [currAltIdx];\n        forEach(alternatives, (currOtherAlt, currOtherAltIdx) => {\n          if (\n            currAltIdx !== currOtherAltIdx &&\n            containsPath(currOtherAlt, currPath) &&\n            // ignore (skip) ambiguities with this \"other\" alternative\n            alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true\n          ) {\n            altsCurrPathAppearsIn.push(currOtherAltIdx);\n          }\n        });\n\n        if (\n          altsCurrPathAppearsIn.length > 1 &&\n          !containsPath(foundAmbiguousPaths, currPath)\n        ) {\n          foundAmbiguousPaths.push(currPath);\n          result.push({\n            alts: altsCurrPathAppearsIn,\n            path: currPath,\n          });\n        }\n      });\n      return result;\n    },\n    [] as { alts: number[]; path: TokenType[] }[],\n  );\n\n  const currErrors = map(identicalAmbiguities, (currAmbDescriptor) => {\n    const ambgIndices = map(\n      currAmbDescriptor.alts,\n      (currAltIdx) => currAltIdx + 1,\n    );\n\n    const currMessage = errMsgProvider.buildAlternationAmbiguityError({\n      topLevelRule: rule,\n      alternation: alternation,\n      ambiguityIndices: ambgIndices,\n      prefixPath: currAmbDescriptor.path,\n    });\n\n    return {\n      message: currMessage,\n      type: ParserDefinitionErrorType.AMBIGUOUS_ALTS,\n      ruleName: rule.name,\n      occurrence: alternation.idx,\n      alternatives: currAmbDescriptor.alts,\n    };\n  });\n\n  return currErrors;\n}\n\nexport function checkPrefixAlternativesAmbiguities(\n  alternatives: Alternative[],\n  alternation: Alternation,\n  rule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\n): IParserAmbiguousAlternativesDefinitionError[] {\n  // flatten\n  const pathsAndIndices = reduce(\n    alternatives,\n    (result, currAlt, idx) => {\n      const currPathsAndIdx = map(currAlt, (currPath) => {\n        return { idx: idx, path: currPath };\n      });\n      return result.concat(currPathsAndIdx);\n    },\n    [] as { idx: number; path: TokenType[] }[],\n  );\n\n  const errors = compact(\n    flatMap(pathsAndIndices, (currPathAndIdx) => {\n      const alternativeGast = alternation.definition[currPathAndIdx.idx];\n      // ignore (skip) ambiguities with this alternative\n      if (alternativeGast.ignoreAmbiguities === true) {\n        return [];\n      }\n      const targetIdx = currPathAndIdx.idx;\n      const targetPath = currPathAndIdx.path;\n\n      const prefixAmbiguitiesPathsAndIndices = filter(\n        pathsAndIndices,\n        (searchPathAndIdx) => {\n          // prefix ambiguity can only be created from lower idx (higher priority) path\n          return (\n            // ignore (skip) ambiguities with this \"other\" alternative\n            alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !==\n              true &&\n            searchPathAndIdx.idx < targetIdx &&\n            // checking for strict prefix because identical lookaheads\n            // will be be detected using a different validation.\n            isStrictPrefixOfPath(searchPathAndIdx.path, targetPath)\n          );\n        },\n      );\n\n      const currPathPrefixErrors = map(\n        prefixAmbiguitiesPathsAndIndices,\n        (currAmbPathAndIdx): IParserAmbiguousAlternativesDefinitionError => {\n          const ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];\n          const occurrence = alternation.idx === 0 ? \"\" : alternation.idx;\n\n          const message = errMsgProvider.buildAlternationPrefixAmbiguityError({\n            topLevelRule: rule,\n            alternation: alternation,\n            ambiguityIndices: ambgIndices,\n            prefixPath: currAmbPathAndIdx.path,\n          });\n          return {\n            message: message,\n            type: ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,\n            ruleName: rule.name,\n            occurrence: occurrence,\n            alternatives: ambgIndices,\n          };\n        },\n      );\n\n      return currPathPrefixErrors;\n    }),\n  );\n\n  return errors;\n}\n\nfunction checkTerminalAndNoneTerminalsNameSpace(\n  topLevels: Rule[],\n  tokenTypes: TokenType[],\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\n): IParserDefinitionError[] {\n  const errors: IParserDefinitionError[] = [];\n\n  const tokenNames = map(tokenTypes, (currToken) => currToken.name);\n\n  forEach(topLevels, (currRule) => {\n    const currRuleName = currRule.name;\n    if (includes(tokenNames, currRuleName)) {\n      const errMsg = errMsgProvider.buildNamespaceConflictError(currRule);\n\n      errors.push({\n        message: errMsg,\n        type: ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,\n        ruleName: currRuleName,\n      });\n    }\n  });\n\n  return errors;\n}\n","import { Rule } from \"@chevrotain/gast\";\nimport { defaults, forEach } from \"lodash-es\";\nimport { resolveGrammar as orgResolveGrammar } from \"../resolver.js\";\nimport { validateGrammar as orgValidateGrammar } from \"../checks.js\";\nimport {\n  defaultGrammarResolverErrorProvider,\n  defaultGrammarValidatorErrorProvider,\n} from \"../../errors_public.js\";\nimport { TokenType } from \"@chevrotain/types\";\nimport {\n  IGrammarResolverErrorMessageProvider,\n  IGrammarValidatorErrorMessageProvider,\n  IParserDefinitionError,\n} from \"../types.js\";\n\ntype ResolveGrammarOpts = {\n  rules: Rule[];\n  errMsgProvider?: IGrammarResolverErrorMessageProvider;\n};\nexport function resolveGrammar(\n  options: ResolveGrammarOpts,\n): IParserDefinitionError[] {\n  const actualOptions: Required<ResolveGrammarOpts> = defaults(options, {\n    errMsgProvider: defaultGrammarResolverErrorProvider,\n  });\n\n  const topRulesTable: { [ruleName: string]: Rule } = {};\n  forEach(options.rules, (rule) => {\n    topRulesTable[rule.name] = rule;\n  });\n  return orgResolveGrammar(topRulesTable, actualOptions.errMsgProvider);\n}\n\nexport function validateGrammar(options: {\n  rules: Rule[];\n  tokenTypes: TokenType[];\n  grammarName: string;\n  errMsgProvider: IGrammarValidatorErrorMessageProvider;\n}): IParserDefinitionError[] {\n  options = defaults(options, {\n    errMsgProvider: defaultGrammarValidatorErrorProvider,\n  });\n\n  return orgValidateGrammar(\n    options.rules,\n    options.tokenTypes,\n    options.errMsgProvider,\n    options.grammarName,\n  );\n}\n","import { includes } from \"lodash-es\";\nimport {\n  IRecognitionException,\n  IRecognizerContext,\n  IToken,\n} from \"@chevrotain/types\";\n\nconst MISMATCHED_TOKEN_EXCEPTION = \"MismatchedTokenException\";\nconst NO_VIABLE_ALT_EXCEPTION = \"NoViableAltException\";\nconst EARLY_EXIT_EXCEPTION = \"EarlyExitException\";\nconst NOT_ALL_INPUT_PARSED_EXCEPTION = \"NotAllInputParsedException\";\n\nconst RECOGNITION_EXCEPTION_NAMES = [\n  MISMATCHED_TOKEN_EXCEPTION,\n  NO_VIABLE_ALT_EXCEPTION,\n  EARLY_EXIT_EXCEPTION,\n  NOT_ALL_INPUT_PARSED_EXCEPTION,\n];\n\nObject.freeze(RECOGNITION_EXCEPTION_NAMES);\n\n// hacks to bypass no support for custom Errors in javascript/typescript\nexport function isRecognitionException(error: Error) {\n  // can't do instanceof on hacked custom js exceptions\n  return includes(RECOGNITION_EXCEPTION_NAMES, error.name);\n}\n\nabstract class RecognitionException\n  extends Error\n  implements IRecognitionException\n{\n  context: IRecognizerContext;\n  resyncedTokens: IToken[] = [];\n\n  protected constructor(\n    message: string,\n    public token: IToken,\n  ) {\n    super(message);\n\n    // fix prototype chain when typescript target is ES5\n    Object.setPrototypeOf(this, new.target.prototype);\n\n    /* istanbul ignore next - V8 workaround to remove constructor from stacktrace when typescript target is ES5 */\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n}\n\nexport class MismatchedTokenException extends RecognitionException {\n  constructor(\n    message: string,\n    token: IToken,\n    public previousToken: IToken,\n  ) {\n    super(message, token);\n    this.name = MISMATCHED_TOKEN_EXCEPTION;\n  }\n}\n\nexport class NoViableAltException extends RecognitionException {\n  constructor(\n    message: string,\n    token: IToken,\n    public previousToken: IToken,\n  ) {\n    super(message, token);\n    this.name = NO_VIABLE_ALT_EXCEPTION;\n  }\n}\n\nexport class NotAllInputParsedException extends RecognitionException {\n  constructor(message: string, token: IToken) {\n    super(message, token);\n    this.name = NOT_ALL_INPUT_PARSED_EXCEPTION;\n  }\n}\n\nexport class EarlyExitException extends RecognitionException {\n  constructor(\n    message: string,\n    token: IToken,\n    public previousToken: IToken,\n  ) {\n    super(message, token);\n    this.name = EARLY_EXIT_EXCEPTION;\n  }\n}\n","import {\n  createTokenInstance,\n  EOF,\n  tokenMatcher,\n} from \"../../../scan/tokens_public.js\";\nimport {\n  AbstractNextTerminalAfterProductionWalker,\n  IFirstAfterRepetition,\n} from \"../../grammar/interpreter.js\";\nimport {\n  clone,\n  dropRight,\n  find,\n  flatten,\n  has,\n  includes,\n  isEmpty,\n  map,\n} from \"lodash-es\";\nimport {\n  IParserConfig,\n  IToken,\n  ITokenGrammarPath,\n  TokenType,\n} from \"@chevrotain/types\";\nimport { MismatchedTokenException } from \"../../exceptions_public.js\";\nimport { IN } from \"../../constants.js\";\nimport { MixedInParser } from \"./parser_traits.js\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser.js\";\n\nexport const EOF_FOLLOW_KEY: any = {};\n\nexport interface IFollowKey {\n  ruleName: string;\n  idxInCallingRule: number;\n  inRule: string;\n}\n\nexport const IN_RULE_RECOVERY_EXCEPTION = \"InRuleRecoveryException\";\n\nexport class InRuleRecoveryException extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = IN_RULE_RECOVERY_EXCEPTION;\n  }\n}\n\n/**\n * This trait is responsible for the error recovery and fault tolerant logic\n */\nexport class Recoverable {\n  recoveryEnabled: boolean;\n  firstAfterRepMap: Record<string, IFirstAfterRepetition>;\n  resyncFollows: Record<string, TokenType[]>;\n\n  initRecoverable(config: IParserConfig) {\n    this.firstAfterRepMap = {};\n    this.resyncFollows = {};\n\n    this.recoveryEnabled = has(config, \"recoveryEnabled\")\n      ? (config.recoveryEnabled as boolean) // assumes end user provides the correct config value/type\n      : DEFAULT_PARSER_CONFIG.recoveryEnabled;\n\n    // performance optimization, NOOP will be inlined which\n    // effectively means that this optional feature does not exist\n    // when not used.\n    if (this.recoveryEnabled) {\n      this.attemptInRepetitionRecovery = attemptInRepetitionRecovery;\n    }\n  }\n\n  public getTokenToInsert(tokType: TokenType): IToken {\n    const tokToInsert = createTokenInstance(\n      tokType,\n      \"\",\n      NaN,\n      NaN,\n      NaN,\n      NaN,\n      NaN,\n      NaN,\n    );\n    tokToInsert.isInsertedInRecovery = true;\n    return tokToInsert;\n  }\n\n  public canTokenTypeBeInsertedInRecovery(tokType: TokenType): boolean {\n    return true;\n  }\n\n  public canTokenTypeBeDeletedInRecovery(tokType: TokenType): boolean {\n    return true;\n  }\n\n  tryInRepetitionRecovery(\n    this: MixedInParser,\n    grammarRule: Function,\n    grammarRuleArgs: any[],\n    lookAheadFunc: () => boolean,\n    expectedTokType: TokenType,\n  ): void {\n    // TODO: can the resyncTokenType be cached?\n    const reSyncTokType = this.findReSyncTokenType();\n    const savedLexerState = this.exportLexerState();\n    const resyncedTokens: IToken[] = [];\n    let passedResyncPoint = false;\n\n    const nextTokenWithoutResync = this.LA(1);\n    let currToken = this.LA(1);\n\n    const generateErrorMessage = () => {\n      const previousToken = this.LA(0);\n      // we are preemptively re-syncing before an error has been detected, therefor we must reproduce\n      // the error that would have been thrown\n      const msg = this.errorMessageProvider.buildMismatchTokenMessage({\n        expected: expectedTokType,\n        actual: nextTokenWithoutResync,\n        previous: previousToken,\n        ruleName: this.getCurrRuleFullName(),\n      });\n      const error = new MismatchedTokenException(\n        msg,\n        nextTokenWithoutResync,\n        this.LA(0),\n      );\n      // the first token here will be the original cause of the error, this is not part of the resyncedTokens property.\n      error.resyncedTokens = dropRight(resyncedTokens);\n      this.SAVE_ERROR(error);\n    };\n\n    while (!passedResyncPoint) {\n      // re-synced to a point where we can safely exit the repetition/\n      if (this.tokenMatcher(currToken, expectedTokType)) {\n        generateErrorMessage();\n        return; // must return here to avoid reverting the inputIdx\n      } else if (lookAheadFunc.call(this)) {\n        // we skipped enough tokens so we can resync right back into another iteration of the repetition grammar rule\n        generateErrorMessage();\n        // recursive invocation in other to support multiple re-syncs in the same top level repetition grammar rule\n        grammarRule.apply(this, grammarRuleArgs);\n        return; // must return here to avoid reverting the inputIdx\n      } else if (this.tokenMatcher(currToken, reSyncTokType)) {\n        passedResyncPoint = true;\n      } else {\n        currToken = this.SKIP_TOKEN();\n        this.addToResyncTokens(currToken, resyncedTokens);\n      }\n    }\n\n    // we were unable to find a CLOSER point to resync inside the Repetition, reset the state.\n    // The parsing exception we were trying to prevent will happen in the NEXT parsing step. it may be handled by\n    // \"between rules\" resync recovery later in the flow.\n    this.importLexerState(savedLexerState);\n  }\n\n  shouldInRepetitionRecoveryBeTried(\n    this: MixedInParser,\n    expectTokAfterLastMatch: TokenType,\n    nextTokIdx: number,\n    notStuck: boolean | undefined,\n  ): boolean {\n    // Edge case of arriving from a MANY repetition which is stuck\n    // Attempting recovery in this case could cause an infinite loop\n    if (notStuck === false) {\n      return false;\n    }\n\n    // no need to recover, next token is what we expect...\n    if (this.tokenMatcher(this.LA(1), expectTokAfterLastMatch)) {\n      return false;\n    }\n\n    // error recovery is disabled during backtracking as it can make the parser ignore a valid grammar path\n    // and prefer some backtracking path that includes recovered errors.\n    if (this.isBackTracking()) {\n      return false;\n    }\n\n    // if we can perform inRule recovery (single token insertion or deletion) we always prefer that recovery algorithm\n    // because if it works, it makes the least amount of changes to the input stream (greedy algorithm)\n    //noinspection RedundantIfStatementJS\n    if (\n      this.canPerformInRuleRecovery(\n        expectTokAfterLastMatch,\n        this.getFollowsForInRuleRecovery(expectTokAfterLastMatch, nextTokIdx),\n      )\n    ) {\n      return false;\n    }\n\n    return true;\n  }\n\n  // Error Recovery functionality\n  getFollowsForInRuleRecovery(\n    this: MixedInParser,\n    tokType: TokenType,\n    tokIdxInRule: number,\n  ): TokenType[] {\n    const grammarPath = this.getCurrentGrammarPath(tokType, tokIdxInRule);\n    const follows = this.getNextPossibleTokenTypes(grammarPath);\n    return follows;\n  }\n\n  tryInRuleRecovery(\n    this: MixedInParser,\n    expectedTokType: TokenType,\n    follows: TokenType[],\n  ): IToken {\n    if (this.canRecoverWithSingleTokenInsertion(expectedTokType, follows)) {\n      const tokToInsert = this.getTokenToInsert(expectedTokType);\n      return tokToInsert;\n    }\n\n    if (this.canRecoverWithSingleTokenDeletion(expectedTokType)) {\n      const nextTok = this.SKIP_TOKEN();\n      this.consumeToken();\n      return nextTok;\n    }\n\n    throw new InRuleRecoveryException(\"sad sad panda\");\n  }\n\n  canPerformInRuleRecovery(\n    this: MixedInParser,\n    expectedToken: TokenType,\n    follows: TokenType[],\n  ): boolean {\n    return (\n      this.canRecoverWithSingleTokenInsertion(expectedToken, follows) ||\n      this.canRecoverWithSingleTokenDeletion(expectedToken)\n    );\n  }\n\n  canRecoverWithSingleTokenInsertion(\n    this: MixedInParser,\n    expectedTokType: TokenType,\n    follows: TokenType[],\n  ): boolean {\n    if (!this.canTokenTypeBeInsertedInRecovery(expectedTokType)) {\n      return false;\n    }\n\n    // must know the possible following tokens to perform single token insertion\n    if (isEmpty(follows)) {\n      return false;\n    }\n\n    const mismatchedTok = this.LA(1);\n    const isMisMatchedTokInFollows =\n      find(follows, (possibleFollowsTokType: TokenType) => {\n        return this.tokenMatcher(mismatchedTok, possibleFollowsTokType);\n      }) !== undefined;\n\n    return isMisMatchedTokInFollows;\n  }\n\n  canRecoverWithSingleTokenDeletion(\n    this: MixedInParser,\n    expectedTokType: TokenType,\n  ): boolean {\n    if (!this.canTokenTypeBeDeletedInRecovery(expectedTokType)) {\n      return false;\n    }\n\n    const isNextTokenWhatIsExpected = this.tokenMatcher(\n      this.LA(2),\n      expectedTokType,\n    );\n    return isNextTokenWhatIsExpected;\n  }\n\n  isInCurrentRuleReSyncSet(\n    this: MixedInParser,\n    tokenTypeIdx: TokenType,\n  ): boolean {\n    const followKey = this.getCurrFollowKey();\n    const currentRuleReSyncSet = this.getFollowSetFromFollowKey(followKey);\n    return includes(currentRuleReSyncSet, tokenTypeIdx);\n  }\n\n  findReSyncTokenType(this: MixedInParser): TokenType {\n    const allPossibleReSyncTokTypes = this.flattenFollowSet();\n    // this loop will always terminate as EOF is always in the follow stack and also always (virtually) in the input\n    let nextToken = this.LA(1);\n    let k = 2;\n    while (true) {\n      const foundMatch = find(allPossibleReSyncTokTypes, (resyncTokType) => {\n        const canMatch = tokenMatcher(nextToken, resyncTokType);\n        return canMatch;\n      });\n      if (foundMatch !== undefined) {\n        return foundMatch;\n      }\n      nextToken = this.LA(k);\n      k++;\n    }\n  }\n\n  getCurrFollowKey(this: MixedInParser): IFollowKey {\n    // the length is at least one as we always add the ruleName to the stack before invoking the rule.\n    if (this.RULE_STACK.length === 1) {\n      return EOF_FOLLOW_KEY;\n    }\n    const currRuleShortName = this.getLastExplicitRuleShortName();\n    const currRuleIdx = this.getLastExplicitRuleOccurrenceIndex();\n    const prevRuleShortName = this.getPreviousExplicitRuleShortName();\n\n    return {\n      ruleName: this.shortRuleNameToFullName(currRuleShortName),\n      idxInCallingRule: currRuleIdx,\n      inRule: this.shortRuleNameToFullName(prevRuleShortName),\n    };\n  }\n\n  buildFullFollowKeyStack(this: MixedInParser): IFollowKey[] {\n    const explicitRuleStack = this.RULE_STACK;\n    const explicitOccurrenceStack = this.RULE_OCCURRENCE_STACK;\n\n    return map(explicitRuleStack, (ruleName, idx) => {\n      if (idx === 0) {\n        return EOF_FOLLOW_KEY;\n      }\n      return {\n        ruleName: this.shortRuleNameToFullName(ruleName),\n        idxInCallingRule: explicitOccurrenceStack[idx],\n        inRule: this.shortRuleNameToFullName(explicitRuleStack[idx - 1]),\n      };\n    });\n  }\n\n  flattenFollowSet(this: MixedInParser): TokenType[] {\n    const followStack = map(this.buildFullFollowKeyStack(), (currKey) => {\n      return this.getFollowSetFromFollowKey(currKey);\n    });\n    return <any>flatten(followStack);\n  }\n\n  getFollowSetFromFollowKey(\n    this: MixedInParser,\n    followKey: IFollowKey,\n  ): TokenType[] {\n    if (followKey === EOF_FOLLOW_KEY) {\n      return [EOF];\n    }\n\n    const followName =\n      followKey.ruleName + followKey.idxInCallingRule + IN + followKey.inRule;\n\n    return this.resyncFollows[followName];\n  }\n\n  // It does not make any sense to include a virtual EOF token in the list of resynced tokens\n  // as EOF does not really exist and thus does not contain any useful information (line/column numbers)\n  addToResyncTokens(\n    this: MixedInParser,\n    token: IToken,\n    resyncTokens: IToken[],\n  ): IToken[] {\n    if (!this.tokenMatcher(token, EOF)) {\n      resyncTokens.push(token);\n    }\n    return resyncTokens;\n  }\n\n  reSyncTo(this: MixedInParser, tokType: TokenType): IToken[] {\n    const resyncedTokens: IToken[] = [];\n    let nextTok = this.LA(1);\n    while (this.tokenMatcher(nextTok, tokType) === false) {\n      nextTok = this.SKIP_TOKEN();\n      this.addToResyncTokens(nextTok, resyncedTokens);\n    }\n    // the last token is not part of the error.\n    return dropRight(resyncedTokens);\n  }\n\n  attemptInRepetitionRecovery(\n    this: MixedInParser,\n    prodFunc: Function,\n    args: any[],\n    lookaheadFunc: () => boolean,\n    dslMethodIdx: number,\n    prodOccurrence: number,\n    nextToksWalker: typeof AbstractNextTerminalAfterProductionWalker,\n    notStuck?: boolean,\n  ): void {\n    // by default this is a NO-OP\n    // The actual implementation is with the function(not method) below\n  }\n\n  getCurrentGrammarPath(\n    this: MixedInParser,\n    tokType: TokenType,\n    tokIdxInRule: number,\n  ): ITokenGrammarPath {\n    const pathRuleStack: string[] = this.getHumanReadableRuleStack();\n    const pathOccurrenceStack: number[] = clone(this.RULE_OCCURRENCE_STACK);\n    const grammarPath: any = {\n      ruleStack: pathRuleStack,\n      occurrenceStack: pathOccurrenceStack,\n      lastTok: tokType,\n      lastTokOccurrence: tokIdxInRule,\n    };\n\n    return grammarPath;\n  }\n  getHumanReadableRuleStack(this: MixedInParser): string[] {\n    return map(this.RULE_STACK, (currShortName) =>\n      this.shortRuleNameToFullName(currShortName),\n    );\n  }\n}\n\nexport function attemptInRepetitionRecovery(\n  this: MixedInParser,\n  prodFunc: Function,\n  args: any[],\n  lookaheadFunc: () => boolean,\n  dslMethodIdx: number,\n  prodOccurrence: number,\n  nextToksWalker: typeof AbstractNextTerminalAfterProductionWalker,\n  notStuck?: boolean,\n): void {\n  const key = this.getKeyForAutomaticLookahead(dslMethodIdx, prodOccurrence);\n  let firstAfterRepInfo = this.firstAfterRepMap[key];\n  if (firstAfterRepInfo === undefined) {\n    const currRuleName = this.getCurrRuleFullName();\n    const ruleGrammar = this.getGAstProductions()[currRuleName];\n    const walker: AbstractNextTerminalAfterProductionWalker =\n      new nextToksWalker(ruleGrammar, prodOccurrence);\n    firstAfterRepInfo = walker.startWalking();\n    this.firstAfterRepMap[key] = firstAfterRepInfo;\n  }\n\n  let expectTokAfterLastMatch = firstAfterRepInfo.token;\n  let nextTokIdx = firstAfterRepInfo.occurrence;\n  const isEndOfRule = firstAfterRepInfo.isEndOfRule;\n\n  // special edge case of a TOP most repetition after which the input should END.\n  // this will force an attempt for inRule recovery in that scenario.\n  if (\n    this.RULE_STACK.length === 1 &&\n    isEndOfRule &&\n    expectTokAfterLastMatch === undefined\n  ) {\n    expectTokAfterLastMatch = EOF;\n    nextTokIdx = 1;\n  }\n\n  // We don't have anything to re-sync to...\n  // this condition was extracted from `shouldInRepetitionRecoveryBeTried` to act as a type-guard\n  if (expectTokAfterLastMatch === undefined || nextTokIdx === undefined) {\n    return;\n  }\n\n  if (\n    this.shouldInRepetitionRecoveryBeTried(\n      expectTokAfterLastMatch,\n      nextTokIdx,\n      notStuck,\n    )\n  ) {\n    // TODO: performance optimization: instead of passing the original args here, we modify\n    // the args param (or create a new one) and make sure the lookahead func is explicitly provided\n    // to avoid searching the cache for it once more.\n    this.tryInRepetitionRecovery(\n      prodFunc,\n      args,\n      lookaheadFunc,\n      expectTokAfterLastMatch,\n    );\n  }\n}\n","// Lookahead keys are 32Bit integers in the form\n// TTTTTTTT-ZZZZZZZZZZZZ-YYYY-XXXXXXXX\n// XXXX -> Occurrence Index bitmap.\n// YYYY -> DSL Method Type bitmap.\n// ZZZZZZZZZZZZZZZ -> Rule short Index bitmap.\n// TTTTTTTTT -> alternation alternative index bitmap\n\nexport const BITS_FOR_METHOD_TYPE = 4;\nexport const BITS_FOR_OCCURRENCE_IDX = 8;\nexport const BITS_FOR_RULE_IDX = 12;\n// TODO: validation, this means that there may at most 2^8 --> 256 alternatives for an alternation.\nexport const BITS_FOR_ALT_IDX = 8;\n\n// short string used as part of mapping keys.\n// being short improves the performance when composing KEYS for maps out of these\n// The 5 - 8 bits (16 possible values, are reserved for the DSL method indices)\nexport const OR_IDX = 1 << BITS_FOR_OCCURRENCE_IDX;\nexport const OPTION_IDX = 2 << BITS_FOR_OCCURRENCE_IDX;\nexport const MANY_IDX = 3 << BITS_FOR_OCCURRENCE_IDX;\nexport const AT_LEAST_ONE_IDX = 4 << BITS_FOR_OCCURRENCE_IDX;\nexport const MANY_SEP_IDX = 5 << BITS_FOR_OCCURRENCE_IDX;\nexport const AT_LEAST_ONE_SEP_IDX = 6 << BITS_FOR_OCCURRENCE_IDX;\n\n// this actually returns a number, but it is always used as a string (object prop key)\nexport function getKeyForAutomaticLookahead(\n  ruleIdx: number,\n  dslMethodIdx: number,\n  occurrence: number,\n): number {\n  return occurrence | dslMethodIdx | ruleIdx;\n}\n\nconst BITS_START_FOR_ALT_IDX = 32 - BITS_FOR_ALT_IDX;\n","import {\n  ILookaheadStrategy,\n  ILookaheadValidationError,\n  IOrAlt,\n  OptionalProductionType,\n  Rule,\n  TokenType,\n} from \"@chevrotain/types\";\nimport { flatMap, isEmpty } from \"lodash-es\";\nimport { defaultGrammarValidatorErrorProvider } from \"../errors_public.js\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser/parser.js\";\nimport {\n  validateAmbiguousAlternationAlternatives,\n  validateEmptyOrAlternative,\n  validateNoLeftRecursion,\n  validateSomeNonEmptyLookaheadPath,\n} from \"./checks.js\";\nimport {\n  buildAlternativesLookAheadFunc,\n  buildLookaheadFuncForOptionalProd,\n  buildLookaheadFuncForOr,\n  buildSingleAlternativeLookaheadFunction,\n  getProdType,\n} from \"./lookahead.js\";\nimport { IParserDefinitionError } from \"./types.js\";\n\nexport class LLkLookaheadStrategy implements ILookaheadStrategy {\n  readonly maxLookahead: number;\n\n  constructor(options?: { maxLookahead?: number }) {\n    this.maxLookahead =\n      options?.maxLookahead ?? DEFAULT_PARSER_CONFIG.maxLookahead;\n  }\n\n  validate(options: {\n    rules: Rule[];\n    tokenTypes: TokenType[];\n    grammarName: string;\n  }): ILookaheadValidationError[] {\n    const leftRecursionErrors = this.validateNoLeftRecursion(options.rules);\n\n    if (isEmpty(leftRecursionErrors)) {\n      const emptyAltErrors = this.validateEmptyOrAlternatives(options.rules);\n      const ambiguousAltsErrors = this.validateAmbiguousAlternationAlternatives(\n        options.rules,\n        this.maxLookahead,\n      );\n      const emptyRepetitionErrors = this.validateSomeNonEmptyLookaheadPath(\n        options.rules,\n        this.maxLookahead,\n      );\n      const allErrors = [\n        ...leftRecursionErrors,\n        ...emptyAltErrors,\n        ...ambiguousAltsErrors,\n        ...emptyRepetitionErrors,\n      ];\n      return allErrors;\n    }\n    return leftRecursionErrors;\n  }\n\n  validateNoLeftRecursion(rules: Rule[]): IParserDefinitionError[] {\n    return flatMap(rules, (currTopRule) =>\n      validateNoLeftRecursion(\n        currTopRule,\n        currTopRule,\n        defaultGrammarValidatorErrorProvider,\n      ),\n    );\n  }\n\n  validateEmptyOrAlternatives(rules: Rule[]): IParserDefinitionError[] {\n    return flatMap(rules, (currTopRule) =>\n      validateEmptyOrAlternative(\n        currTopRule,\n        defaultGrammarValidatorErrorProvider,\n      ),\n    );\n  }\n\n  validateAmbiguousAlternationAlternatives(\n    rules: Rule[],\n    maxLookahead: number,\n  ): IParserDefinitionError[] {\n    return flatMap(rules, (currTopRule) =>\n      validateAmbiguousAlternationAlternatives(\n        currTopRule,\n        maxLookahead,\n        defaultGrammarValidatorErrorProvider,\n      ),\n    );\n  }\n\n  validateSomeNonEmptyLookaheadPath(\n    rules: Rule[],\n    maxLookahead: number,\n  ): IParserDefinitionError[] {\n    return validateSomeNonEmptyLookaheadPath(\n      rules,\n      maxLookahead,\n      defaultGrammarValidatorErrorProvider,\n    );\n  }\n\n  buildLookaheadForAlternation(options: {\n    prodOccurrence: number;\n    rule: Rule;\n    maxLookahead: number;\n    hasPredicates: boolean;\n    dynamicTokensEnabled: boolean;\n  }): (orAlts?: IOrAlt<any>[] | undefined) => number | undefined {\n    return buildLookaheadFuncForOr(\n      options.prodOccurrence,\n      options.rule,\n      options.maxLookahead,\n      options.hasPredicates,\n      options.dynamicTokensEnabled,\n      buildAlternativesLookAheadFunc,\n    );\n  }\n\n  buildLookaheadForOptional(options: {\n    prodOccurrence: number;\n    prodType: OptionalProductionType;\n    rule: Rule;\n    maxLookahead: number;\n    dynamicTokensEnabled: boolean;\n  }): () => boolean {\n    return buildLookaheadFuncForOptionalProd(\n      options.prodOccurrence,\n      options.rule,\n      options.maxLookahead,\n      options.dynamicTokensEnabled,\n      getProdType(options.prodType),\n      buildSingleAlternativeLookaheadFunction,\n    );\n  }\n}\n","import { forEach, has } from \"lodash-es\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser.js\";\nimport {\n  ILookaheadStrategy,\n  IParserConfig,\n  OptionalProductionType,\n} from \"@chevrotain/types\";\nimport {\n  AT_LEAST_ONE_IDX,\n  AT_LEAST_ONE_SEP_IDX,\n  getKeyForAutomaticLookahead,\n  MANY_IDX,\n  MANY_SEP_IDX,\n  OPTION_IDX,\n  OR_IDX,\n} from \"../../grammar/keys.js\";\nimport { MixedInParser } from \"./parser_traits.js\";\nimport {\n  Alternation,\n  GAstVisitor,\n  getProductionDslName,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Rule,\n} from \"@chevrotain/gast\";\nimport { LLkLookaheadStrategy } from \"../../grammar/llk_lookahead.js\";\n\n/**\n * Trait responsible for the lookahead related utilities and optimizations.\n */\nexport class LooksAhead {\n  maxLookahead: number;\n  lookAheadFuncsCache: any;\n  dynamicTokensEnabled: boolean;\n  lookaheadStrategy: ILookaheadStrategy;\n\n  initLooksAhead(config: IParserConfig) {\n    this.dynamicTokensEnabled = has(config, \"dynamicTokensEnabled\")\n      ? (config.dynamicTokensEnabled as boolean) // assumes end user provides the correct config value/type\n      : DEFAULT_PARSER_CONFIG.dynamicTokensEnabled;\n\n    this.maxLookahead = has(config, \"maxLookahead\")\n      ? (config.maxLookahead as number) // assumes end user provides the correct config value/type\n      : DEFAULT_PARSER_CONFIG.maxLookahead;\n\n    this.lookaheadStrategy = has(config, \"lookaheadStrategy\")\n      ? (config.lookaheadStrategy as ILookaheadStrategy) // assumes end user provides the correct config value/type\n      : new LLkLookaheadStrategy({ maxLookahead: this.maxLookahead });\n\n    this.lookAheadFuncsCache = new Map();\n  }\n\n  preComputeLookaheadFunctions(this: MixedInParser, rules: Rule[]): void {\n    forEach(rules, (currRule) => {\n      this.TRACE_INIT(`${currRule.name} Rule Lookahead`, () => {\n        const {\n          alternation,\n          repetition,\n          option,\n          repetitionMandatory,\n          repetitionMandatoryWithSeparator,\n          repetitionWithSeparator,\n        } = collectMethods(currRule);\n\n        forEach(alternation, (currProd) => {\n          const prodIdx = currProd.idx === 0 ? \"\" : currProd.idx;\n          this.TRACE_INIT(`${getProductionDslName(currProd)}${prodIdx}`, () => {\n            const laFunc = this.lookaheadStrategy.buildLookaheadForAlternation({\n              prodOccurrence: currProd.idx,\n              rule: currRule,\n              maxLookahead: currProd.maxLookahead || this.maxLookahead,\n              hasPredicates: currProd.hasPredicates,\n              dynamicTokensEnabled: this.dynamicTokensEnabled,\n            });\n\n            const key = getKeyForAutomaticLookahead(\n              this.fullRuleNameToShort[currRule.name],\n              OR_IDX,\n              currProd.idx,\n            );\n            this.setLaFuncCache(key, laFunc);\n          });\n        });\n\n        forEach(repetition, (currProd) => {\n          this.computeLookaheadFunc(\n            currRule,\n            currProd.idx,\n            MANY_IDX,\n            \"Repetition\",\n            currProd.maxLookahead,\n            getProductionDslName(currProd),\n          );\n        });\n\n        forEach(option, (currProd) => {\n          this.computeLookaheadFunc(\n            currRule,\n            currProd.idx,\n            OPTION_IDX,\n            \"Option\",\n            currProd.maxLookahead,\n            getProductionDslName(currProd),\n          );\n        });\n\n        forEach(repetitionMandatory, (currProd) => {\n          this.computeLookaheadFunc(\n            currRule,\n            currProd.idx,\n            AT_LEAST_ONE_IDX,\n            \"RepetitionMandatory\",\n            currProd.maxLookahead,\n            getProductionDslName(currProd),\n          );\n        });\n\n        forEach(repetitionMandatoryWithSeparator, (currProd) => {\n          this.computeLookaheadFunc(\n            currRule,\n            currProd.idx,\n            AT_LEAST_ONE_SEP_IDX,\n            \"RepetitionMandatoryWithSeparator\",\n            currProd.maxLookahead,\n            getProductionDslName(currProd),\n          );\n        });\n\n        forEach(repetitionWithSeparator, (currProd) => {\n          this.computeLookaheadFunc(\n            currRule,\n            currProd.idx,\n            MANY_SEP_IDX,\n            \"RepetitionWithSeparator\",\n            currProd.maxLookahead,\n            getProductionDslName(currProd),\n          );\n        });\n      });\n    });\n  }\n\n  computeLookaheadFunc(\n    this: MixedInParser,\n    rule: Rule,\n    prodOccurrence: number,\n    prodKey: number,\n    prodType: OptionalProductionType,\n    prodMaxLookahead: number | undefined,\n    dslMethodName: string,\n  ): void {\n    this.TRACE_INIT(\n      `${dslMethodName}${prodOccurrence === 0 ? \"\" : prodOccurrence}`,\n      () => {\n        const laFunc = this.lookaheadStrategy.buildLookaheadForOptional({\n          prodOccurrence,\n          rule,\n          maxLookahead: prodMaxLookahead || this.maxLookahead,\n          dynamicTokensEnabled: this.dynamicTokensEnabled,\n          prodType,\n        });\n        const key = getKeyForAutomaticLookahead(\n          this.fullRuleNameToShort[rule.name],\n          prodKey,\n          prodOccurrence,\n        );\n        this.setLaFuncCache(key, laFunc);\n      },\n    );\n  }\n\n  // this actually returns a number, but it is always used as a string (object prop key)\n  getKeyForAutomaticLookahead(\n    this: MixedInParser,\n    dslMethodIdx: number,\n    occurrence: number,\n  ): number {\n    const currRuleShortName: any = this.getLastExplicitRuleShortName();\n    return getKeyForAutomaticLookahead(\n      currRuleShortName,\n      dslMethodIdx,\n      occurrence,\n    );\n  }\n\n  getLaFuncFromCache(this: MixedInParser, key: number): Function {\n    return this.lookAheadFuncsCache.get(key);\n  }\n\n  /* istanbul ignore next */\n  setLaFuncCache(this: MixedInParser, key: number, value: Function): void {\n    this.lookAheadFuncsCache.set(key, value);\n  }\n}\n\nclass DslMethodsCollectorVisitor extends GAstVisitor {\n  public dslMethods: {\n    option: Option[];\n    alternation: Alternation[];\n    repetition: Repetition[];\n    repetitionWithSeparator: RepetitionWithSeparator[];\n    repetitionMandatory: RepetitionMandatory[];\n    repetitionMandatoryWithSeparator: RepetitionMandatoryWithSeparator[];\n  } = {\n    option: [],\n    alternation: [],\n    repetition: [],\n    repetitionWithSeparator: [],\n    repetitionMandatory: [],\n    repetitionMandatoryWithSeparator: [],\n  };\n\n  reset() {\n    this.dslMethods = {\n      option: [],\n      alternation: [],\n      repetition: [],\n      repetitionWithSeparator: [],\n      repetitionMandatory: [],\n      repetitionMandatoryWithSeparator: [],\n    };\n  }\n\n  public visitOption(option: Option): void {\n    this.dslMethods.option.push(option);\n  }\n\n  public visitRepetitionWithSeparator(manySep: RepetitionWithSeparator): void {\n    this.dslMethods.repetitionWithSeparator.push(manySep);\n  }\n\n  public visitRepetitionMandatory(atLeastOne: RepetitionMandatory): void {\n    this.dslMethods.repetitionMandatory.push(atLeastOne);\n  }\n\n  public visitRepetitionMandatoryWithSeparator(\n    atLeastOneSep: RepetitionMandatoryWithSeparator,\n  ): void {\n    this.dslMethods.repetitionMandatoryWithSeparator.push(atLeastOneSep);\n  }\n\n  public visitRepetition(many: Repetition): void {\n    this.dslMethods.repetition.push(many);\n  }\n\n  public visitAlternation(or: Alternation): void {\n    this.dslMethods.alternation.push(or);\n  }\n}\n\nconst collectorVisitor = new DslMethodsCollectorVisitor();\nexport function collectMethods(rule: Rule): {\n  option: Option[];\n  alternation: Alternation[];\n  repetition: Repetition[];\n  repetitionWithSeparator: RepetitionWithSeparator[];\n  repetitionMandatory: RepetitionMandatory[];\n  repetitionMandatoryWithSeparator: RepetitionMandatoryWithSeparator[];\n} {\n  collectorVisitor.reset();\n  rule.accept(collectorVisitor);\n  const dslMethods = collectorVisitor.dslMethods;\n  // avoid uncleaned references\n  collectorVisitor.reset();\n  return <any>dslMethods;\n}\n","import { CstNode, CstNodeLocation, IToken } from \"@chevrotain/types\";\n\n/**\n * This nodeLocation tracking is not efficient and should only be used\n * when error recovery is enabled or the Token Vector contains virtual Tokens\n * (e.g, Python Indent/Outdent)\n * As it executes the calculation for every single terminal/nonTerminal\n * and does not rely on the fact the token vector is **sorted**\n */\nexport function setNodeLocationOnlyOffset(\n  currNodeLocation: CstNodeLocation,\n  newLocationInfo: Required<Pick<IToken, \"startOffset\" | \"endOffset\">>,\n): void {\n  // First (valid) update for this cst node\n  if (isNaN(currNodeLocation.startOffset) === true) {\n    // assumption1: Token location information is either NaN or a valid number\n    // assumption2: Token location information is fully valid if it exist\n    // (both start/end offsets exist and are numbers).\n    currNodeLocation.startOffset = newLocationInfo.startOffset;\n    currNodeLocation.endOffset = newLocationInfo.endOffset;\n  }\n  // Once the startOffset has been updated with a valid number it should never receive\n  // any farther updates as the Token vector is sorted.\n  // We still have to check this this condition for every new possible location info\n  // because with error recovery enabled we may encounter invalid tokens (NaN location props)\n  else if (currNodeLocation.endOffset! < newLocationInfo.endOffset === true) {\n    currNodeLocation.endOffset = newLocationInfo.endOffset;\n  }\n}\n\n/**\n * This nodeLocation tracking is not efficient and should only be used\n * when error recovery is enabled or the Token Vector contains virtual Tokens\n * (e.g, Python Indent/Outdent)\n * As it executes the calculation for every single terminal/nonTerminal\n * and does not rely on the fact the token vector is **sorted**\n */\nexport function setNodeLocationFull(\n  currNodeLocation: CstNodeLocation,\n  newLocationInfo: CstNodeLocation,\n): void {\n  // First (valid) update for this cst node\n  if (isNaN(currNodeLocation.startOffset) === true) {\n    // assumption1: Token location information is either NaN or a valid number\n    // assumption2: Token location information is fully valid if it exist\n    // (all start/end props exist and are numbers).\n    currNodeLocation.startOffset = newLocationInfo.startOffset;\n    currNodeLocation.startColumn = newLocationInfo.startColumn;\n    currNodeLocation.startLine = newLocationInfo.startLine;\n    currNodeLocation.endOffset = newLocationInfo.endOffset;\n    currNodeLocation.endColumn = newLocationInfo.endColumn;\n    currNodeLocation.endLine = newLocationInfo.endLine;\n  }\n  // Once the start props has been updated with a valid number it should never receive\n  // any farther updates as the Token vector is sorted.\n  // We still have to check this this condition for every new possible location info\n  // because with error recovery enabled we may encounter invalid tokens (NaN location props)\n  else if (currNodeLocation.endOffset! < newLocationInfo.endOffset! === true) {\n    currNodeLocation.endOffset = newLocationInfo.endOffset;\n    currNodeLocation.endColumn = newLocationInfo.endColumn;\n    currNodeLocation.endLine = newLocationInfo.endLine;\n  }\n}\n\nexport function addTerminalToCst(\n  node: CstNode,\n  token: IToken,\n  tokenTypeName: string,\n): void {\n  if (node.children[tokenTypeName] === undefined) {\n    node.children[tokenTypeName] = [token];\n  } else {\n    node.children[tokenTypeName].push(token);\n  }\n}\n\nexport function addNoneTerminalToCst(\n  node: CstNode,\n  ruleName: string,\n  ruleResult: any,\n): void {\n  if (node.children[ruleName] === undefined) {\n    node.children[ruleName] = [ruleResult];\n  } else {\n    node.children[ruleName].push(ruleResult);\n  }\n}\n","const NAME = \"name\";\n\nexport function defineNameProp(obj: {}, nameValue: string): void {\n  Object.defineProperty(obj, NAME, {\n    enumerable: false,\n    configurable: true,\n    writable: false,\n    value: nameValue,\n  });\n}\n","import {\n  compact,\n  filter,\n  forEach,\n  isArray,\n  isEmpty,\n  isFunction,\n  isUndefined,\n  keys,\n  map,\n} from \"lodash-es\";\nimport { defineNameProp } from \"../../lang/lang_extensions.js\";\nimport { CstNode, ICstVisitor } from \"@chevrotain/types\";\n\nexport function defaultVisit<IN>(ctx: any, param: IN): void {\n  const childrenNames = keys(ctx);\n  const childrenNamesLength = childrenNames.length;\n  for (let i = 0; i < childrenNamesLength; i++) {\n    const currChildName = childrenNames[i];\n    const currChildArray = ctx[currChildName];\n    const currChildArrayLength = currChildArray.length;\n    for (let j = 0; j < currChildArrayLength; j++) {\n      const currChild: any = currChildArray[j];\n      // distinction between Tokens Children and CstNode children\n      if (currChild.tokenTypeIdx === undefined) {\n        this[currChild.name](currChild.children, param);\n      }\n    }\n  }\n  // defaultVisit does not support generic out param\n}\n\nexport function createBaseSemanticVisitorConstructor(\n  grammarName: string,\n  ruleNames: string[],\n): {\n  new (...args: any[]): ICstVisitor<any, any>;\n} {\n  const derivedConstructor: any = function () {};\n\n  // can be overwritten according to:\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/\n  // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname\n  defineNameProp(derivedConstructor, grammarName + \"BaseSemantics\");\n\n  const semanticProto = {\n    visit: function (cstNode: CstNode | CstNode[], param: any) {\n      // enables writing more concise visitor methods when CstNode has only a single child\n      if (isArray(cstNode)) {\n        // A CST Node's children dictionary can never have empty arrays as values\n        // If a key is defined there will be at least one element in the corresponding value array.\n        cstNode = cstNode[0];\n      }\n\n      // enables passing optional CstNodes concisely.\n      if (isUndefined(cstNode)) {\n        return undefined;\n      }\n\n      return this[cstNode.name](cstNode.children, param);\n    },\n\n    validateVisitor: function () {\n      const semanticDefinitionErrors = validateVisitor(this, ruleNames);\n      if (!isEmpty(semanticDefinitionErrors)) {\n        const errorMessages = map(\n          semanticDefinitionErrors,\n          (currDefError) => currDefError.msg,\n        );\n        throw Error(\n          `Errors Detected in CST Visitor <${this.constructor.name}>:\\n\\t` +\n            `${errorMessages.join(\"\\n\\n\").replace(/\\n/g, \"\\n\\t\")}`,\n        );\n      }\n    },\n  };\n\n  derivedConstructor.prototype = semanticProto;\n  derivedConstructor.prototype.constructor = derivedConstructor;\n\n  derivedConstructor._RULE_NAMES = ruleNames;\n\n  return derivedConstructor;\n}\n\nexport function createBaseVisitorConstructorWithDefaults(\n  grammarName: string,\n  ruleNames: string[],\n  baseConstructor: Function,\n): {\n  new (...args: any[]): ICstVisitor<any, any>;\n} {\n  const derivedConstructor: any = function () {};\n\n  // can be overwritten according to:\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/\n  // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname\n  defineNameProp(derivedConstructor, grammarName + \"BaseSemanticsWithDefaults\");\n\n  const withDefaultsProto = Object.create(baseConstructor.prototype);\n  forEach(ruleNames, (ruleName) => {\n    withDefaultsProto[ruleName] = defaultVisit;\n  });\n\n  derivedConstructor.prototype = withDefaultsProto;\n  derivedConstructor.prototype.constructor = derivedConstructor;\n\n  return derivedConstructor;\n}\n\nexport enum CstVisitorDefinitionError {\n  REDUNDANT_METHOD,\n  MISSING_METHOD,\n}\n\nexport interface IVisitorDefinitionError {\n  msg: string;\n  type: CstVisitorDefinitionError;\n  methodName: string;\n}\n\nexport function validateVisitor(\n  visitorInstance: ICstVisitor<unknown, unknown>,\n  ruleNames: string[],\n): IVisitorDefinitionError[] {\n  const missingErrors = validateMissingCstMethods(visitorInstance, ruleNames);\n\n  return missingErrors;\n}\n\nexport function validateMissingCstMethods(\n  visitorInstance: ICstVisitor<unknown, unknown>,\n  ruleNames: string[],\n): IVisitorDefinitionError[] {\n  const missingRuleNames = filter(ruleNames, (currRuleName) => {\n    return isFunction((visitorInstance as any)[currRuleName]) === false;\n  });\n\n  const errors: IVisitorDefinitionError[] = map(\n    missingRuleNames,\n    (currRuleName) => {\n      return {\n        msg: `Missing visitor method: <${currRuleName}> on ${<any>(\n          visitorInstance.constructor.name\n        )} CST Visitor.`,\n        type: CstVisitorDefinitionError.MISSING_METHOD,\n        methodName: currRuleName,\n      };\n    },\n  );\n\n  return compact<IVisitorDefinitionError>(errors);\n}\n","import {\n  addNoneTerminalToCst,\n  addTerminalToCst,\n  setNodeLocationFull,\n  setNodeLocationOnlyOffset,\n} from \"../../cst/cst.js\";\nimport { has, isUndefined, keys, noop } from \"lodash-es\";\nimport {\n  createBaseSemanticVisitorConstructor,\n  createBaseVisitorConstructorWithDefaults,\n} from \"../../cst/cst_visitor.js\";\nimport {\n  CstNode,\n  CstNodeLocation,\n  ICstVisitor,\n  IParserConfig,\n  IToken,\n  nodeLocationTrackingOptions,\n} from \"@chevrotain/types\";\nimport { MixedInParser } from \"./parser_traits.js\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser.js\";\n\n/**\n * This trait is responsible for the CST building logic.\n */\nexport class TreeBuilder {\n  outputCst: boolean;\n  CST_STACK: CstNode[];\n  baseCstVisitorConstructor: Function;\n  baseCstVisitorWithDefaultsConstructor: Function;\n\n  // dynamically assigned Methods\n  setNodeLocationFromNode: (\n    nodeLocation: CstNodeLocation,\n    locationInformation: CstNodeLocation,\n  ) => void;\n  setNodeLocationFromToken: (\n    nodeLocation: CstNodeLocation,\n    locationInformation: CstNodeLocation,\n  ) => void;\n  cstPostRule: (this: MixedInParser, ruleCstNode: CstNode) => void;\n\n  setInitialNodeLocation: (cstNode: CstNode) => void;\n  nodeLocationTracking: nodeLocationTrackingOptions;\n\n  initTreeBuilder(this: MixedInParser, config: IParserConfig) {\n    this.CST_STACK = [];\n\n    // outputCst is no longer exposed/defined in the pubic API\n    this.outputCst = (config as any).outputCst;\n\n    this.nodeLocationTracking = has(config, \"nodeLocationTracking\")\n      ? (config.nodeLocationTracking as nodeLocationTrackingOptions) // assumes end user provides the correct config value/type\n      : DEFAULT_PARSER_CONFIG.nodeLocationTracking;\n\n    if (!this.outputCst) {\n      this.cstInvocationStateUpdate = noop;\n      this.cstFinallyStateUpdate = noop;\n      this.cstPostTerminal = noop;\n      this.cstPostNonTerminal = noop;\n      this.cstPostRule = noop;\n    } else {\n      if (/full/i.test(this.nodeLocationTracking)) {\n        if (this.recoveryEnabled) {\n          this.setNodeLocationFromToken = setNodeLocationFull;\n          this.setNodeLocationFromNode = setNodeLocationFull;\n          this.cstPostRule = noop;\n          this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery;\n        } else {\n          this.setNodeLocationFromToken = noop;\n          this.setNodeLocationFromNode = noop;\n          this.cstPostRule = this.cstPostRuleFull;\n          this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular;\n        }\n      } else if (/onlyOffset/i.test(this.nodeLocationTracking)) {\n        if (this.recoveryEnabled) {\n          this.setNodeLocationFromToken = <any>setNodeLocationOnlyOffset;\n          this.setNodeLocationFromNode = <any>setNodeLocationOnlyOffset;\n          this.cstPostRule = noop;\n          this.setInitialNodeLocation =\n            this.setInitialNodeLocationOnlyOffsetRecovery;\n        } else {\n          this.setNodeLocationFromToken = noop;\n          this.setNodeLocationFromNode = noop;\n          this.cstPostRule = this.cstPostRuleOnlyOffset;\n          this.setInitialNodeLocation =\n            this.setInitialNodeLocationOnlyOffsetRegular;\n        }\n      } else if (/none/i.test(this.nodeLocationTracking)) {\n        this.setNodeLocationFromToken = noop;\n        this.setNodeLocationFromNode = noop;\n        this.cstPostRule = noop;\n        this.setInitialNodeLocation = noop;\n      } else {\n        throw Error(\n          `Invalid <nodeLocationTracking> config option: \"${config.nodeLocationTracking}\"`,\n        );\n      }\n    }\n  }\n\n  setInitialNodeLocationOnlyOffsetRecovery(\n    this: MixedInParser,\n    cstNode: any,\n  ): void {\n    cstNode.location = {\n      startOffset: NaN,\n      endOffset: NaN,\n    };\n  }\n\n  setInitialNodeLocationOnlyOffsetRegular(\n    this: MixedInParser,\n    cstNode: any,\n  ): void {\n    cstNode.location = {\n      // without error recovery the starting Location of a new CstNode is guaranteed\n      // To be the next Token's startOffset (for valid inputs).\n      // For invalid inputs there won't be any CSTOutput so this potential\n      // inaccuracy does not matter\n      startOffset: this.LA(1).startOffset,\n      endOffset: NaN,\n    };\n  }\n\n  setInitialNodeLocationFullRecovery(this: MixedInParser, cstNode: any): void {\n    cstNode.location = {\n      startOffset: NaN,\n      startLine: NaN,\n      startColumn: NaN,\n      endOffset: NaN,\n      endLine: NaN,\n      endColumn: NaN,\n    };\n  }\n\n  /**\n     *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work\n\n     * @param cstNode\n     */\n  setInitialNodeLocationFullRegular(this: MixedInParser, cstNode: any): void {\n    const nextToken = this.LA(1);\n    cstNode.location = {\n      startOffset: nextToken.startOffset,\n      startLine: nextToken.startLine,\n      startColumn: nextToken.startColumn,\n      endOffset: NaN,\n      endLine: NaN,\n      endColumn: NaN,\n    };\n  }\n\n  cstInvocationStateUpdate(this: MixedInParser, fullRuleName: string): void {\n    const cstNode: CstNode = {\n      name: fullRuleName,\n      children: Object.create(null),\n    };\n\n    this.setInitialNodeLocation(cstNode);\n    this.CST_STACK.push(cstNode);\n  }\n\n  cstFinallyStateUpdate(this: MixedInParser): void {\n    this.CST_STACK.pop();\n  }\n\n  cstPostRuleFull(this: MixedInParser, ruleCstNode: CstNode): void {\n    // casts to `required<CstNodeLocation>` are safe because `cstPostRuleFull` should only be invoked when full location is enabled\n    const prevToken = this.LA(0) as Required<CstNodeLocation>;\n    const loc = ruleCstNode.location as Required<CstNodeLocation>;\n\n    // If this condition is true it means we consumed at least one Token\n    // In this CstNode.\n    if (loc.startOffset <= prevToken.startOffset === true) {\n      loc.endOffset = prevToken.endOffset;\n      loc.endLine = prevToken.endLine;\n      loc.endColumn = prevToken.endColumn;\n    }\n    // \"empty\" CstNode edge case\n    else {\n      loc.startOffset = NaN;\n      loc.startLine = NaN;\n      loc.startColumn = NaN;\n    }\n  }\n\n  cstPostRuleOnlyOffset(this: MixedInParser, ruleCstNode: CstNode): void {\n    const prevToken = this.LA(0);\n    // `location' is not null because `cstPostRuleOnlyOffset` will only be invoked when location tracking is enabled.\n    const loc = ruleCstNode.location!;\n\n    // If this condition is true it means we consumed at least one Token\n    // In this CstNode.\n    if (loc.startOffset <= prevToken.startOffset === true) {\n      loc.endOffset = prevToken.endOffset;\n    }\n    // \"empty\" CstNode edge case\n    else {\n      loc.startOffset = NaN;\n    }\n  }\n\n  cstPostTerminal(\n    this: MixedInParser,\n    key: string,\n    consumedToken: IToken,\n  ): void {\n    const rootCst = this.CST_STACK[this.CST_STACK.length - 1];\n    addTerminalToCst(rootCst, consumedToken, key);\n    // This is only used when **both** error recovery and CST Output are enabled.\n    this.setNodeLocationFromToken(rootCst.location!, <any>consumedToken);\n  }\n\n  cstPostNonTerminal(\n    this: MixedInParser,\n    ruleCstResult: CstNode,\n    ruleName: string,\n  ): void {\n    const preCstNode = this.CST_STACK[this.CST_STACK.length - 1];\n    addNoneTerminalToCst(preCstNode, ruleName, ruleCstResult);\n    // This is only used when **both** error recovery and CST Output are enabled.\n    this.setNodeLocationFromNode(preCstNode.location!, ruleCstResult.location!);\n  }\n\n  getBaseCstVisitorConstructor<IN = any, OUT = any>(\n    this: MixedInParser,\n  ): {\n    new (...args: any[]): ICstVisitor<IN, OUT>;\n  } {\n    if (isUndefined(this.baseCstVisitorConstructor)) {\n      const newBaseCstVisitorConstructor = createBaseSemanticVisitorConstructor(\n        this.className,\n        keys(this.gastProductionsCache),\n      );\n      this.baseCstVisitorConstructor = newBaseCstVisitorConstructor;\n      return newBaseCstVisitorConstructor;\n    }\n\n    return <any>this.baseCstVisitorConstructor;\n  }\n\n  getBaseCstVisitorConstructorWithDefaults<IN = any, OUT = any>(\n    this: MixedInParser,\n  ): {\n    new (...args: any[]): ICstVisitor<IN, OUT>;\n  } {\n    if (isUndefined(this.baseCstVisitorWithDefaultsConstructor)) {\n      const newConstructor = createBaseVisitorConstructorWithDefaults(\n        this.className,\n        keys(this.gastProductionsCache),\n        this.getBaseCstVisitorConstructor(),\n      );\n      this.baseCstVisitorWithDefaultsConstructor = newConstructor;\n      return newConstructor;\n    }\n\n    return <any>this.baseCstVisitorWithDefaultsConstructor;\n  }\n\n  getLastExplicitRuleShortName(this: MixedInParser): number {\n    const ruleStack = this.RULE_STACK;\n    return ruleStack[ruleStack.length - 1];\n  }\n\n  getPreviousExplicitRuleShortName(this: MixedInParser): number {\n    const ruleStack = this.RULE_STACK;\n    return ruleStack[ruleStack.length - 2];\n  }\n\n  getLastExplicitRuleOccurrenceIndex(this: MixedInParser): number {\n    const occurrenceStack = this.RULE_OCCURRENCE_STACK;\n    return occurrenceStack[occurrenceStack.length - 1];\n  }\n}\n","import { END_OF_FILE } from \"../parser.js\";\nimport { IToken } from \"@chevrotain/types\";\nimport { MixedInParser } from \"./parser_traits.js\";\n\n/**\n * Trait responsible abstracting over the interaction with Lexer output (Token vector).\n *\n * This could be generalized to support other kinds of lexers, e.g.\n * - Just in Time Lexing / Lexer-Less parsing.\n * - Streaming Lexer.\n */\nexport class LexerAdapter {\n  tokVector: IToken[];\n  tokVectorLength: number;\n  currIdx: number;\n\n  initLexerAdapter() {\n    this.tokVector = [];\n    this.tokVectorLength = 0;\n    this.currIdx = -1;\n  }\n\n  set input(newInput: IToken[]) {\n    // @ts-ignore - `this parameter` not supported in setters/getters\n    //   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters\n    if (this.selfAnalysisDone !== true) {\n      throw Error(\n        `Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.`,\n      );\n    }\n    // @ts-ignore - `this parameter` not supported in setters/getters\n    //   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters\n    this.reset();\n    this.tokVector = newInput;\n    this.tokVectorLength = newInput.length;\n  }\n\n  get input(): IToken[] {\n    return this.tokVector;\n  }\n\n  // skips a token and returns the next token\n  SKIP_TOKEN(this: MixedInParser): IToken {\n    if (this.currIdx <= this.tokVector.length - 2) {\n      this.consumeToken();\n      return this.LA(1);\n    } else {\n      return END_OF_FILE;\n    }\n  }\n\n  // Lexer (accessing Token vector) related methods which can be overridden to implement lazy lexers\n  // or lexers dependent on parser context.\n  LA(this: MixedInParser, howMuch: number): IToken {\n    const soughtIdx = this.currIdx + howMuch;\n    if (soughtIdx < 0 || this.tokVectorLength <= soughtIdx) {\n      return END_OF_FILE;\n    } else {\n      return this.tokVector[soughtIdx];\n    }\n  }\n\n  consumeToken(this: MixedInParser) {\n    this.currIdx++;\n  }\n\n  exportLexerState(this: MixedInParser): number {\n    return this.currIdx;\n  }\n\n  importLexerState(this: MixedInParser, newState: number) {\n    this.currIdx = newState;\n  }\n\n  resetLexerState(this: MixedInParser): void {\n    this.currIdx = -1;\n  }\n\n  moveToTerminatedState(this: MixedInParser): void {\n    this.currIdx = this.tokVector.length - 1;\n  }\n\n  getLexerPosition(this: MixedInParser): number {\n    return this.exportLexerState();\n  }\n}\n","import {\n  AtLeastOneSepMethodOpts,\n  ConsumeMethodOpts,\n  DSLMethodOpts,\n  DSLMethodOptsWithErr,\n  GrammarAction,\n  IOrAlt,\n  IRuleConfig,\n  ISerializedGast,\n  IToken,\n  ManySepMethodOpts,\n  OrMethodOpts,\n  SubruleMethodOpts,\n  TokenType,\n} from \"@chevrotain/types\";\nimport { includes, values } from \"lodash-es\";\nimport { isRecognitionException } from \"../../exceptions_public.js\";\nimport { DEFAULT_RULE_CONFIG, ParserDefinitionErrorType } from \"../parser.js\";\nimport { defaultGrammarValidatorErrorProvider } from \"../../errors_public.js\";\nimport { validateRuleIsOverridden } from \"../../grammar/checks.js\";\nimport { MixedInParser } from \"./parser_traits.js\";\nimport { Rule, serializeGrammar } from \"@chevrotain/gast\";\nimport { IParserDefinitionError } from \"../../grammar/types.js\";\nimport { ParserMethodInternal } from \"../types.js\";\n\n/**\n * This trait is responsible for implementing the public API\n * for defining Chevrotain parsers, i.e:\n * - CONSUME\n * - RULE\n * - OPTION\n * - ...\n */\nexport class RecognizerApi {\n  ACTION<T>(this: MixedInParser, impl: () => T): T {\n    return impl.call(this);\n  }\n\n  consume(\n    this: MixedInParser,\n    idx: number,\n    tokType: TokenType,\n    options?: ConsumeMethodOpts,\n  ): IToken {\n    return this.consumeInternal(tokType, idx, options);\n  }\n\n  subrule<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    idx: number,\n    ruleToCall: ParserMethodInternal<ARGS, R>,\n    options?: SubruleMethodOpts<ARGS>,\n  ): R {\n    return this.subruleInternal(ruleToCall, idx, options);\n  }\n\n  option<OUT>(\n    this: MixedInParser,\n    idx: number,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ): OUT | undefined {\n    return this.optionInternal(actionORMethodDef, idx);\n  }\n\n  or(\n    this: MixedInParser,\n    idx: number,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<any>,\n  ): any {\n    return this.orInternal(altsOrOpts, idx);\n  }\n\n  many(\n    this: MixedInParser,\n    idx: number,\n    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>,\n  ): void {\n    return this.manyInternal(idx, actionORMethodDef);\n  }\n\n  atLeastOne(\n    this: MixedInParser,\n    idx: number,\n    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>,\n  ): void {\n    return this.atLeastOneInternal(idx, actionORMethodDef);\n  }\n\n  CONSUME(\n    this: MixedInParser,\n    tokType: TokenType,\n    options?: ConsumeMethodOpts,\n  ): IToken {\n    return this.consumeInternal(tokType, 0, options);\n  }\n\n  CONSUME1(\n    this: MixedInParser,\n    tokType: TokenType,\n    options?: ConsumeMethodOpts,\n  ): IToken {\n    return this.consumeInternal(tokType, 1, options);\n  }\n\n  CONSUME2(\n    this: MixedInParser,\n    tokType: TokenType,\n    options?: ConsumeMethodOpts,\n  ): IToken {\n    return this.consumeInternal(tokType, 2, options);\n  }\n\n  CONSUME3(\n    this: MixedInParser,\n    tokType: TokenType,\n    options?: ConsumeMethodOpts,\n  ): IToken {\n    return this.consumeInternal(tokType, 3, options);\n  }\n\n  CONSUME4(\n    this: MixedInParser,\n    tokType: TokenType,\n    options?: ConsumeMethodOpts,\n  ): IToken {\n    return this.consumeInternal(tokType, 4, options);\n  }\n\n  CONSUME5(\n    this: MixedInParser,\n    tokType: TokenType,\n    options?: ConsumeMethodOpts,\n  ): IToken {\n    return this.consumeInternal(tokType, 5, options);\n  }\n\n  CONSUME6(\n    this: MixedInParser,\n    tokType: TokenType,\n    options?: ConsumeMethodOpts,\n  ): IToken {\n    return this.consumeInternal(tokType, 6, options);\n  }\n\n  CONSUME7(\n    this: MixedInParser,\n    tokType: TokenType,\n    options?: ConsumeMethodOpts,\n  ): IToken {\n    return this.consumeInternal(tokType, 7, options);\n  }\n\n  CONSUME8(\n    this: MixedInParser,\n    tokType: TokenType,\n    options?: ConsumeMethodOpts,\n  ): IToken {\n    return this.consumeInternal(tokType, 8, options);\n  }\n\n  CONSUME9(\n    this: MixedInParser,\n    tokType: TokenType,\n    options?: ConsumeMethodOpts,\n  ): IToken {\n    return this.consumeInternal(tokType, 9, options);\n  }\n\n  SUBRULE<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    ruleToCall: ParserMethodInternal<ARGS, R>,\n    options?: SubruleMethodOpts<ARGS>,\n  ): R {\n    return this.subruleInternal(ruleToCall, 0, options);\n  }\n\n  SUBRULE1<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    ruleToCall: ParserMethodInternal<ARGS, R>,\n    options?: SubruleMethodOpts<ARGS>,\n  ): R {\n    return this.subruleInternal(ruleToCall, 1, options);\n  }\n\n  SUBRULE2<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    ruleToCall: ParserMethodInternal<ARGS, R>,\n    options?: SubruleMethodOpts<ARGS>,\n  ): R {\n    return this.subruleInternal(ruleToCall, 2, options);\n  }\n\n  SUBRULE3<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    ruleToCall: ParserMethodInternal<ARGS, R>,\n    options?: SubruleMethodOpts<ARGS>,\n  ): R {\n    return this.subruleInternal(ruleToCall, 3, options);\n  }\n\n  SUBRULE4<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    ruleToCall: ParserMethodInternal<ARGS, R>,\n    options?: SubruleMethodOpts<ARGS>,\n  ): R {\n    return this.subruleInternal(ruleToCall, 4, options);\n  }\n\n  SUBRULE5<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    ruleToCall: ParserMethodInternal<ARGS, R>,\n    options?: SubruleMethodOpts<ARGS>,\n  ): R {\n    return this.subruleInternal(ruleToCall, 5, options);\n  }\n\n  SUBRULE6<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    ruleToCall: ParserMethodInternal<ARGS, R>,\n    options?: SubruleMethodOpts<ARGS>,\n  ): R {\n    return this.subruleInternal(ruleToCall, 6, options);\n  }\n\n  SUBRULE7<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    ruleToCall: ParserMethodInternal<ARGS, R>,\n    options?: SubruleMethodOpts<ARGS>,\n  ): R {\n    return this.subruleInternal(ruleToCall, 7, options);\n  }\n\n  SUBRULE8<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    ruleToCall: ParserMethodInternal<ARGS, R>,\n    options?: SubruleMethodOpts<ARGS>,\n  ): R {\n    return this.subruleInternal(ruleToCall, 8, options);\n  }\n\n  SUBRULE9<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    ruleToCall: ParserMethodInternal<ARGS, R>,\n    options?: SubruleMethodOpts<ARGS>,\n  ): R {\n    return this.subruleInternal(ruleToCall, 9, options);\n  }\n\n  OPTION<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ): OUT | undefined {\n    return this.optionInternal(actionORMethodDef, 0);\n  }\n\n  OPTION1<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ): OUT | undefined {\n    return this.optionInternal(actionORMethodDef, 1);\n  }\n\n  OPTION2<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ): OUT | undefined {\n    return this.optionInternal(actionORMethodDef, 2);\n  }\n\n  OPTION3<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ): OUT | undefined {\n    return this.optionInternal(actionORMethodDef, 3);\n  }\n\n  OPTION4<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ): OUT | undefined {\n    return this.optionInternal(actionORMethodDef, 4);\n  }\n\n  OPTION5<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ): OUT | undefined {\n    return this.optionInternal(actionORMethodDef, 5);\n  }\n\n  OPTION6<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ): OUT | undefined {\n    return this.optionInternal(actionORMethodDef, 6);\n  }\n\n  OPTION7<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ): OUT | undefined {\n    return this.optionInternal(actionORMethodDef, 7);\n  }\n\n  OPTION8<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ): OUT | undefined {\n    return this.optionInternal(actionORMethodDef, 8);\n  }\n\n  OPTION9<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ): OUT | undefined {\n    return this.optionInternal(actionORMethodDef, 9);\n  }\n\n  OR<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>,\n  ): T {\n    return this.orInternal(altsOrOpts, 0);\n  }\n\n  OR1<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>,\n  ): T {\n    return this.orInternal(altsOrOpts, 1);\n  }\n\n  OR2<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>,\n  ): T {\n    return this.orInternal(altsOrOpts, 2);\n  }\n\n  OR3<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>,\n  ): T {\n    return this.orInternal(altsOrOpts, 3);\n  }\n\n  OR4<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>,\n  ): T {\n    return this.orInternal(altsOrOpts, 4);\n  }\n\n  OR5<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>,\n  ): T {\n    return this.orInternal(altsOrOpts, 5);\n  }\n\n  OR6<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>,\n  ): T {\n    return this.orInternal(altsOrOpts, 6);\n  }\n\n  OR7<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>,\n  ): T {\n    return this.orInternal(altsOrOpts, 7);\n  }\n\n  OR8<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>,\n  ): T {\n    return this.orInternal(altsOrOpts, 8);\n  }\n\n  OR9<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>,\n  ): T {\n    return this.orInternal(altsOrOpts, 9);\n  }\n\n  MANY<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ): void {\n    this.manyInternal(0, actionORMethodDef);\n  }\n\n  MANY1<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ): void {\n    this.manyInternal(1, actionORMethodDef);\n  }\n\n  MANY2<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ): void {\n    this.manyInternal(2, actionORMethodDef);\n  }\n\n  MANY3<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ): void {\n    this.manyInternal(3, actionORMethodDef);\n  }\n\n  MANY4<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ): void {\n    this.manyInternal(4, actionORMethodDef);\n  }\n\n  MANY5<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ): void {\n    this.manyInternal(5, actionORMethodDef);\n  }\n\n  MANY6<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ): void {\n    this.manyInternal(6, actionORMethodDef);\n  }\n\n  MANY7<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ): void {\n    this.manyInternal(7, actionORMethodDef);\n  }\n\n  MANY8<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ): void {\n    this.manyInternal(8, actionORMethodDef);\n  }\n\n  MANY9<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ): void {\n    this.manyInternal(9, actionORMethodDef);\n  }\n\n  MANY_SEP<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\n    this.manySepFirstInternal(0, options);\n  }\n\n  MANY_SEP1<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\n    this.manySepFirstInternal(1, options);\n  }\n\n  MANY_SEP2<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\n    this.manySepFirstInternal(2, options);\n  }\n\n  MANY_SEP3<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\n    this.manySepFirstInternal(3, options);\n  }\n\n  MANY_SEP4<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\n    this.manySepFirstInternal(4, options);\n  }\n\n  MANY_SEP5<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\n    this.manySepFirstInternal(5, options);\n  }\n\n  MANY_SEP6<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\n    this.manySepFirstInternal(6, options);\n  }\n\n  MANY_SEP7<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\n    this.manySepFirstInternal(7, options);\n  }\n\n  MANY_SEP8<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\n    this.manySepFirstInternal(8, options);\n  }\n\n  MANY_SEP9<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\n    this.manySepFirstInternal(9, options);\n  }\n\n  AT_LEAST_ONE<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>,\n  ): void {\n    this.atLeastOneInternal(0, actionORMethodDef);\n  }\n\n  AT_LEAST_ONE1<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>,\n  ): void {\n    return this.atLeastOneInternal(1, actionORMethodDef);\n  }\n\n  AT_LEAST_ONE2<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>,\n  ): void {\n    this.atLeastOneInternal(2, actionORMethodDef);\n  }\n\n  AT_LEAST_ONE3<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>,\n  ): void {\n    this.atLeastOneInternal(3, actionORMethodDef);\n  }\n\n  AT_LEAST_ONE4<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>,\n  ): void {\n    this.atLeastOneInternal(4, actionORMethodDef);\n  }\n\n  AT_LEAST_ONE5<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>,\n  ): void {\n    this.atLeastOneInternal(5, actionORMethodDef);\n  }\n\n  AT_LEAST_ONE6<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>,\n  ): void {\n    this.atLeastOneInternal(6, actionORMethodDef);\n  }\n\n  AT_LEAST_ONE7<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>,\n  ): void {\n    this.atLeastOneInternal(7, actionORMethodDef);\n  }\n\n  AT_LEAST_ONE8<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>,\n  ): void {\n    this.atLeastOneInternal(8, actionORMethodDef);\n  }\n\n  AT_LEAST_ONE9<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>,\n  ): void {\n    this.atLeastOneInternal(9, actionORMethodDef);\n  }\n\n  AT_LEAST_ONE_SEP<OUT>(\n    this: MixedInParser,\n    options: AtLeastOneSepMethodOpts<OUT>,\n  ): void {\n    this.atLeastOneSepFirstInternal(0, options);\n  }\n\n  AT_LEAST_ONE_SEP1<OUT>(\n    this: MixedInParser,\n    options: AtLeastOneSepMethodOpts<OUT>,\n  ): void {\n    this.atLeastOneSepFirstInternal(1, options);\n  }\n\n  AT_LEAST_ONE_SEP2<OUT>(\n    this: MixedInParser,\n    options: AtLeastOneSepMethodOpts<OUT>,\n  ): void {\n    this.atLeastOneSepFirstInternal(2, options);\n  }\n\n  AT_LEAST_ONE_SEP3<OUT>(\n    this: MixedInParser,\n    options: AtLeastOneSepMethodOpts<OUT>,\n  ): void {\n    this.atLeastOneSepFirstInternal(3, options);\n  }\n\n  AT_LEAST_ONE_SEP4<OUT>(\n    this: MixedInParser,\n    options: AtLeastOneSepMethodOpts<OUT>,\n  ): void {\n    this.atLeastOneSepFirstInternal(4, options);\n  }\n\n  AT_LEAST_ONE_SEP5<OUT>(\n    this: MixedInParser,\n    options: AtLeastOneSepMethodOpts<OUT>,\n  ): void {\n    this.atLeastOneSepFirstInternal(5, options);\n  }\n\n  AT_LEAST_ONE_SEP6<OUT>(\n    this: MixedInParser,\n    options: AtLeastOneSepMethodOpts<OUT>,\n  ): void {\n    this.atLeastOneSepFirstInternal(6, options);\n  }\n\n  AT_LEAST_ONE_SEP7<OUT>(\n    this: MixedInParser,\n    options: AtLeastOneSepMethodOpts<OUT>,\n  ): void {\n    this.atLeastOneSepFirstInternal(7, options);\n  }\n\n  AT_LEAST_ONE_SEP8<OUT>(\n    this: MixedInParser,\n    options: AtLeastOneSepMethodOpts<OUT>,\n  ): void {\n    this.atLeastOneSepFirstInternal(8, options);\n  }\n\n  AT_LEAST_ONE_SEP9<OUT>(\n    this: MixedInParser,\n    options: AtLeastOneSepMethodOpts<OUT>,\n  ): void {\n    this.atLeastOneSepFirstInternal(9, options);\n  }\n\n  RULE<T>(\n    this: MixedInParser,\n    name: string,\n    implementation: (...implArgs: any[]) => T,\n    config: IRuleConfig<T> = DEFAULT_RULE_CONFIG,\n  ): (idxInCallingRule?: number, ...args: any[]) => T | any {\n    if (includes(this.definedRulesNames, name)) {\n      const errMsg =\n        defaultGrammarValidatorErrorProvider.buildDuplicateRuleNameError({\n          topLevelRule: name,\n          grammarName: this.className,\n        });\n\n      const error = {\n        message: errMsg,\n        type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n        ruleName: name,\n      };\n      this.definitionErrors.push(error);\n    }\n\n    this.definedRulesNames.push(name);\n\n    const ruleImplementation = this.defineRule(name, implementation, config);\n    (this as any)[name] = ruleImplementation;\n    return ruleImplementation;\n  }\n\n  OVERRIDE_RULE<T>(\n    this: MixedInParser,\n    name: string,\n    impl: (...implArgs: any[]) => T,\n    config: IRuleConfig<T> = DEFAULT_RULE_CONFIG,\n  ): (idxInCallingRule?: number, ...args: any[]) => T {\n    const ruleErrors: IParserDefinitionError[] = validateRuleIsOverridden(\n      name,\n      this.definedRulesNames,\n      this.className,\n    );\n    this.definitionErrors = this.definitionErrors.concat(ruleErrors);\n\n    const ruleImplementation = this.defineRule(name, impl, config);\n    (this as any)[name] = ruleImplementation;\n    return ruleImplementation;\n  }\n\n  BACKTRACK<T>(\n    this: MixedInParser,\n    grammarRule: (...args: any[]) => T,\n    args?: any[],\n  ): () => boolean {\n    return function () {\n      // save org state\n      this.isBackTrackingStack.push(1);\n      const orgState = this.saveRecogState();\n      try {\n        grammarRule.apply(this, args);\n        // if no exception was thrown we have succeed parsing the rule.\n        return true;\n      } catch (e) {\n        if (isRecognitionException(e)) {\n          return false;\n        } else {\n          throw e;\n        }\n      } finally {\n        this.reloadRecogState(orgState);\n        this.isBackTrackingStack.pop();\n      }\n    };\n  }\n\n  // GAST export APIs\n  public getGAstProductions(this: MixedInParser): Record<string, Rule> {\n    return this.gastProductionsCache;\n  }\n\n  public getSerializedGastProductions(this: MixedInParser): ISerializedGast[] {\n    return serializeGrammar(values(this.gastProductionsCache));\n  }\n}\n","import {\n  AtLeastOneSepMethodOpts,\n  ConsumeMethodOpts,\n  DSLMethodOpts,\n  DSLMethodOptsWithErr,\n  GrammarAction,\n  IOrAlt,\n  IParserConfig,\n  IRuleConfig,\n  IToken,\n  ManySepMethodOpts,\n  OrMethodOpts,\n  ParserMethod,\n  SubruleMethodOpts,\n  TokenType,\n  TokenTypeDictionary,\n  TokenVocabulary,\n} from \"@chevrotain/types\";\nimport {\n  clone,\n  every,\n  flatten,\n  has,\n  isArray,\n  isEmpty,\n  isObject,\n  reduce,\n  uniq,\n  values,\n} from \"lodash-es\";\nimport {\n  AT_LEAST_ONE_IDX,\n  AT_LEAST_ONE_SEP_IDX,\n  BITS_FOR_METHOD_TYPE,\n  BITS_FOR_OCCURRENCE_IDX,\n  MANY_IDX,\n  MANY_SEP_IDX,\n  OPTION_IDX,\n  OR_IDX,\n} from \"../../grammar/keys.js\";\nimport {\n  isRecognitionException,\n  MismatchedTokenException,\n  NotAllInputParsedException,\n} from \"../../exceptions_public.js\";\nimport { PROD_TYPE } from \"../../grammar/lookahead.js\";\nimport {\n  AbstractNextTerminalAfterProductionWalker,\n  NextTerminalAfterAtLeastOneSepWalker,\n  NextTerminalAfterAtLeastOneWalker,\n  NextTerminalAfterManySepWalker,\n  NextTerminalAfterManyWalker,\n} from \"../../grammar/interpreter.js\";\nimport { DEFAULT_RULE_CONFIG, IParserState, TokenMatcher } from \"../parser.js\";\nimport { IN_RULE_RECOVERY_EXCEPTION } from \"./recoverable.js\";\nimport { EOF } from \"../../../scan/tokens_public.js\";\nimport { MixedInParser } from \"./parser_traits.js\";\nimport {\n  augmentTokenTypes,\n  isTokenType,\n  tokenStructuredMatcher,\n  tokenStructuredMatcherNoCategories,\n} from \"../../../scan/tokens.js\";\nimport { Rule } from \"@chevrotain/gast\";\nimport { ParserMethodInternal } from \"../types.js\";\n\n/**\n * This trait is responsible for the runtime parsing engine\n * Used by the official API (recognizer_api.ts)\n */\nexport class RecognizerEngine {\n  isBackTrackingStack: boolean[];\n  className: string;\n  RULE_STACK: number[];\n  RULE_OCCURRENCE_STACK: number[];\n  definedRulesNames: string[];\n  tokensMap: { [fqn: string]: TokenType };\n  gastProductionsCache: Record<string, Rule>;\n  shortRuleNameToFull: Record<string, string>;\n  fullRuleNameToShort: Record<string, number>;\n  // The shortName Index must be coded \"after\" the first 8bits to enable building unique lookahead keys\n  ruleShortNameIdx: number;\n  tokenMatcher: TokenMatcher;\n  subruleIdx: number;\n\n  initRecognizerEngine(\n    tokenVocabulary: TokenVocabulary,\n    config: IParserConfig,\n  ) {\n    this.className = this.constructor.name;\n    // TODO: would using an ES6 Map or plain object be faster (CST building scenario)\n    this.shortRuleNameToFull = {};\n    this.fullRuleNameToShort = {};\n    this.ruleShortNameIdx = 256;\n    this.tokenMatcher = tokenStructuredMatcherNoCategories;\n    this.subruleIdx = 0;\n\n    this.definedRulesNames = [];\n    this.tokensMap = {};\n    this.isBackTrackingStack = [];\n    this.RULE_STACK = [];\n    this.RULE_OCCURRENCE_STACK = [];\n    this.gastProductionsCache = {};\n\n    if (has(config, \"serializedGrammar\")) {\n      throw Error(\n        \"The Parser's configuration can no longer contain a <serializedGrammar> property.\\n\" +\n          \"\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0\\n\" +\n          \"\\tFor Further details.\",\n      );\n    }\n\n    if (isArray(tokenVocabulary)) {\n      // This only checks for Token vocabularies provided as arrays.\n      // That is good enough because the main objective is to detect users of pre-V4.0 APIs\n      // rather than all edge cases of empty Token vocabularies.\n      if (isEmpty(tokenVocabulary as any[])) {\n        throw Error(\n          \"A Token Vocabulary cannot be empty.\\n\" +\n            \"\\tNote that the first argument for the parser constructor\\n\" +\n            \"\\tis no longer a Token vector (since v4.0).\",\n        );\n      }\n\n      if (typeof (tokenVocabulary as any[])[0].startOffset === \"number\") {\n        throw Error(\n          \"The Parser constructor no longer accepts a token vector as the first argument.\\n\" +\n            \"\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0\\n\" +\n            \"\\tFor Further details.\",\n        );\n      }\n    }\n\n    if (isArray(tokenVocabulary)) {\n      this.tokensMap = reduce(\n        tokenVocabulary,\n        (acc, tokType: TokenType) => {\n          acc[tokType.name] = tokType;\n          return acc;\n        },\n        {} as { [tokenName: string]: TokenType },\n      );\n    } else if (\n      has(tokenVocabulary, \"modes\") &&\n      every(flatten(values((<any>tokenVocabulary).modes)), isTokenType)\n    ) {\n      const allTokenTypes = flatten(values((<any>tokenVocabulary).modes));\n      const uniqueTokens = uniq(allTokenTypes);\n      this.tokensMap = <any>reduce(\n        uniqueTokens,\n        (acc, tokType: TokenType) => {\n          acc[tokType.name] = tokType;\n          return acc;\n        },\n        {} as { [tokenName: string]: TokenType },\n      );\n    } else if (isObject(tokenVocabulary)) {\n      this.tokensMap = clone(tokenVocabulary as TokenTypeDictionary);\n    } else {\n      throw new Error(\n        \"<tokensDictionary> argument must be An Array of Token constructors,\" +\n          \" A dictionary of Token constructors or an IMultiModeLexerDefinition\",\n      );\n    }\n\n    // always add EOF to the tokenNames -> constructors map. it is useful to assure all the input has been\n    // parsed with a clear error message (\"expecting EOF but found ...\")\n    this.tokensMap[\"EOF\"] = EOF;\n\n    const allTokenTypes = has(tokenVocabulary, \"modes\")\n      ? flatten(values((<any>tokenVocabulary).modes))\n      : values(tokenVocabulary);\n    const noTokenCategoriesUsed = every(allTokenTypes, (tokenConstructor) =>\n      isEmpty(tokenConstructor.categoryMatches),\n    );\n\n    this.tokenMatcher = noTokenCategoriesUsed\n      ? tokenStructuredMatcherNoCategories\n      : tokenStructuredMatcher;\n\n    // Because ES2015+ syntax should be supported for creating Token classes\n    // We cannot assume that the Token classes were created using the \"extendToken\" utilities\n    // Therefore we must augment the Token classes both on Lexer initialization and on Parser initialization\n    augmentTokenTypes(values(this.tokensMap));\n  }\n\n  defineRule<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    ruleName: string,\n    impl: (...args: ARGS) => R,\n    config: IRuleConfig<R>,\n  ): ParserMethodInternal<ARGS, R> {\n    if (this.selfAnalysisDone) {\n      throw Error(\n        `Grammar rule <${ruleName}> may not be defined after the 'performSelfAnalysis' method has been called'\\n` +\n          `Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.`,\n      );\n    }\n    const resyncEnabled: boolean = has(config, \"resyncEnabled\")\n      ? (config.resyncEnabled as boolean) // assumes end user provides the correct config value/type\n      : DEFAULT_RULE_CONFIG.resyncEnabled;\n    const recoveryValueFunc = has(config, \"recoveryValueFunc\")\n      ? (config.recoveryValueFunc as () => R) // assumes end user provides the correct config value/type\n      : DEFAULT_RULE_CONFIG.recoveryValueFunc;\n\n    // performance optimization: Use small integers as keys for the longer human readable \"full\" rule names.\n    // this greatly improves Map access time (as much as 8% for some performance benchmarks).\n    const shortName =\n      this.ruleShortNameIdx << (BITS_FOR_METHOD_TYPE + BITS_FOR_OCCURRENCE_IDX);\n\n    this.ruleShortNameIdx++;\n    this.shortRuleNameToFull[shortName] = ruleName;\n    this.fullRuleNameToShort[ruleName] = shortName;\n\n    let invokeRuleWithTry: ParserMethod<ARGS, R>;\n\n    // Micro optimization, only check the condition **once** on rule definition\n    // instead of **every single** rule invocation.\n    if (this.outputCst === true) {\n      invokeRuleWithTry = function invokeRuleWithTry(\n        this: MixedInParser,\n        ...args: ARGS\n      ): R {\n        try {\n          this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);\n          impl.apply(this, args);\n          const cst = this.CST_STACK[this.CST_STACK.length - 1];\n          this.cstPostRule(cst);\n          return cst as unknown as R;\n        } catch (e) {\n          return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc) as R;\n        } finally {\n          this.ruleFinallyStateUpdate();\n        }\n      };\n    } else {\n      invokeRuleWithTry = function invokeRuleWithTryCst(\n        this: MixedInParser,\n        ...args: ARGS\n      ): R {\n        try {\n          this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);\n          return impl.apply(this, args);\n        } catch (e) {\n          return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc) as R;\n        } finally {\n          this.ruleFinallyStateUpdate();\n        }\n      };\n    }\n\n    const wrappedGrammarRule: ParserMethodInternal<ARGS, R> = Object.assign(\n      invokeRuleWithTry as any,\n      { ruleName, originalGrammarAction: impl },\n    );\n\n    return wrappedGrammarRule;\n  }\n\n  invokeRuleCatch(\n    this: MixedInParser,\n    e: Error,\n    resyncEnabledConfig: boolean,\n    recoveryValueFunc: Function,\n  ): unknown {\n    const isFirstInvokedRule = this.RULE_STACK.length === 1;\n    // note the reSync is always enabled for the first rule invocation, because we must always be able to\n    // reSync with EOF and just output some INVALID ParseTree\n    // during backtracking reSync recovery is disabled, otherwise we can't be certain the backtracking\n    // path is really the most valid one\n    const reSyncEnabled =\n      resyncEnabledConfig && !this.isBackTracking() && this.recoveryEnabled;\n\n    if (isRecognitionException(e)) {\n      const recogError: any = e;\n      if (reSyncEnabled) {\n        const reSyncTokType = this.findReSyncTokenType();\n        if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {\n          recogError.resyncedTokens = this.reSyncTo(reSyncTokType);\n          if (this.outputCst) {\n            const partialCstResult: any =\n              this.CST_STACK[this.CST_STACK.length - 1];\n            partialCstResult.recoveredNode = true;\n            return partialCstResult;\n          } else {\n            return recoveryValueFunc(e);\n          }\n        } else {\n          if (this.outputCst) {\n            const partialCstResult: any =\n              this.CST_STACK[this.CST_STACK.length - 1];\n            partialCstResult.recoveredNode = true;\n            recogError.partialCstResult = partialCstResult;\n          }\n          // to be handled Further up the call stack\n          throw recogError;\n        }\n      } else if (isFirstInvokedRule) {\n        // otherwise a Redundant input error will be created as well and we cannot guarantee that this is indeed the case\n        this.moveToTerminatedState();\n        // the parser should never throw one of its own errors outside its flow.\n        // even if error recovery is disabled\n        return recoveryValueFunc(e);\n      } else {\n        // to be recovered Further up the call stack\n        throw recogError;\n      }\n    } else {\n      // some other Error type which we don't know how to handle (for example a built in JavaScript Error)\n      throw e;\n    }\n  }\n\n  // Implementation of parsing DSL\n  optionInternal<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n    occurrence: number,\n  ): OUT | undefined {\n    const key = this.getKeyForAutomaticLookahead(OPTION_IDX, occurrence);\n    return this.optionInternalLogic(actionORMethodDef, occurrence, key);\n  }\n\n  optionInternalLogic<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n    occurrence: number,\n    key: number,\n  ): OUT | undefined {\n    let lookAheadFunc = this.getLaFuncFromCache(key);\n    let action: GrammarAction<OUT>;\n    if (typeof actionORMethodDef !== \"function\") {\n      action = actionORMethodDef.DEF;\n      const predicate = actionORMethodDef.GATE;\n      // predicate present\n      if (predicate !== undefined) {\n        const orgLookaheadFunction = lookAheadFunc;\n        lookAheadFunc = () => {\n          return predicate.call(this) && orgLookaheadFunction.call(this);\n        };\n      }\n    } else {\n      action = actionORMethodDef;\n    }\n\n    if (lookAheadFunc.call(this) === true) {\n      return action.call(this);\n    }\n    return undefined;\n  }\n\n  atLeastOneInternal<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>,\n  ): void {\n    const laKey = this.getKeyForAutomaticLookahead(\n      AT_LEAST_ONE_IDX,\n      prodOccurrence,\n    );\n    return this.atLeastOneInternalLogic(\n      prodOccurrence,\n      actionORMethodDef,\n      laKey,\n    );\n  }\n\n  atLeastOneInternalLogic<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>,\n    key: number,\n  ): void {\n    let lookAheadFunc = this.getLaFuncFromCache(key);\n    let action;\n    if (typeof actionORMethodDef !== \"function\") {\n      action = actionORMethodDef.DEF;\n      const predicate = actionORMethodDef.GATE;\n      // predicate present\n      if (predicate !== undefined) {\n        const orgLookaheadFunction = lookAheadFunc;\n        lookAheadFunc = () => {\n          return predicate.call(this) && orgLookaheadFunction.call(this);\n        };\n      }\n    } else {\n      action = actionORMethodDef;\n    }\n\n    if ((<Function>lookAheadFunc).call(this) === true) {\n      let notStuck = this.doSingleRepetition(action);\n      while (\n        (<Function>lookAheadFunc).call(this) === true &&\n        notStuck === true\n      ) {\n        notStuck = this.doSingleRepetition(action);\n      }\n    } else {\n      throw this.raiseEarlyExitException(\n        prodOccurrence,\n        PROD_TYPE.REPETITION_MANDATORY,\n        (<DSLMethodOptsWithErr<OUT>>actionORMethodDef).ERR_MSG,\n      );\n    }\n\n    // note that while it may seem that this can cause an error because by using a recursive call to\n    // AT_LEAST_ONE we change the grammar to AT_LEAST_TWO, AT_LEAST_THREE ... , the possible recursive call\n    // from the tryInRepetitionRecovery(...) will only happen IFF there really are TWO/THREE/.... items.\n\n    // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n    this.attemptInRepetitionRecovery(\n      this.atLeastOneInternal,\n      [prodOccurrence, actionORMethodDef],\n      <any>lookAheadFunc,\n      AT_LEAST_ONE_IDX,\n      prodOccurrence,\n      NextTerminalAfterAtLeastOneWalker,\n    );\n  }\n\n  atLeastOneSepFirstInternal<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    options: AtLeastOneSepMethodOpts<OUT>,\n  ): void {\n    const laKey = this.getKeyForAutomaticLookahead(\n      AT_LEAST_ONE_SEP_IDX,\n      prodOccurrence,\n    );\n    this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);\n  }\n\n  atLeastOneSepFirstInternalLogic<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    options: AtLeastOneSepMethodOpts<OUT>,\n    key: number,\n  ): void {\n    const action = options.DEF;\n    const separator = options.SEP;\n\n    const firstIterationLookaheadFunc = this.getLaFuncFromCache(key);\n\n    // 1st iteration\n    if (firstIterationLookaheadFunc.call(this) === true) {\n      (<GrammarAction<OUT>>action).call(this);\n\n      //  TODO: Optimization can move this function construction into \"attemptInRepetitionRecovery\"\n      //  because it is only needed in error recovery scenarios.\n      const separatorLookAheadFunc = () => {\n        return this.tokenMatcher(this.LA(1), separator);\n      };\n\n      // 2nd..nth iterations\n      while (this.tokenMatcher(this.LA(1), separator) === true) {\n        // note that this CONSUME will never enter recovery because\n        // the separatorLookAheadFunc checks that the separator really does exist.\n        this.CONSUME(separator);\n        // No need for checking infinite loop here due to consuming the separator.\n        (<GrammarAction<OUT>>action).call(this);\n      }\n\n      // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n      this.attemptInRepetitionRecovery(\n        this.repetitionSepSecondInternal,\n        [\n          prodOccurrence,\n          separator,\n          separatorLookAheadFunc,\n          action,\n          NextTerminalAfterAtLeastOneSepWalker,\n        ],\n        separatorLookAheadFunc,\n        AT_LEAST_ONE_SEP_IDX,\n        prodOccurrence,\n        NextTerminalAfterAtLeastOneSepWalker,\n      );\n    } else {\n      throw this.raiseEarlyExitException(\n        prodOccurrence,\n        PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR,\n        options.ERR_MSG,\n      );\n    }\n  }\n\n  manyInternal<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ): void {\n    const laKey = this.getKeyForAutomaticLookahead(MANY_IDX, prodOccurrence);\n    return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n  }\n\n  manyInternalLogic<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n    key: number,\n  ) {\n    let lookaheadFunction = this.getLaFuncFromCache(key);\n    let action;\n    if (typeof actionORMethodDef !== \"function\") {\n      action = actionORMethodDef.DEF;\n      const predicate = actionORMethodDef.GATE;\n      // predicate present\n      if (predicate !== undefined) {\n        const orgLookaheadFunction = lookaheadFunction;\n        lookaheadFunction = () => {\n          return predicate.call(this) && orgLookaheadFunction.call(this);\n        };\n      }\n    } else {\n      action = actionORMethodDef;\n    }\n\n    let notStuck = true;\n    while (lookaheadFunction.call(this) === true && notStuck === true) {\n      notStuck = this.doSingleRepetition(action);\n    }\n\n    // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n    this.attemptInRepetitionRecovery(\n      this.manyInternal,\n      [prodOccurrence, actionORMethodDef],\n      <any>lookaheadFunction,\n      MANY_IDX,\n      prodOccurrence,\n      NextTerminalAfterManyWalker,\n      // The notStuck parameter is only relevant when \"attemptInRepetitionRecovery\"\n      // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]\n      // An infinite loop cannot occur as:\n      // - Either the lookahead is guaranteed to consume something (Single Token Separator)\n      // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).\n      notStuck,\n    );\n  }\n\n  manySepFirstInternal<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    options: ManySepMethodOpts<OUT>,\n  ): void {\n    const laKey = this.getKeyForAutomaticLookahead(\n      MANY_SEP_IDX,\n      prodOccurrence,\n    );\n    this.manySepFirstInternalLogic(prodOccurrence, options, laKey);\n  }\n\n  manySepFirstInternalLogic<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    options: ManySepMethodOpts<OUT>,\n    key: number,\n  ): void {\n    const action = options.DEF;\n    const separator = options.SEP;\n    const firstIterationLaFunc = this.getLaFuncFromCache(key);\n\n    // 1st iteration\n    if (firstIterationLaFunc.call(this) === true) {\n      action.call(this);\n\n      const separatorLookAheadFunc = () => {\n        return this.tokenMatcher(this.LA(1), separator);\n      };\n      // 2nd..nth iterations\n      while (this.tokenMatcher(this.LA(1), separator) === true) {\n        // note that this CONSUME will never enter recovery because\n        // the separatorLookAheadFunc checks that the separator really does exist.\n        this.CONSUME(separator);\n        // No need for checking infinite loop here due to consuming the separator.\n        action.call(this);\n      }\n\n      // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n      this.attemptInRepetitionRecovery(\n        this.repetitionSepSecondInternal,\n        [\n          prodOccurrence,\n          separator,\n          separatorLookAheadFunc,\n          action,\n          NextTerminalAfterManySepWalker,\n        ],\n        separatorLookAheadFunc,\n        MANY_SEP_IDX,\n        prodOccurrence,\n        NextTerminalAfterManySepWalker,\n      );\n    }\n  }\n\n  repetitionSepSecondInternal<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    separator: TokenType,\n    separatorLookAheadFunc: () => boolean,\n    action: GrammarAction<OUT>,\n    nextTerminalAfterWalker: typeof AbstractNextTerminalAfterProductionWalker,\n  ): void {\n    while (separatorLookAheadFunc()) {\n      // note that this CONSUME will never enter recovery because\n      // the separatorLookAheadFunc checks that the separator really does exist.\n      this.CONSUME(separator);\n      action.call(this);\n    }\n\n    // we can only arrive to this function after an error\n    // has occurred (hence the name 'second') so the following\n    // IF will always be entered, its possible to remove it...\n    // however it is kept to avoid confusion and be consistent.\n    // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n    /* istanbul ignore else */\n    this.attemptInRepetitionRecovery(\n      this.repetitionSepSecondInternal,\n      [\n        prodOccurrence,\n        separator,\n        separatorLookAheadFunc,\n        action,\n        nextTerminalAfterWalker,\n      ],\n      separatorLookAheadFunc,\n      AT_LEAST_ONE_SEP_IDX,\n      prodOccurrence,\n      nextTerminalAfterWalker,\n    );\n  }\n\n  doSingleRepetition(this: MixedInParser, action: Function): any {\n    const beforeIteration = this.getLexerPosition();\n    action.call(this);\n    const afterIteration = this.getLexerPosition();\n\n    // This boolean will indicate if this repetition progressed\n    // or if we are \"stuck\" (potential infinite loop in the repetition).\n    return afterIteration > beforeIteration;\n  }\n\n  orInternal<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>,\n    occurrence: number,\n  ): T {\n    const laKey = this.getKeyForAutomaticLookahead(OR_IDX, occurrence);\n    const alts = isArray(altsOrOpts) ? altsOrOpts : altsOrOpts.DEF;\n\n    const laFunc = this.getLaFuncFromCache(laKey);\n    const altIdxToTake = laFunc.call(this, alts);\n    if (altIdxToTake !== undefined) {\n      const chosenAlternative: any = alts[altIdxToTake];\n      return chosenAlternative.ALT.call(this);\n    }\n    this.raiseNoAltException(\n      occurrence,\n      (altsOrOpts as OrMethodOpts<unknown>).ERR_MSG,\n    );\n  }\n\n  ruleFinallyStateUpdate(this: MixedInParser): void {\n    this.RULE_STACK.pop();\n    this.RULE_OCCURRENCE_STACK.pop();\n\n    // NOOP when cst is disabled\n    this.cstFinallyStateUpdate();\n\n    if (this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {\n      const firstRedundantTok = this.LA(1);\n      const errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({\n        firstRedundant: firstRedundantTok,\n        ruleName: this.getCurrRuleFullName(),\n      });\n      this.SAVE_ERROR(\n        new NotAllInputParsedException(errMsg, firstRedundantTok),\n      );\n    }\n  }\n\n  subruleInternal<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    ruleToCall: ParserMethodInternal<ARGS, R>,\n    idx: number,\n    options?: SubruleMethodOpts<ARGS>,\n  ): R {\n    let ruleResult;\n    try {\n      const args = options !== undefined ? options.ARGS : undefined;\n      this.subruleIdx = idx;\n      ruleResult = ruleToCall.apply(this, args);\n      this.cstPostNonTerminal(\n        ruleResult,\n        options !== undefined && options.LABEL !== undefined\n          ? options.LABEL\n          : ruleToCall.ruleName,\n      );\n      return ruleResult;\n    } catch (e) {\n      throw this.subruleInternalError(e, options, ruleToCall.ruleName);\n    }\n  }\n\n  subruleInternalError(\n    this: MixedInParser,\n    e: any,\n    options: SubruleMethodOpts<unknown[]> | undefined,\n    ruleName: string,\n  ): void {\n    if (isRecognitionException(e) && e.partialCstResult !== undefined) {\n      this.cstPostNonTerminal(\n        e.partialCstResult,\n        options !== undefined && options.LABEL !== undefined\n          ? options.LABEL\n          : ruleName,\n      );\n\n      delete e.partialCstResult;\n    }\n    throw e;\n  }\n\n  consumeInternal(\n    this: MixedInParser,\n    tokType: TokenType,\n    idx: number,\n    options: ConsumeMethodOpts | undefined,\n  ): IToken {\n    let consumedToken!: IToken;\n    try {\n      const nextToken = this.LA(1);\n      if (this.tokenMatcher(nextToken, tokType) === true) {\n        this.consumeToken();\n        consumedToken = nextToken;\n      } else {\n        this.consumeInternalError(tokType, nextToken, options);\n      }\n    } catch (eFromConsumption) {\n      consumedToken = this.consumeInternalRecovery(\n        tokType,\n        idx,\n        eFromConsumption,\n      );\n    }\n\n    this.cstPostTerminal(\n      options !== undefined && options.LABEL !== undefined\n        ? options.LABEL\n        : tokType.name,\n      consumedToken,\n    );\n    return consumedToken;\n  }\n\n  consumeInternalError(\n    this: MixedInParser,\n    tokType: TokenType,\n    nextToken: IToken,\n    options: ConsumeMethodOpts | undefined,\n  ): void {\n    let msg;\n    const previousToken = this.LA(0);\n    if (options !== undefined && options.ERR_MSG) {\n      msg = options.ERR_MSG;\n    } else {\n      msg = this.errorMessageProvider.buildMismatchTokenMessage({\n        expected: tokType,\n        actual: nextToken,\n        previous: previousToken,\n        ruleName: this.getCurrRuleFullName(),\n      });\n    }\n    throw this.SAVE_ERROR(\n      new MismatchedTokenException(msg, nextToken, previousToken),\n    );\n  }\n\n  consumeInternalRecovery(\n    this: MixedInParser,\n    tokType: TokenType,\n    idx: number,\n    eFromConsumption: Error,\n  ): IToken {\n    // no recovery allowed during backtracking, otherwise backtracking may recover invalid syntax and accept it\n    // but the original syntax could have been parsed successfully without any backtracking + recovery\n    if (\n      this.recoveryEnabled &&\n      // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?\n      eFromConsumption.name === \"MismatchedTokenException\" &&\n      !this.isBackTracking()\n    ) {\n      const follows = this.getFollowsForInRuleRecovery(<any>tokType, idx);\n      try {\n        return this.tryInRuleRecovery(<any>tokType, follows);\n      } catch (eFromInRuleRecovery) {\n        if (eFromInRuleRecovery.name === IN_RULE_RECOVERY_EXCEPTION) {\n          // failed in RuleRecovery.\n          // throw the original error in order to trigger reSync error recovery\n          throw eFromConsumption;\n        } else {\n          throw eFromInRuleRecovery;\n        }\n      }\n    } else {\n      throw eFromConsumption;\n    }\n  }\n\n  saveRecogState(this: MixedInParser): IParserState {\n    // errors is a getter which will clone the errors array\n    const savedErrors = this.errors;\n    const savedRuleStack = clone(this.RULE_STACK);\n    return {\n      errors: savedErrors,\n      lexerState: this.exportLexerState(),\n      RULE_STACK: savedRuleStack,\n      CST_STACK: this.CST_STACK,\n    };\n  }\n\n  reloadRecogState(this: MixedInParser, newState: IParserState) {\n    this.errors = newState.errors;\n    this.importLexerState(newState.lexerState);\n    this.RULE_STACK = newState.RULE_STACK;\n  }\n\n  ruleInvocationStateUpdate(\n    this: MixedInParser,\n    shortName: number,\n    fullName: string,\n    idxInCallingRule: number,\n  ): void {\n    this.RULE_OCCURRENCE_STACK.push(idxInCallingRule);\n    this.RULE_STACK.push(shortName);\n    // NOOP when cst is disabled\n    this.cstInvocationStateUpdate(fullName);\n  }\n\n  isBackTracking(this: MixedInParser): boolean {\n    return this.isBackTrackingStack.length !== 0;\n  }\n\n  getCurrRuleFullName(this: MixedInParser): string {\n    const shortName = this.getLastExplicitRuleShortName();\n    return this.shortRuleNameToFull[shortName];\n  }\n\n  shortRuleNameToFullName(this: MixedInParser, shortName: number) {\n    return this.shortRuleNameToFull[shortName];\n  }\n\n  public isAtEndOfInput(this: MixedInParser): boolean {\n    return this.tokenMatcher(this.LA(1), EOF);\n  }\n\n  public reset(this: MixedInParser): void {\n    this.resetLexerState();\n    this.subruleIdx = 0;\n    this.isBackTrackingStack = [];\n    this.errors = [];\n    this.RULE_STACK = [];\n    // TODO: extract a specific reset for TreeBuilder trait\n    this.CST_STACK = [];\n    this.RULE_OCCURRENCE_STACK = [];\n  }\n}\n","import {\n  IParserConfig,\n  IParserErrorMessageProvider,\n  IRecognitionException,\n} from \"@chevrotain/types\";\nimport {\n  EarlyExitException,\n  isRecognitionException,\n  NoViableAltException,\n} from \"../../exceptions_public.js\";\nimport { clone, has } from \"lodash-es\";\nimport {\n  getLookaheadPathsForOptionalProd,\n  getLookaheadPathsForOr,\n  PROD_TYPE,\n} from \"../../grammar/lookahead.js\";\nimport { MixedInParser } from \"./parser_traits.js\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser.js\";\n\n/**\n * Trait responsible for runtime parsing errors.\n */\nexport class ErrorHandler {\n  _errors: IRecognitionException[];\n  errorMessageProvider: IParserErrorMessageProvider;\n\n  initErrorHandler(config: IParserConfig) {\n    this._errors = [];\n    this.errorMessageProvider = has(config, \"errorMessageProvider\")\n      ? (config.errorMessageProvider as IParserErrorMessageProvider) // assumes end user provides the correct config value/type\n      : DEFAULT_PARSER_CONFIG.errorMessageProvider;\n  }\n\n  SAVE_ERROR(\n    this: MixedInParser,\n    error: IRecognitionException,\n  ): IRecognitionException {\n    if (isRecognitionException(error)) {\n      error.context = {\n        ruleStack: this.getHumanReadableRuleStack(),\n        ruleOccurrenceStack: clone(this.RULE_OCCURRENCE_STACK),\n      };\n      this._errors.push(error);\n      return error;\n    } else {\n      throw Error(\n        \"Trying to save an Error which is not a RecognitionException\",\n      );\n    }\n  }\n\n  get errors(): IRecognitionException[] {\n    return clone(this._errors);\n  }\n\n  set errors(newErrors: IRecognitionException[]) {\n    this._errors = newErrors;\n  }\n\n  // TODO: consider caching the error message computed information\n  raiseEarlyExitException(\n    this: MixedInParser,\n    occurrence: number,\n    prodType: PROD_TYPE,\n    userDefinedErrMsg: string | undefined,\n  ): never {\n    const ruleName = this.getCurrRuleFullName();\n    const ruleGrammar = this.getGAstProductions()[ruleName];\n    const lookAheadPathsPerAlternative = getLookaheadPathsForOptionalProd(\n      occurrence,\n      ruleGrammar,\n      prodType,\n      this.maxLookahead,\n    );\n    const insideProdPaths = lookAheadPathsPerAlternative[0];\n    const actualTokens = [];\n    for (let i = 1; i <= this.maxLookahead; i++) {\n      actualTokens.push(this.LA(i));\n    }\n    const msg = this.errorMessageProvider.buildEarlyExitMessage({\n      expectedIterationPaths: insideProdPaths,\n      actual: actualTokens,\n      previous: this.LA(0),\n      customUserDescription: userDefinedErrMsg,\n      ruleName: ruleName,\n    });\n\n    throw this.SAVE_ERROR(new EarlyExitException(msg, this.LA(1), this.LA(0)));\n  }\n\n  // TODO: consider caching the error message computed information\n  raiseNoAltException(\n    this: MixedInParser,\n    occurrence: number,\n    errMsgTypes: string | undefined,\n  ): never {\n    const ruleName = this.getCurrRuleFullName();\n    const ruleGrammar = this.getGAstProductions()[ruleName];\n    // TODO: getLookaheadPathsForOr can be slow for large enough maxLookahead and certain grammars, consider caching ?\n    const lookAheadPathsPerAlternative = getLookaheadPathsForOr(\n      occurrence,\n      ruleGrammar,\n      this.maxLookahead,\n    );\n\n    const actualTokens = [];\n    for (let i = 1; i <= this.maxLookahead; i++) {\n      actualTokens.push(this.LA(i));\n    }\n    const previousToken = this.LA(0);\n\n    const errMsg = this.errorMessageProvider.buildNoViableAltMessage({\n      expectedPathsPerAlt: lookAheadPathsPerAlternative,\n      actual: actualTokens,\n      previous: previousToken,\n      customUserDescription: errMsgTypes,\n      ruleName: this.getCurrRuleFullName(),\n    });\n\n    throw this.SAVE_ERROR(\n      new NoViableAltException(errMsg, this.LA(1), previousToken),\n    );\n  }\n}\n","import {\n  ISyntacticContentAssistPath,\n  IToken,\n  ITokenGrammarPath,\n  TokenType,\n} from \"@chevrotain/types\";\nimport {\n  NextAfterTokenWalker,\n  nextPossibleTokensAfter,\n} from \"../../grammar/interpreter.js\";\nimport { first, isUndefined } from \"lodash-es\";\nimport { MixedInParser } from \"./parser_traits.js\";\n\nexport class ContentAssist {\n  initContentAssist() {}\n\n  public computeContentAssist(\n    this: MixedInParser,\n    startRuleName: string,\n    precedingInput: IToken[],\n  ): ISyntacticContentAssistPath[] {\n    const startRuleGast = this.gastProductionsCache[startRuleName];\n\n    if (isUndefined(startRuleGast)) {\n      throw Error(`Rule ->${startRuleName}<- does not exist in this grammar.`);\n    }\n\n    return nextPossibleTokensAfter(\n      [startRuleGast],\n      precedingInput,\n      this.tokenMatcher,\n      this.maxLookahead,\n    );\n  }\n\n  // TODO: should this be a member method or a utility? it does not have any state or usage of 'this'...\n  // TODO: should this be more explicitly part of the public API?\n  public getNextPossibleTokenTypes(\n    this: MixedInParser,\n    grammarPath: ITokenGrammarPath,\n  ): TokenType[] {\n    const topRuleName = first(grammarPath.ruleStack)!;\n    const gastProductions = this.getGAstProductions();\n    const topProduction = gastProductions[topRuleName];\n    const nextPossibleTokenTypes = new NextAfterTokenWalker(\n      topProduction,\n      grammarPath,\n    ).startWalking();\n    return nextPossibleTokenTypes;\n  }\n}\n","import {\n  AtLeastOneSepMethodOpts,\n  ConsumeMethodOpts,\n  CstNode,\n  DSLMethodOpts,\n  DSLMethodOptsWithErr,\n  GrammarAction,\n  IOrAlt,\n  IParserConfig,\n  IProduction,\n  IToken,\n  ManySepMethodOpts,\n  OrMethodOpts,\n  SubruleMethodOpts,\n  TokenType,\n} from \"@chevrotain/types\";\nimport {\n  forEach,\n  has,\n  isArray,\n  isFunction,\n  last as peek,\n  some,\n} from \"lodash-es\";\nimport { MixedInParser } from \"./parser_traits.js\";\nimport {\n  Alternation,\n  Alternative,\n  NonTerminal,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Rule,\n  Terminal,\n} from \"@chevrotain/gast\";\nimport { Lexer } from \"../../../scan/lexer_public.js\";\nimport {\n  augmentTokenTypes,\n  hasShortKeyProperty,\n} from \"../../../scan/tokens.js\";\nimport {\n  createToken,\n  createTokenInstance,\n} from \"../../../scan/tokens_public.js\";\nimport { END_OF_FILE } from \"../parser.js\";\nimport { BITS_FOR_OCCURRENCE_IDX } from \"../../grammar/keys.js\";\nimport { ParserMethodInternal } from \"../types.js\";\n\ntype ProdWithDef = IProduction & { definition?: IProduction[] };\nconst RECORDING_NULL_OBJECT = {\n  description: \"This Object indicates the Parser is during Recording Phase\",\n};\nObject.freeze(RECORDING_NULL_OBJECT);\n\nconst HANDLE_SEPARATOR = true;\nconst MAX_METHOD_IDX = Math.pow(2, BITS_FOR_OCCURRENCE_IDX) - 1;\n\nconst RFT = createToken({ name: \"RECORDING_PHASE_TOKEN\", pattern: Lexer.NA });\naugmentTokenTypes([RFT]);\nconst RECORDING_PHASE_TOKEN = createTokenInstance(\n  RFT,\n  \"This IToken indicates the Parser is in Recording Phase\\n\\t\" +\n    \"\" +\n    \"See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\",\n  // Using \"-1\" instead of NaN (as in EOF) because an actual number is less likely to\n  // cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n);\nObject.freeze(RECORDING_PHASE_TOKEN);\n\nconst RECORDING_PHASE_CSTNODE: CstNode = {\n  name:\n    \"This CSTNode indicates the Parser is in Recording Phase\\n\\t\" +\n    \"See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\",\n  children: {},\n};\n\n/**\n * This trait handles the creation of the GAST structure for Chevrotain Grammars\n */\nexport class GastRecorder {\n  recordingProdStack: ProdWithDef[];\n  RECORDING_PHASE: boolean;\n\n  initGastRecorder(this: MixedInParser, config: IParserConfig): void {\n    this.recordingProdStack = [];\n    this.RECORDING_PHASE = false;\n  }\n\n  enableRecording(this: MixedInParser): void {\n    this.RECORDING_PHASE = true;\n\n    this.TRACE_INIT(\"Enable Recording\", () => {\n      /**\n       * Warning Dark Voodoo Magic upcoming!\n       * We are \"replacing\" the public parsing DSL methods API\n       * With **new** alternative implementations on the Parser **instance**\n       *\n       * So far this is the only way I've found to avoid performance regressions during parsing time.\n       * - Approx 30% performance regression was measured on Chrome 75 Canary when attempting to replace the \"internal\"\n       *   implementations directly instead.\n       */\n      for (let i = 0; i < 10; i++) {\n        const idx = i > 0 ? i : \"\";\n        this[`CONSUME${idx}` as \"CONSUME\"] = function (arg1, arg2) {\n          return this.consumeInternalRecord(arg1, i, arg2);\n        };\n        this[`SUBRULE${idx}` as \"SUBRULE\"] = function (arg1, arg2) {\n          return this.subruleInternalRecord(arg1, i, arg2) as any;\n        };\n        this[`OPTION${idx}` as \"OPTION\"] = function (arg1) {\n          return this.optionInternalRecord(arg1, i);\n        };\n        this[`OR${idx}` as \"OR\"] = function (arg1) {\n          return this.orInternalRecord(arg1, i);\n        };\n        this[`MANY${idx}` as \"MANY\"] = function (arg1) {\n          this.manyInternalRecord(i, arg1);\n        };\n        this[`MANY_SEP${idx}` as \"MANY_SEP\"] = function (arg1) {\n          this.manySepFirstInternalRecord(i, arg1);\n        };\n        this[`AT_LEAST_ONE${idx}` as \"AT_LEAST_ONE\"] = function (arg1) {\n          this.atLeastOneInternalRecord(i, arg1);\n        };\n        this[`AT_LEAST_ONE_SEP${idx}` as \"AT_LEAST_ONE_SEP\"] = function (arg1) {\n          this.atLeastOneSepFirstInternalRecord(i, arg1);\n        };\n      }\n\n      // DSL methods with the idx(suffix) as an argument\n      this[`consume`] = function (idx, arg1, arg2) {\n        return this.consumeInternalRecord(arg1, idx, arg2);\n      };\n      this[`subrule`] = function (idx, arg1, arg2) {\n        return this.subruleInternalRecord(arg1, idx, arg2) as any;\n      };\n      this[`option`] = function (idx, arg1) {\n        return this.optionInternalRecord(arg1, idx);\n      };\n      this[`or`] = function (idx, arg1) {\n        return this.orInternalRecord(arg1, idx);\n      };\n      this[`many`] = function (idx, arg1) {\n        this.manyInternalRecord(idx, arg1);\n      };\n      this[`atLeastOne`] = function (idx, arg1) {\n        this.atLeastOneInternalRecord(idx, arg1);\n      };\n\n      this.ACTION = this.ACTION_RECORD;\n      this.BACKTRACK = this.BACKTRACK_RECORD;\n      this.LA = this.LA_RECORD;\n    });\n  }\n\n  disableRecording(this: MixedInParser) {\n    this.RECORDING_PHASE = false;\n    // By deleting these **instance** properties, any future invocation\n    // will be deferred to the original methods on the **prototype** object\n    // This seems to get rid of any incorrect optimizations that V8 may\n    // do during the recording phase.\n    this.TRACE_INIT(\"Deleting Recording methods\", () => {\n      const that: any = this;\n\n      for (let i = 0; i < 10; i++) {\n        const idx = i > 0 ? i : \"\";\n        delete that[`CONSUME${idx}`];\n        delete that[`SUBRULE${idx}`];\n        delete that[`OPTION${idx}`];\n        delete that[`OR${idx}`];\n        delete that[`MANY${idx}`];\n        delete that[`MANY_SEP${idx}`];\n        delete that[`AT_LEAST_ONE${idx}`];\n        delete that[`AT_LEAST_ONE_SEP${idx}`];\n      }\n\n      delete that[`consume`];\n      delete that[`subrule`];\n      delete that[`option`];\n      delete that[`or`];\n      delete that[`many`];\n      delete that[`atLeastOne`];\n\n      delete that.ACTION;\n      delete that.BACKTRACK;\n      delete that.LA;\n    });\n  }\n\n  //   Parser methods are called inside an ACTION?\n  //   Maybe try/catch/finally on ACTIONS while disabling the recorders state changes?\n  // @ts-expect-error -- noop place holder\n  ACTION_RECORD<T>(this: MixedInParser, impl: () => T): T {\n    // NO-OP during recording\n  }\n\n  // Executing backtracking logic will break our recording logic assumptions\n  BACKTRACK_RECORD<T>(\n    grammarRule: (...args: any[]) => T,\n    args?: any[],\n  ): () => boolean {\n    return () => true;\n  }\n\n  // LA is part of the official API and may be used for custom lookahead logic\n  // by end users who may forget to wrap it in ACTION or inside a GATE\n  LA_RECORD(howMuch: number): IToken {\n    // We cannot use the RECORD_PHASE_TOKEN here because someone may depend\n    // On LA return EOF at the end of the input so an infinite loop may occur.\n    return END_OF_FILE;\n  }\n\n  topLevelRuleRecord(name: string, def: Function): Rule {\n    try {\n      const newTopLevelRule = new Rule({ definition: [], name: name });\n      newTopLevelRule.name = name;\n      this.recordingProdStack.push(newTopLevelRule);\n      def.call(this);\n      this.recordingProdStack.pop();\n      return newTopLevelRule;\n    } catch (originalError) {\n      if (originalError.KNOWN_RECORDER_ERROR !== true) {\n        try {\n          originalError.message =\n            originalError.message +\n            '\\n\\t This error was thrown during the \"grammar recording phase\" For more info see:\\n\\t' +\n            \"https://chevrotain.io/docs/guide/internals.html#grammar-recording\";\n        } catch (mutabilityError) {\n          // We may not be able to modify the original error object\n          throw originalError;\n        }\n      }\n      throw originalError;\n    }\n  }\n\n  // Implementation of parsing DSL\n  optionInternalRecord<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n    occurrence: number,\n  ): OUT {\n    return recordProd.call(this, Option, actionORMethodDef, occurrence);\n  }\n\n  atLeastOneInternalRecord<OUT>(\n    this: MixedInParser,\n    occurrence: number,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>,\n  ): void {\n    recordProd.call(this, RepetitionMandatory, actionORMethodDef, occurrence);\n  }\n\n  atLeastOneSepFirstInternalRecord<OUT>(\n    this: MixedInParser,\n    occurrence: number,\n    options: AtLeastOneSepMethodOpts<OUT>,\n  ): void {\n    recordProd.call(\n      this,\n      RepetitionMandatoryWithSeparator,\n      options,\n      occurrence,\n      HANDLE_SEPARATOR,\n    );\n  }\n\n  manyInternalRecord<OUT>(\n    this: MixedInParser,\n    occurrence: number,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ): void {\n    recordProd.call(this, Repetition, actionORMethodDef, occurrence);\n  }\n\n  manySepFirstInternalRecord<OUT>(\n    this: MixedInParser,\n    occurrence: number,\n    options: ManySepMethodOpts<OUT>,\n  ): void {\n    recordProd.call(\n      this,\n      RepetitionWithSeparator,\n      options,\n      occurrence,\n      HANDLE_SEPARATOR,\n    );\n  }\n\n  orInternalRecord<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>,\n    occurrence: number,\n  ): T {\n    return recordOrProd.call(this, altsOrOpts, occurrence);\n  }\n\n  subruleInternalRecord<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    ruleToCall: ParserMethodInternal<ARGS, R>,\n    occurrence: number,\n    options?: SubruleMethodOpts<ARGS>,\n  ): R | CstNode {\n    assertMethodIdxIsValid(occurrence);\n    if (!ruleToCall || has(ruleToCall, \"ruleName\") === false) {\n      const error: any = new Error(\n        `<SUBRULE${getIdxSuffix(occurrence)}> argument is invalid` +\n          ` expecting a Parser method reference but got: <${JSON.stringify(\n            ruleToCall,\n          )}>` +\n          `\\n inside top level rule: <${\n            (<Rule>this.recordingProdStack[0]).name\n          }>`,\n      );\n      error.KNOWN_RECORDER_ERROR = true;\n      throw error;\n    }\n\n    const prevProd: any = peek(this.recordingProdStack);\n    const ruleName = ruleToCall.ruleName;\n    const newNoneTerminal = new NonTerminal({\n      idx: occurrence,\n      nonTerminalName: ruleName,\n      label: options?.LABEL,\n      // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created\n      referencedRule: undefined,\n    });\n    prevProd.definition.push(newNoneTerminal);\n\n    return this.outputCst\n      ? RECORDING_PHASE_CSTNODE\n      : <any>RECORDING_NULL_OBJECT;\n  }\n\n  consumeInternalRecord(\n    this: MixedInParser,\n    tokType: TokenType,\n    occurrence: number,\n    options?: ConsumeMethodOpts,\n  ): IToken {\n    assertMethodIdxIsValid(occurrence);\n    if (!hasShortKeyProperty(tokType)) {\n      const error: any = new Error(\n        `<CONSUME${getIdxSuffix(occurrence)}> argument is invalid` +\n          ` expecting a TokenType reference but got: <${JSON.stringify(\n            tokType,\n          )}>` +\n          `\\n inside top level rule: <${\n            (<Rule>this.recordingProdStack[0]).name\n          }>`,\n      );\n      error.KNOWN_RECORDER_ERROR = true;\n      throw error;\n    }\n    const prevProd: any = peek(this.recordingProdStack);\n    const newNoneTerminal = new Terminal({\n      idx: occurrence,\n      terminalType: tokType,\n      label: options?.LABEL,\n    });\n    prevProd.definition.push(newNoneTerminal);\n\n    return RECORDING_PHASE_TOKEN;\n  }\n}\n\nfunction recordProd(\n  prodConstructor: any,\n  mainProdArg: any,\n  occurrence: number,\n  handleSep: boolean = false,\n): any {\n  assertMethodIdxIsValid(occurrence);\n  const prevProd: any = peek(this.recordingProdStack);\n  const grammarAction = isFunction(mainProdArg) ? mainProdArg : mainProdArg.DEF;\n\n  const newProd = new prodConstructor({ definition: [], idx: occurrence });\n  if (handleSep) {\n    newProd.separator = mainProdArg.SEP;\n  }\n  if (has(mainProdArg, \"MAX_LOOKAHEAD\")) {\n    newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n  }\n\n  this.recordingProdStack.push(newProd);\n  grammarAction.call(this);\n  prevProd.definition.push(newProd);\n  this.recordingProdStack.pop();\n\n  return RECORDING_NULL_OBJECT;\n}\n\nfunction recordOrProd(mainProdArg: any, occurrence: number): any {\n  assertMethodIdxIsValid(occurrence);\n  const prevProd: any = peek(this.recordingProdStack);\n  // Only an array of alternatives\n  const hasOptions = isArray(mainProdArg) === false;\n  const alts: IOrAlt<unknown>[] =\n    hasOptions === false ? mainProdArg : mainProdArg.DEF;\n\n  const newOrProd = new Alternation({\n    definition: [],\n    idx: occurrence,\n    ignoreAmbiguities: hasOptions && mainProdArg.IGNORE_AMBIGUITIES === true,\n  });\n  if (has(mainProdArg, \"MAX_LOOKAHEAD\")) {\n    newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n  }\n\n  const hasPredicates = some(alts, (currAlt: any) => isFunction(currAlt.GATE));\n  newOrProd.hasPredicates = hasPredicates;\n\n  prevProd.definition.push(newOrProd);\n\n  forEach(alts, (currAlt) => {\n    const currAltFlat = new Alternative({ definition: [] });\n    newOrProd.definition.push(currAltFlat);\n    if (has(currAlt, \"IGNORE_AMBIGUITIES\")) {\n      currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES as boolean; // assumes end user provides the correct config value/type\n    }\n    // **implicit** ignoreAmbiguities due to usage of gate\n    else if (has(currAlt, \"GATE\")) {\n      currAltFlat.ignoreAmbiguities = true;\n    }\n    this.recordingProdStack.push(currAltFlat);\n    currAlt.ALT.call(this);\n    this.recordingProdStack.pop();\n  });\n  return RECORDING_NULL_OBJECT;\n}\n\nfunction getIdxSuffix(idx: number): string {\n  return idx === 0 ? \"\" : `${idx}`;\n}\n\nfunction assertMethodIdxIsValid(idx: number): void {\n  if (idx < 0 || idx > MAX_METHOD_IDX) {\n    const error: any = new Error(\n      // The stack trace will contain all the needed details\n      `Invalid DSL Method idx value: <${idx}>\\n\\t` +\n        `Idx value must be a none negative value smaller than ${\n          MAX_METHOD_IDX + 1\n        }`,\n    );\n    error.KNOWN_RECORDER_ERROR = true;\n    throw error;\n  }\n}\n","import { IParserConfig } from \"@chevrotain/types\";\nimport { has } from \"lodash-es\";\nimport { timer } from \"@chevrotain/utils\";\nimport { MixedInParser } from \"./parser_traits.js\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser.js\";\n\n/**\n * Trait responsible for runtime parsing errors.\n */\nexport class PerformanceTracer {\n  traceInitPerf: boolean | number;\n  traceInitMaxIdent: number;\n  traceInitIndent: number;\n\n  initPerformanceTracer(config: IParserConfig) {\n    if (has(config, \"traceInitPerf\")) {\n      const userTraceInitPerf = config.traceInitPerf;\n      const traceIsNumber = typeof userTraceInitPerf === \"number\";\n      this.traceInitMaxIdent = traceIsNumber\n        ? <number>userTraceInitPerf\n        : Infinity;\n      this.traceInitPerf = traceIsNumber\n        ? userTraceInitPerf > 0\n        : (userTraceInitPerf as boolean); // assumes end user provides the correct config value/type\n    } else {\n      this.traceInitMaxIdent = 0;\n      this.traceInitPerf = DEFAULT_PARSER_CONFIG.traceInitPerf;\n    }\n\n    this.traceInitIndent = -1;\n  }\n\n  TRACE_INIT<T>(this: MixedInParser, phaseDesc: string, phaseImpl: () => T): T {\n    // No need to optimize this using NOOP pattern because\n    // It is not called in a hot spot...\n    if (this.traceInitPerf === true) {\n      this.traceInitIndent++;\n      const indent = new Array(this.traceInitIndent + 1).join(\"\\t\");\n      if (this.traceInitIndent < this.traceInitMaxIdent) {\n        console.log(`${indent}--> <${phaseDesc}>`);\n      }\n      const { time, value } = timer(phaseImpl);\n      /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */\n      const traceMethod = time > 10 ? console.warn : console.log;\n      if (this.traceInitIndent < this.traceInitMaxIdent) {\n        traceMethod(`${indent}<-- <${phaseDesc}> time: ${time}ms`);\n      }\n      this.traceInitIndent--;\n      return value;\n    } else {\n      return phaseImpl();\n    }\n  }\n}\n","export function applyMixins(derivedCtor: any, baseCtors: any[]) {\n  baseCtors.forEach((baseCtor) => {\n    const baseProto = baseCtor.prototype;\n    Object.getOwnPropertyNames(baseProto).forEach((propName) => {\n      if (propName === \"constructor\") {\n        return;\n      }\n\n      const basePropDescriptor = Object.getOwnPropertyDescriptor(\n        baseProto,\n        propName,\n      );\n      // Handle Accessors\n      if (\n        basePropDescriptor &&\n        (basePropDescriptor.get || basePropDescriptor.set)\n      ) {\n        Object.defineProperty(\n          derivedCtor.prototype,\n          propName,\n          basePropDescriptor,\n        );\n      } else {\n        derivedCtor.prototype[propName] = baseCtor.prototype[propName];\n      }\n    });\n  });\n}\n","import { clone, forEach, has, isEmpty, map, values } from \"lodash-es\";\nimport { toFastProperties } from \"@chevrotain/utils\";\nimport { computeAllProdsFollows } from \"../grammar/follow.js\";\nimport { createTokenInstance, EOF } from \"../../scan/tokens_public.js\";\nimport {\n  defaultGrammarValidatorErrorProvider,\n  defaultParserErrorProvider,\n} from \"../errors_public.js\";\nimport {\n  resolveGrammar,\n  validateGrammar,\n} from \"../grammar/gast/gast_resolver_public.js\";\nimport {\n  CstNode,\n  IParserConfig,\n  IRecognitionException,\n  IRuleConfig,\n  IToken,\n  TokenType,\n  TokenVocabulary,\n} from \"@chevrotain/types\";\nimport { Recoverable } from \"./traits/recoverable.js\";\nimport { LooksAhead } from \"./traits/looksahead.js\";\nimport { TreeBuilder } from \"./traits/tree_builder.js\";\nimport { LexerAdapter } from \"./traits/lexer_adapter.js\";\nimport { RecognizerApi } from \"./traits/recognizer_api.js\";\nimport { RecognizerEngine } from \"./traits/recognizer_engine.js\";\n\nimport { ErrorHandler } from \"./traits/error_handler.js\";\nimport { MixedInParser } from \"./traits/parser_traits.js\";\nimport { ContentAssist } from \"./traits/context_assist.js\";\nimport { GastRecorder } from \"./traits/gast_recorder.js\";\nimport { PerformanceTracer } from \"./traits/perf_tracer.js\";\nimport { applyMixins } from \"./utils/apply_mixins.js\";\nimport { IParserDefinitionError } from \"../grammar/types.js\";\nimport { Rule } from \"@chevrotain/gast\";\nimport { IParserConfigInternal, ParserMethodInternal } from \"./types.js\";\nimport { validateLookahead } from \"../grammar/checks.js\";\n\nexport const END_OF_FILE = createTokenInstance(\n  EOF,\n  \"\",\n  NaN,\n  NaN,\n  NaN,\n  NaN,\n  NaN,\n  NaN,\n);\nObject.freeze(END_OF_FILE);\n\nexport type TokenMatcher = (token: IToken, tokType: TokenType) => boolean;\n\nexport const DEFAULT_PARSER_CONFIG: Required<\n  Omit<IParserConfigInternal, \"lookaheadStrategy\">\n> = Object.freeze({\n  recoveryEnabled: false,\n  maxLookahead: 3,\n  dynamicTokensEnabled: false,\n  outputCst: true,\n  errorMessageProvider: defaultParserErrorProvider,\n  nodeLocationTracking: \"none\",\n  traceInitPerf: false,\n  skipValidations: false,\n});\n\nexport const DEFAULT_RULE_CONFIG: Required<IRuleConfig<any>> = Object.freeze({\n  recoveryValueFunc: () => undefined,\n  resyncEnabled: true,\n});\n\nexport enum ParserDefinitionErrorType {\n  INVALID_RULE_NAME = 0,\n  DUPLICATE_RULE_NAME = 1,\n  INVALID_RULE_OVERRIDE = 2,\n  DUPLICATE_PRODUCTIONS = 3,\n  UNRESOLVED_SUBRULE_REF = 4,\n  LEFT_RECURSION = 5,\n  NONE_LAST_EMPTY_ALT = 6,\n  AMBIGUOUS_ALTS = 7,\n  CONFLICT_TOKENS_RULES_NAMESPACE = 8,\n  INVALID_TOKEN_NAME = 9,\n  NO_NON_EMPTY_LOOKAHEAD = 10,\n  AMBIGUOUS_PREFIX_ALTS = 11,\n  TOO_MANY_ALTS = 12,\n  CUSTOM_LOOKAHEAD_VALIDATION = 13,\n}\n\nexport interface IParserDuplicatesDefinitionError\n  extends IParserDefinitionError {\n  dslName: string;\n  occurrence: number;\n  parameter?: string;\n}\n\nexport interface IParserEmptyAlternativeDefinitionError\n  extends IParserDefinitionError {\n  occurrence: number;\n  alternative: number;\n}\n\nexport interface IParserAmbiguousAlternativesDefinitionError\n  extends IParserDefinitionError {\n  occurrence: number | string;\n  alternatives: number[];\n}\n\nexport interface IParserUnresolvedRefDefinitionError\n  extends IParserDefinitionError {\n  unresolvedRefName: string;\n}\n\nexport interface IParserState {\n  errors: IRecognitionException[];\n  lexerState: any;\n  RULE_STACK: number[];\n  CST_STACK: CstNode[];\n}\n\nexport type Predicate = () => boolean;\n\nexport function EMPTY_ALT(): () => undefined;\nexport function EMPTY_ALT<T>(value: T): () => T;\nexport function EMPTY_ALT(value: any = undefined) {\n  return function () {\n    return value;\n  };\n}\n\nexport class Parser {\n  // Set this flag to true if you don't want the Parser to throw error when problems in it's definition are detected.\n  // (normally during the parser's constructor).\n  // This is a design time flag, it will not affect the runtime error handling of the parser, just design time errors,\n  // for example: duplicate rule names, referencing an unresolved subrule, ect...\n  // This flag should not be enabled during normal usage, it is used in special situations, for example when\n  // needing to display the parser definition errors in some GUI(online playground).\n  static DEFER_DEFINITION_ERRORS_HANDLING: boolean = false;\n\n  /**\n   *  @deprecated use the **instance** method with the same name instead\n   */\n  static performSelfAnalysis(parserInstance: Parser): void {\n    throw Error(\n      \"The **static** `performSelfAnalysis` method has been deprecated.\" +\n        \"\\t\\nUse the **instance** method with the same name instead.\",\n    );\n  }\n\n  public performSelfAnalysis(this: MixedInParser): void {\n    this.TRACE_INIT(\"performSelfAnalysis\", () => {\n      let defErrorsMsgs;\n\n      this.selfAnalysisDone = true;\n      const className = this.className;\n\n      this.TRACE_INIT(\"toFastProps\", () => {\n        // Without this voodoo magic the parser would be x3-x4 slower\n        // It seems it is better to invoke `toFastProperties` **before**\n        // Any manipulations of the `this` object done during the recording phase.\n        toFastProperties(this);\n      });\n\n      this.TRACE_INIT(\"Grammar Recording\", () => {\n        try {\n          this.enableRecording();\n          // Building the GAST\n          forEach(this.definedRulesNames, (currRuleName) => {\n            const wrappedRule = (this as any)[\n              currRuleName\n            ] as ParserMethodInternal<unknown[], unknown>;\n            const originalGrammarAction = wrappedRule[\"originalGrammarAction\"];\n            let recordedRuleGast!: Rule;\n            this.TRACE_INIT(`${currRuleName} Rule`, () => {\n              recordedRuleGast = this.topLevelRuleRecord(\n                currRuleName,\n                originalGrammarAction,\n              );\n            });\n            this.gastProductionsCache[currRuleName] = recordedRuleGast;\n          });\n        } finally {\n          this.disableRecording();\n        }\n      });\n\n      let resolverErrors: IParserDefinitionError[] = [];\n      this.TRACE_INIT(\"Grammar Resolving\", () => {\n        resolverErrors = resolveGrammar({\n          rules: values(this.gastProductionsCache),\n        });\n        this.definitionErrors = this.definitionErrors.concat(resolverErrors);\n      });\n\n      this.TRACE_INIT(\"Grammar Validations\", () => {\n        // only perform additional grammar validations IFF no resolving errors have occurred.\n        // as unresolved grammar may lead to unhandled runtime exceptions in the follow up validations.\n        if (isEmpty(resolverErrors) && this.skipValidations === false) {\n          const validationErrors = validateGrammar({\n            rules: values(this.gastProductionsCache),\n            tokenTypes: values(this.tokensMap),\n            errMsgProvider: defaultGrammarValidatorErrorProvider,\n            grammarName: className,\n          });\n          const lookaheadValidationErrors = validateLookahead({\n            lookaheadStrategy: this.lookaheadStrategy,\n            rules: values(this.gastProductionsCache),\n            tokenTypes: values(this.tokensMap),\n            grammarName: className,\n          });\n          this.definitionErrors = this.definitionErrors.concat(\n            validationErrors,\n            lookaheadValidationErrors,\n          );\n        }\n      });\n\n      // this analysis may fail if the grammar is not perfectly valid\n      if (isEmpty(this.definitionErrors)) {\n        // The results of these computations are not needed unless error recovery is enabled.\n        if (this.recoveryEnabled) {\n          this.TRACE_INIT(\"computeAllProdsFollows\", () => {\n            const allFollows = computeAllProdsFollows(\n              values(this.gastProductionsCache),\n            );\n            this.resyncFollows = allFollows;\n          });\n        }\n\n        this.TRACE_INIT(\"ComputeLookaheadFunctions\", () => {\n          this.lookaheadStrategy.initialize?.({\n            rules: values(this.gastProductionsCache),\n          });\n          this.preComputeLookaheadFunctions(values(this.gastProductionsCache));\n        });\n      }\n\n      if (\n        !Parser.DEFER_DEFINITION_ERRORS_HANDLING &&\n        !isEmpty(this.definitionErrors)\n      ) {\n        defErrorsMsgs = map(\n          this.definitionErrors,\n          (defError) => defError.message,\n        );\n        throw new Error(\n          `Parser Definition Errors detected:\\n ${defErrorsMsgs.join(\n            \"\\n-------------------------------\\n\",\n          )}`,\n        );\n      }\n    });\n  }\n\n  definitionErrors: IParserDefinitionError[] = [];\n  selfAnalysisDone = false;\n  protected skipValidations: boolean;\n\n  constructor(tokenVocabulary: TokenVocabulary, config: IParserConfig) {\n    const that: MixedInParser = this as any;\n    that.initErrorHandler(config);\n    that.initLexerAdapter();\n    that.initLooksAhead(config);\n    that.initRecognizerEngine(tokenVocabulary, config);\n    that.initRecoverable(config);\n    that.initTreeBuilder(config);\n    that.initContentAssist();\n    that.initGastRecorder(config);\n    that.initPerformanceTracer(config);\n\n    if (has(config, \"ignoredIssues\")) {\n      throw new Error(\n        \"The <ignoredIssues> IParserConfig property has been deprecated.\\n\\t\" +\n          \"Please use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.\\n\\t\" +\n          \"See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#IGNORING_AMBIGUITIES\\n\\t\" +\n          \"For further details.\",\n      );\n    }\n\n    this.skipValidations = has(config, \"skipValidations\")\n      ? (config.skipValidations as boolean) // casting assumes the end user passing the correct type\n      : DEFAULT_PARSER_CONFIG.skipValidations;\n  }\n}\n\napplyMixins(Parser, [\n  Recoverable,\n  LooksAhead,\n  TreeBuilder,\n  LexerAdapter,\n  RecognizerEngine,\n  RecognizerApi,\n  ErrorHandler,\n  ContentAssist,\n  GastRecorder,\n  PerformanceTracer,\n]);\n\nexport class CstParser extends Parser {\n  constructor(\n    tokenVocabulary: TokenVocabulary,\n    config: IParserConfigInternal = DEFAULT_PARSER_CONFIG,\n  ) {\n    const configClone = clone(config);\n    configClone.outputCst = true;\n    super(tokenVocabulary, configClone);\n  }\n}\n\nexport class EmbeddedActionsParser extends Parser {\n  constructor(\n    tokenVocabulary: TokenVocabulary,\n    config: IParserConfigInternal = DEFAULT_PARSER_CONFIG,\n  ) {\n    const configClone = clone(config);\n    configClone.outputCst = false;\n    super(tokenVocabulary, configClone);\n  }\n}\n","import { createToken } from \"chevrotain\"\n\nfunction getTokens(v2Compatible) {\n\n  let Symbols = {\n    OR: '|',\n    ELSE: '||',\n    DYNAMIC: '$',\n    STATIC: '#',\n    ENTITY: '&',\n    OPEN_GATE: '@',\n    CLOSE_GATE: '@',\n    PENDING_GATE: '@@',\n    OPEN_SILENT: '{',\n    CLOSE_SILENT: '}',\n  };\n\n  let v2Symbols = {\n    OPEN_CHOICE: '(',\n    CLOSE_CHOICE: ')',\n    OPEN_WEIGHT: '[',\n    CLOSE_WEIGHT: ']',\n    CONTINUATION: '\\\\',\n  };\n\n  let v3Symbols = {\n    OPEN_CHOICE: '[',\n    CLOSE_CHOICE: ']',\n    OPEN_WEIGHT: '^', // also allows (int), eg. (3)\n    CLOSE_WEIGHT: '^',\n    CONTINUATION: '~',\n  };\n\n  Object.assign(Symbols, v2Compatible ? v2Symbols : v3Symbols);\n\n  const Escaped = {};\n  Object.entries(Symbols).forEach(([k, v]) => { Escaped[k] = escapeRegex(v) });\n\n  const PENDING_GATE_PATTERN = new RegExp(`${Escaped.PENDING_GATE}([0-9]{9,11})`)\n\n  Escaped.SPECIAL = Object.values(Escaped).join('').replace(/[<>]/g, ''); // allow <>& for html \n  Symbols.PENDING_GATE_RE = new RegExp(PENDING_GATE_PATTERN.source, 'g'); // for unresolved gates\n\n  const ExitGate = createToken({\n    name: \"ExitGate\",\n    pattern: new RegExp(`\\\\s*${Escaped.CLOSE_GATE}`),\n    pop_mode: true\n  });\n\n  const Gate = createToken({\n    name: \"Gate\",\n    pattern: new RegExp(`[^${Escaped.CLOSE_GATE}]+`)\n  });\n\n  const PendingGate = createToken({\n    name: \"PendingGate\",\n    pattern: PENDING_GATE_PATTERN\n  });\n\n  const EnterGate = createToken({\n    name: \"EnterGate\",\n    pattern: new RegExp(`${Escaped.OPEN_GATE}\\\\s*`),\n    push_mode: \"gate_mode\"\n  });\n\n  \n  const OC = createToken({ name: \"OC\", pattern: new RegExp(Escaped.OPEN_CHOICE + '\\\\s*') });\n  const CC = createToken({ name: \"CC\", pattern: new RegExp(`\\\\s*${Escaped.CLOSE_CHOICE}`) });\n  const OR = createToken({ name: \"OR\", pattern: /\\s*\\|\\s*/ });\n  const ELSE = createToken({ name: \"ELSE\", pattern: /\\s*\\|\\|\\s*/ });\n  const EQ = createToken({ name: \"EQ\", pattern: /\\s*=\\s*/ });\n  const TF = createToken({ name: \"TF\", pattern: /\\.[A-Za-z_0-9][A-Za-z_0-9]*(\\(\\))?/ });\n  const OS = createToken({ name: \"OS\", pattern: new RegExp(`${Escaped.OPEN_SILENT}\\\\s*`) });\n  const CS = createToken({ name: \"CS\", pattern: new RegExp(`\\\\s*${Escaped.CLOSE_SILENT}`) });\n  const SYM = createToken({ name: \"SYM\", pattern: new RegExp(`[${Escaped.DYNAMIC}${Escaped.STATIC}][A-Za-z_0-9]*`) });\n\n  const Entity = createToken({ name: \"Entity\", pattern: /&([a-z0-9]+|#[0-9]{1,6}|#x[0-9a-fA-F]{1,6});/i });\n  const Weight = createToken({ name: \"Weight\", pattern: new RegExp(`\\\\s*${Escaped.OPEN_WEIGHT}.+${Escaped.CLOSE_WEIGHT}\\\\s*`) });\n  const Raw = createToken({ name: \"Raw\", pattern: new RegExp(`[^${Escaped.SPECIAL}]+`) });\n\n  const normalMode = [Entity, Weight, ELSE, OC, CC, OR, EQ, SYM, TF, OS, CS, PendingGate, Raw, EnterGate];\n  const gateMode = [Gate, ExitGate];\n\n  const multiMode = {\n    modes: {\n      normal: normalMode,\n      gate_mode: gateMode\n    },\n    defaultMode: 'normal'\n  };\n\n  return { tokens: multiMode, Constants: { Symbols, Escaped } };\n}\n\nfunction escapeRegex(s) {\n  return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n}\n\n// console.log(getTokens().tokens.modes.normal.map(t => t.name));\n\nexport { getTokens };","\nimport { CstParser } from \"chevrotain\"\n\nclass RiScriptParser extends CstParser {\n\n  constructor(allTokens) {\n    super(allTokens, { nodeLocationTracking: \"full\" });\n    this.atomTypes = ['silent', 'assign', 'symbol', 'choice', 'pgate', 'text', 'entity'];\n    this.buildRules();\n  }\n\n  parse(opts) {\n    this.input = opts.tokens; // superclass member (do not change)\n    \n    let cst = this.script();\n    if (this.errors.length > 0) throw Error\n      (\"[PARSING]\\n\" + this.errors[0].message);\n    return cst;\n  }\n\n  buildRules() {\n\n    const $ = this, Tokens = this.tokensMap;\n\n    $.RULE(\"script\", () => {\n      $.MANY(() => $.SUBRULE($.expr));\n    });\n\n    $.RULE(\"pgate\", () => {\n      $.CONSUME(Tokens.PendingGate);\n      $.MANY(() => $.CONSUME(Tokens.TF));\n    });\n\n    $.RULE(\"entity\", () => {\n      $.CONSUME(Tokens.Entity);\n    });\n\n    $.RULE(\"gate\", () => {\n      $.CONSUME(Tokens.EnterGate);\n      $.MANY(() => $.CONSUME(Tokens.Gate));\n      $.CONSUME(Tokens.ExitGate);\n    });\n\n    $.RULE(\"silent\", () => {\n      $.CONSUME(Tokens.OS);\n      $.OPTION1(() => $.SUBRULE($.gate));\n      $.CONSUME(Tokens.SYM);\n      $.OPTION2(() => {\n        $.CONSUME(Tokens.EQ);\n        $.SUBRULE($.expr);\n      });\n      $.CONSUME(Tokens.CS);\n    });\n\n    $.RULE(\"assign\", () => {\n      $.CONSUME(Tokens.SYM);\n      $.CONSUME(Tokens.EQ);\n      $.SUBRULE($.expr);\n    });\n\n    $.RULE(\"symbol\", () => {\n      $.CONSUME(Tokens.SYM);\n      $.MANY(() => $.CONSUME(Tokens.TF));\n    });\n\n    $.RULE(\"accept\", () => {\n      $.SUBRULE($.or_expr);\n    });\n\n    $.RULE(\"reject\", () => {\n      $.SUBRULE($.or_expr);\n    });\n\n    $.RULE(\"or_expr\", () => {\n      $.MANY_SEP({\n        SEP: Tokens.OR,\n        DEF: () => $.SUBRULE($.wexpr)\n      });\n    });\n\n    // choice: (LP (wexpr OR)* wexpr RP) transform*;\n    $.RULE(\"choice\", () => {\n      $.CONSUME(Tokens.OC)\n      $.OPTION1(() => $.SUBRULE($.gate));\n      $.SUBRULE($.accept)\n      // $.MANY_SEP({\n      //   SEP: Tokens.OR,\n      //   DEF: () => $.SUBRULE($.wexpr)\n      // });\n      $.OPTION2(() => {\n        $.CONSUME(Tokens.ELSE);\n        $.SUBRULE($.reject)\n      });\n      $.CONSUME(Tokens.CC);\n      $.MANY(() => $.CONSUME(Tokens.TF));\n    });\n\n    $.RULE(\"wexpr\", () => {\n      $.MANY(() => {\n        $.OR([\n          { ALT: () => $.SUBRULE($.expr) },\n          { ALT: () => $.CONSUME(Tokens.Weight) },\n        ])\n      });\n    });\n\n    $.RULE(\"expr\", () => {\n      $.AT_LEAST_ONE(() => $.SUBRULE($.atom));\n    });\n\n    $.RULE(\"atom\", () => {\n      $.OR(this.atomTypes.map(t => ({ ALT: () => $.SUBRULE($[t]) })));\n    });\n\n    $.RULE(\"text\", () => {\n      $.CONSUME(Tokens.Raw);\n    });\n\n    this.performSelfAnalysis(); // keep\n  }\n}\n\nexport { RiScriptParser };","\nclass BaseVisitor {\n  constructor(riScript) {\n    this.input = 0;\n\n    this.path = '';\n    this.tracePath = true;\n    this.scripting = riScript;\n    this.warnOnInvalidGates = false;\n    this.RiScript = this.scripting.constructor; // class hack\n  }\n\n  isCstNode(o) {\n    return (typeof o === 'object' &&\n      ('accept' in o || ('name' in o && 'location' in o && 'children' in o)));\n  }\n\n  visit(cstNode, param) {\n    if (Array.isArray(cstNode)) {\n      cstNode = cstNode[0];\n    }\n    if (typeof cstNode === 'undefined') {\n      return undefined;\n    }\n    if (!this.isCstNode(cstNode)) {\n      throw Error('Non-cstNode passed to visit: ' + JSON.stringify(cstNode));\n    }\n\n    const { name, location } = cstNode;\n\n    this.nodeText = this.input.substring(\n      location.startOffset,\n      location.endOffset + 1\n    );\n\n    if (typeof this[name] !== 'function') {\n      throw Error('BaseVisitor.visit: expecting function for this[' +\n        `${name}], found ${typeof this[name]}: ${JSON.stringify(this[name])}`);\n    }\n\n    if (this.tracePath && !/(expr|atom|silent)/.test(name)) {\n      this.path += name + '.';\n    }\n    return this[name](cstNode.children, param);\n  }\n\n  validateVisitor() {\n    /* no-op */\n  }\n}\n\nclass RiScriptVisitor extends BaseVisitor {\n  constructor(riScript, context = {}) {\n    super(riScript); // stored as global RiScript (TODO)\n    this.context = context;\n\n    this.trace = 0;\n    this.choices = {};\n    this.isNoRepeat = false;\n    this.symbols = this.scripting.Symbols;\n    this.escaped = this.scripting.Escaped;\n\n    // lookups\n    this.statics = {};\n    this.dynamics = {};\n    this.pendingGates = {};\n    this.pendingSymbols = new Set();\n\n    this.validateVisitor(); // keep\n  }\n\n  start(opts = {}) {\n    this.input = opts.input;\n    this.trace = opts.trace;\n    this.traceTx = opts.traceTx;\n    if (!opts.cst) throw Error('no cst');\n    return super.visit(opts.cst);\n  }\n\n  script(ctx) {\n    this.order = 0;\n    const count = ctx.expr ? ctx.expr.length : 0;\n    this.print('script', \"'\" + this.RiScript._escapeText(this.input)\n      + \"' :: \" + count + ' expression(s)');\n    if (!count) return '';\n    if (Object.keys(ctx).length !== 1) throw Error('script: invalid expr');\n    return this.visit(ctx.expr);\n  }\n\n  expr(ctx) {\n    // this.print('expr', ctx);\n    const types = Object.keys(ctx);\n    if (types.length !== 1) throw Error('invalid expr: ' + types.length);\n    const exprs = ctx.atom.map((c) => this.visit(c));\n    // handle special cases of the form: \"not [quite|] far enough\"\n    for (let i = 1; i < exprs.length - 1; i++) {\n      if (\n        exprs[i].length === 0 &&\n        exprs[i - 1].endsWith(' ') &&\n        exprs[i + 1].startsWith(' ')\n      ) {\n        exprs[i + 1] = exprs[i + 1].substring(1);\n      }\n    }\n    return exprs.join('');\n  }\n\n  wexpr(ctx) {\n    this.print('wexpr');\n  }\n\n  gate(ctx) {\n    // returns { decision: [accept | reject] } or { decision: 'defer', operands: [] }\n\n    if (ctx.Gate.length !== 1) throw Error('Invalid gate: ' + ctx.Gate);\n\n    let mingoQuery;\n    const raw = ctx.Gate[0].image;\n    try {\n      mingoQuery = this.scripting._query(raw);\n    } catch (e) {\n      if (!this.warnOnInvalidGates) {\n        throw Error(`Invalid gate[2]: \"@${raw}@\"\\n\\nRootCause -> ${e}`);\n      }\n      if (!this.scripting.RiTa.SILENT && !this.scripting.silent) {\n        console.warn(`[WARN] Ignoring invalid gate: @${raw}@\\n`, e);\n      }\n      return { decision: 'accept' };\n    }\n\n    const resolvedOps = {};\n    const unresolvedOps = [];\n    const operands = mingoQuery.operands();\n    operands.forEach((sym) => {\n      let { result, resolved, isStatic, isUser } = this.checkContext(sym);\n\n      if (typeof result === 'function') {\n        // while {} ?\n        result = result.call(); // call it\n        resolved = !this.scripting.isParseable(result);\n      }\n      if (typeof result === 'undefined' || !resolved) {\n        unresolvedOps.push(sym);\n      } else {\n        // add to appropriate context\n        if (isStatic) {\n          this.statics[sym] = result;\n        } else if (isUser) {\n          this.context[sym] = result;\n        } else {\n          this.dynamics[sym] = result;\n        }\n        // store resolved result\n        resolvedOps[sym] = result;\n      }\n    });\n\n    if (\n      Object.keys(resolvedOps).length + unresolvedOps.length !==\n      operands.length\n    ) { throw Error('invalid operands'); }\n\n    // if we have unresolved operands, return them (and defer)\n    if (unresolvedOps.length) { return { decision: 'defer', operands: unresolvedOps }; }\n\n    let result = mingoQuery.test(resolvedOps); // do test\n    if (!result && this.castValues(resolvedOps)) {\n      result = mingoQuery.test(resolvedOps); // redo test after casting\n    }\n\n    return { decision: result ? 'accept' : 'reject' };\n  }\n\n  assign(ctx, opts) {\n    const sym = ctx.SYM[0].image;\n    let value;\n    let info;\n    const ident = sym.replace(this.scripting.AnySymbolRE, '');\n    const isStatic = sym.startsWith(this.symbols.STATIC);\n\n    if (isStatic) {\n      value = this.visit(ctx.expr);\n      if (this.scripting.isParseable(value)) {\n        this.statics[ident] = value; // store in lookup table ??\n        value = this.inlineAssignment(ident, ctx.TF, value);\n      } else {\n        this.statics[ident] = value; // store in lookup table\n        this.pendingSymbols.delete(ident); // no longer pending\n        this.trace &&\n          console.log('  [pending.delete]', sym,\n            this.pendingSymbols.length\n              ? JSON.stringify(this.pendingSymbols)\n              : ''\n          );\n      }\n      info = `${sym} = ${this.RiScript._escapeText(value)}` +\n        ` [#static] ${opts?.silent ? '{silent}' : ''}`;\n    } else {\n      const $ = this;\n\n      // dynamic: store as func to be resolved later, perhaps many times\n      value = () => $.visit(ctx.expr);\n      info = `${sym} = <f*:pending>` + (opts?.silent ? '{silent}' : '');\n\n      // NOTE: this function may contain a choice, which needs to be handled\n      // when called from a symbol with a norepeat transform (??) TODO: test\n\n      this.dynamics[ident] = value; // store in lookup table\n    }\n    this.print('assign', info);\n\n    return value;\n  }\n\n  silent(ctx) {\n    if (ctx.EQ) {\n      this.assign(ctx, { silent: true });\n    } else {\n      this.symbol(ctx, { silent: true });\n    }\n    return '';\n  }\n\n  atom(ctx) {\n    let result;\n    const types = Object.keys(ctx);\n    if (types.length !== 1) throw Error('invalid atom: ' + types);\n    this.scripting.parser.atomTypes.forEach((type) => {\n      const context = ctx[type];\n      if (context) {\n        if (context.length !== 1) {\n          throw Error(type + ': bad length -> ' + ctx[type].length);\n        }\n        // console.log(type + ':', context[0]);\n        result = this.visit(context[0]);\n      }\n    });\n\n    // pending function, call it\n    if (typeof result === 'function') {\n      result = result.call();\n    }\n    return result;\n  }\n\n  text(ctx) {\n    if (ctx.Raw.length !== 1) throw Error('[1] invalid text');\n    if (Object.keys(ctx).length !== 1) throw Error('[2] invalid text');\n    const image = ctx.Raw[0].image;\n    this.print('text', this.RiScript._escapeText(\"'\" + image + \"'\"));\n    return image;\n  }\n\n  entity(ctx) {\n    return this.nodeText;\n  }\n\n  symbol(ctx, opts) {\n    if (ctx.SYM.length !== 1) throw Error('[1] invalid symbol');\n\n    const original = this.nodeText;\n    const symbol = ctx.SYM[0].image;\n    const ident = symbol.replace(this.scripting.AnySymbolRE, '');\n\n    this.isNoRepeat = this.hasNoRepeat(ctx.TF);\n\n    if (this.pendingSymbols.has(ident)) {\n      this.print('symbol', `${symbol} [is-pending]`);\n      return original;\n    }\n\n    // lookup: result is either a value, a function, or undef\n    let { result, isStatic, isUser, resolved } = this.checkContext(ident);\n\n    if (!isStatic && symbol.startsWith(this.symbols.STATIC)) {\n      if (!this.scripting.EntityRE.test(symbol)) {\n        throw Error(`Attempt to refer to dynamic symbol '${ident}' as` +\n          ` ${this.symbols.STATIC}${ident}, did you mean $${ident}?`);\n      }\n    }\n\n    if (typeof result === 'function') {\n      // while {} ?\n      result = result.call(); // call it\n      resolved = !this.scripting.isParseable(result);\n    }\n\n    if (this.isNoRepeat && (isStatic || isUser)) {\n      this.isNoRepeat = false;\n      const msg = 'Attempt to call norepeat() on ' + (isStatic\n        ? \"static symbol '\" + symbol + \"'. Did you mean to use '\" +\n        this.symbols.DYNAMIC + ident + \"' ?\"\n        : \"non-dynamic symbol '\" + ident + \"'. Did you mean to define '\" +\n        this.symbols.DYNAMIC + ident + \"' in riscript?\");\n      throw Error(msg);\n    }\n\n    if (typeof result === 'undefined') {\n      // nothing found, defer\n      this.print('symbol', symbol + \" -> '\" + original + \"' ctx=\" +\n        this.lookupsToString(), '[deferred]', opts?.silent ? '{silent}' : '');\n      return original;\n    }\n\n    let info = original + \" -> '\" + result + \"'\" + (opts?.silent ? ' {silent}' : '');\n\n    // defer if we still have unresolved riscript\n    if (typeof result === 'string' && !resolved) {\n      if (isStatic) {\n        this.pendingSymbols.add(ident);\n        result = this.inlineAssignment(ident, ctx.TF, result);\n        this.print('symbol*', `${original} -> ${result} :: pending.add(${ident})`);\n      } else {\n        if (ctx.TF) result = this.restoreTransforms(result, ctx.TF);\n        this.print('symbol', info);\n      }\n      return result;\n    }\n\n    if (isStatic) {\n      // store !untransformed! result in static context\n      this.statics[ident] = result; // ADDED 8/18/23 - FIXED 10/8/23\n    }\n\n    if (ctx.TF) {\n      result = this.applyTransforms(result, ctx.TF);\n      info += \" -> '\" + result + \"'\";\n      // info += \" -> \" + ctx.TF.map(tf => ` ${tf.image} -> `) + '\\'' + result + \"'\";\n      // console.log(\"INFO: \" + info);\n      if (this.isNoRepeat) info += ' (norepeat)';\n    }\n\n    this.print('symbol', info);\n\n    // resolved, so remove from pending\n    if (this.pendingSymbols.has(ident)) {\n      this.trace && console.log('  [$pending.delete]', (isStatic ? '#' : '$') + ident,\n        this.pendingSymbols.length ? JSON.stringify(this.pendingSymbols) : '');\n      this.pendingSymbols.delete(ident);\n    }\n    this.isNoRepeat = false; // reset\n\n    return result;\n  }\n\n  pgate(ctx) {\n    this.print('pgate', this.nodeText);\n    // new RegExp(`^${this.symbols.PENDING_GATE}`\n    const original = this.nodeText;\n    const ident = original.replace(this.symbols.PENDING_GATE, '');\n    const lookup = this.pendingGates[ident];\n\n    if (!lookup) {\n      throw Error('no pending gate=\"' + original + '\" pgates=' +\n        JSON.stringify(Object.keys(this.pendingGates)));\n    }\n\n    const stillUnresolved = lookup.operands.some((o) => {\n      let { result, resolved } = this.checkContext(o);\n      if (typeof result === 'function') {\n        // while {} ?\n        result = result.call(); // call it\n        resolved = !this.scripting.isParseable(result);\n      }\n      return typeof result === 'undefined' || !resolved;\n    });\n\n    if (stillUnresolved) return original; // still deferred\n\n    const result = this.choice(lookup.deferredContext); // execute the gate\n    return result;\n  }\n\n  else(ctx) {\n    // this.print('else', this.nodeText);\n    return this.visit(ctx.expr).trim();\n  }\n\n  choice(ctx, opts) {\n    const $ = this.symbols;\n    let rawGate, gateResult;\n    const original = this.nodeText;\n    let info = original;\n    const choiceKey = this.RiScript._stringHash(original + ' #' + this.choiceId(ctx));\n\n    if (!this.isNoRepeat && this.hasNoRepeat(ctx.TF)) {\n      throw Error('noRepeat() not allowed on choice (use a $variable instead): ' + original);\n    }\n\n    let decision = 'accept';\n    if (opts?.forceReject) {\n      decision = 'reject';\n    } else {\n      if (ctx.gate) {\n        // do we have a gate\n        rawGate = ctx.gate[0].children.Gate[0].image;\n        gateResult = this.visit(ctx.gate);\n        decision = gateResult.decision;\n        info += `\\n  [gate] ${rawGate} -> ${decision !== 'defer'\n          ? decision.toUpperCase()\n          : `DEFER ${$.PENDING_GATE}${choiceKey}`\n          }  ${this.lookupsToString()}`;\n      }\n\n      if (gateResult) {\n        if (gateResult.decision === 'defer') {\n          this.pendingGates[choiceKey] = {\n            deferredContext: ctx,\n            operands: gateResult.operands\n          };\n          return `${$.PENDING_GATE}${choiceKey}`; // gate defers\n        }\n      }\n    }\n\n    if (decision === 'reject' && !('reject' in ctx)) {\n      return ''; // rejected without reject expr, return ''\n    }\n\n    const orExpr = ctx[decision]?.[0]?.children?.or_expr?.[0]; // yuck\n    const options = this.parseOptions(orExpr); // get options\n    if (!options) throw Error('No options in choice: ' + original);\n\n    let value = null;\n    const excluded = [];\n    let restored = false;\n    while (value === null) {\n      value = this.choose(options, excluded).value;\n\n      // if we still have script, defer until its resolved\n      if (this.scripting.isParseable(value)) {\n        if (ctx.TF) value = this.restoreTransforms(value, ctx.TF);\n        restored = true;\n        break;\n      }\n\n      // apply any remaining transforms\n      if (ctx.TF) value = this.applyTransforms(value, ctx.TF);\n\n      // we have 'norepeat' but value was already used, try again\n      if (this.isNoRepeat && value === this.choices[choiceKey]) {\n        this.print('choice.reject', value + ' [norepeat]');\n        excluded.push(value);\n        value = null;\n        continue;\n      }\n    }\n\n    if (!restored) this.choices[choiceKey] = value; // put in choice cache\n\n    return value;\n  }\n\n  // Helpers ================================================\n\n  hasNoRepeat(tfs) {\n    const transforms = this.RiScript._transformNames(tfs);\n    if (transforms.length) {\n      return transforms.includes('nr') || transforms.includes('norepeat');\n    }\n    return false;\n  }\n\n  checkContext(ident) {\n    let isStatic = false;\n    let isUser = false;\n    let result;\n\n    if (ident.length === 0) {\n      return { result: '', resolved: true, isStatic, isUser };\n    }\n\n    // check for dynamic symbol: $var\n    result = this.dynamics[ident];\n    if (typeof result === 'undefined') {\n      // no dynamic\n\n      // check for static symbol: #var\n      result = this.statics[ident];\n      if (typeof result !== 'undefined') {\n        isStatic = true; // found static\n      }\n    }\n\n    if (typeof result === 'undefined') {\n      // no static\n      // check for user-defined symbol: context[var]\n      result = this.context[ident];\n      if (typeof result !== 'undefined') {\n        isUser = true; // found user symbol\n      } else {\n        // check for user-defined dynamic? context[$var]\n        result = this.context[this.symbols.DYNAMIC + ident];\n        if (typeof result !== 'undefined') {\n          // no static\n          // note: treat as normal dynamic, isUser = false\n        }\n      }\n    }\n\n    // do we have more script to deal with ?\n    const resolved = !this.scripting.isParseable(result);\n\n    return { result, isStatic, isUser, resolved }; // TODO: replace with 'type'\n  }\n\n  inlineAssignment(ident, tfs, result) {\n    const $ = this.symbols;\n    const lhs = $.STATIC + ident;\n    const rhs = this.restoreTransforms(result, tfs);\n    result = $.OPEN_CHOICE + (lhs + '=' + rhs) + $.CLOSE_CHOICE;\n    return result;\n  }\n\n  choiceId(ctx) {\n    if (!ctx.OC || !ctx.OC.length) throw Error('invalid choice');\n    return ctx.OC[0].startOffset + '.' + ctx.OC[0].endOffset;\n  }\n\n  parseOptions(ctx) {\n    const options = [];\n    if (ctx && ctx?.children?.wexpr) {\n      const wexprs = ctx.children.wexpr;\n      for (let i = 0; i < wexprs.length; i++) {\n        const wexpr = wexprs[i];\n        const expr = wexpr.children.expr;\n        if (expr && expr.length != 1) { throw Error('invalid choice-expr: ' + expr.length); }\n\n        const weight = wexpr.children.Weight;\n        if (weight) {\n          if (weight.length != 1) { throw Error('invalid weight: ' + weight.length); }\n          let mult = 1;\n          try {\n            mult = parseInt(\n              this.symbols.CLOSE_WEIGHT.length\n                ? weight[0].image.trim().slice(1, -1)\n                : weight[0].image.trim().slice(1)\n            );\n          } catch (e) {\n            console.log('EX: ' + mult);\n          }\n          Array.from({ length: mult }, () => options.push(expr));\n        } else {\n          options.push(expr || '');\n        }\n      }\n    }\n    return options;\n  }\n\n  chooseUnique(options, choiceKey) {\n    // not used\n\n    const isUnique = false;\n    while (options.length && !isUnique) {\n      const { index, value } = this.choose(options);\n      if (value !== this.choices[choiceKey]) return value;\n      // console.log(`Skipping ${index}: '${value}'`);\n      options.splice(index, 1);\n    }\n    throw Error('No remaining options');\n  }\n\n  choose(options, excludes = []) {\n    if (!options || !options.length) {\n      throw Error('Invalid choice: no options');\n    }\n\n    const valid = options.filter((x) => !excludes.includes(x));\n    if (!valid.length) {\n      throw Error('Invalid choice: no valid options');\n    }\n\n    const index = this.scripting.RiTa.randi(valid.length);\n\n    let value = ''; const selected = valid[index];\n\n    if (typeof selected === 'string') {\n      this.print('choice.text', \"''\");\n    } else {\n      // if (typeof selected === 'object') {\n      this.path = 'choice.' + this.path;\n      value = this.visit(selected); // cstNode\n    }\n\n    if (typeof value === 'string') value = value.trim();\n\n    return { index, value };\n  }\n\n  applyTransforms(value, txs) {\n    if (this.traceTx) { console.log('applyTransforms', this.formatTxs(...arguments)); }\n    for (let i = 0; i < txs.length; i++) {\n      value = this.applyTransform(value, txs[i]);\n    }\n    return value;\n  }\n\n  // value is not yet resolved, so store with transform for later\n  restoreTransforms(value, txs) {\n    if (typeof value === 'string') {\n      const patt = new RegExp(\n        '^' + this.escaped.OPEN_CHOICE + '.*' + this.escaped.CLOSE_CHOICE + '$'\n      );\n      if (!patt.test(value)) {\n        // wrap in choice to preserve\n        value = this.symbols.OPEN_CHOICE + value + this.symbols.CLOSE_CHOICE;\n      }\n      if (txs) {\n        txs.forEach((tx) => (value += tx.image)); // append transform strings\n      }\n      if (this.traceTx) console.log('restoreTransforms:', value);\n    }\n    return value;\n  }\n\n  castValues(obj) {\n    let madeCast = false;\n    Object.entries(obj).forEach(([k, v]) => {\n      const num = parseFloat(v);\n      if (!isNaN(num)) {\n        madeCast = true;\n        obj[k] = num; // update object with casted value\n      }\n    });\n    return madeCast;\n  }\n\n  contextIsResolved(table) {\n    let allResolved = true;\n    Object.entries(table).forEach(([key, val]) => {\n      if (!this.scripting.isParseable(val)) {\n        allResolved = false;\n      }\n    });\n    return allResolved;\n  }\n\n  applyTransform(target, transform) {\n    const image = transform.image;\n    let result;\n    const raw = target + image;\n    const tx = image.substring(1).replace(/\\(\\)$/, '');\n\n    // function in dynamics\n    if (typeof this.dynamics[tx] === 'function') {\n      result = this.dynamics[tx](target);\n    }\n    // function in statics\n    else if (typeof this.statics[tx] === 'function') {\n      result = this.statics[tx](target);\n    }\n    // function in context\n    else if (typeof this.context[tx] === 'function') {\n      result = this.context[tx](target);\n    }\n\n    // function in transforms\n    else if (typeof this.RiScript.transforms[tx] === 'function') {\n      result = this.RiScript.transforms[tx](target);\n    }\n    // member functions (usually on String)\n    else if (typeof target[tx] === 'function') {\n      result = target[tx]();\n    } else {\n      // check for property\n      if (target.hasOwnProperty(tx)) {\n        result = target[tx];\n      } else {\n        if (!this.scripting.RiTa.SILENT && !this.scripting.silent) {\n          console.warn('[WARN] Unresolved transform: ' + raw);\n        }\n\n        /* Replace transform parens so as not to trigger\n           RiScript.isParseable (for example, in v2) 0 */\n        result = raw.replace(/\\(\\)$/, '&lpar;&rpar;');\n      }\n    }\n\n    if (this.trace) { console.log(`${this.tindent()}[transform] ${raw} -> '${result}'`); }\n\n    return result;\n  }\n\n  lookupsToString() {\n    const dyns = {};\n    const stats = {};\n    Object.entries(this.dynamics || {}).forEach(\n      ([k, v]) => (dyns[`$${k} `] = v)\n    );\n    Object.entries(this.statics || {}).forEach(\n      ([k, v]) => (stats[`#${k} `] = v)\n    );\n    return JSON.stringify({ ...this.context, ...stats, ...dyns }, (k, v) =>\n      typeof v === 'function' ? '<f*:pending>' : v\n    ).replace(/\"/g, '');\n  }\n\n  formatTxs(value, txs) {\n    return value + txs.map((tx) => tx.image.replace(/()/, '') + '()').join('');\n  }\n\n  print(s, ...args) {\n    if (this.trace) {\n      if (this.path && s !== 'script') {\n        s = this.path.replace(/\\.$/, '');\n      }\n      console.log(++this.order, `[${s}]`, ...args);\n      this.path = '';\n    }\n  }\n\n  tindent() {\n    return ' '.repeat((this.order + '').length + 1);\n  }\n}\n\nexport { RiScriptVisitor };\n\n// console.log('&#33; -> '+decode('&#33;'));\n// console.log('&amp; -> '+decode('&amp;'));\n","import { RiScript } from './riscript.js'\n\nclass RiGrammar {\n\n  constructor(rules = {}, context = {}) {\n    if (typeof rules !== 'object') {\n      throw Error('RiGrammar: expecting object, found ' + typeof rules);\n    }\n\n    this.scripting = new RiScript();\n    this.context = context;\n    this.setRules(rules);\n  }\n\n  static expand(rules, context, opts) {\n    return new RiGrammar(rules, context).expand(opts);\n  }\n\n  addTransform() {\n    return RiScript.addTransform(...arguments);\n  }\n  removeTransform() {\n    return RiScript.removeTransform(...arguments);\n  }\n  getTransforms() {\n    return RiScript.transforms;\n  }\n\n  equals(rg) {\n    return rg.toJSON() === this.toJSON();\n  }\n\n  expand(opts = {}) {\n    if ('context' in opts) {\n      throw Error('pass context to RiScript.grammar() or new RiGrammar() instead');\n    }\n\n    // TODO: clone opts here ?\n    opts.visitor = opts.visitor || new RiScript.Visitor(this.scripting);\n    opts.visitor.context = this.context || {};\n    opts.input = this._toScript(opts);\n    // opts.noAddedSilence = true;\n\n    return this.scripting._evaluate(opts);\n  }\n\n  addRule(name, def) {\n    this._validateRule(name, def);\n    this.rules[name] = def;\n  }\n\n  setRules(rules) {\n    if (typeof rules === 'undefined') throw Error('undefined rules');\n    this.rules = {};\n    let incoming = typeof rules === 'string' ? parseJSON(rules) : rules;\n    let self = this;\n    Object.entries(incoming).forEach((e) => self.addRule(...e));\n  }\n\n  removeRule(name) {\n    if (name in this.rules) {\n      delete this.rules[name];\n    }\n  }\n\n  toJSON() {\n    return JSON.stringify(this.rules, ...arguments);\n  }\n\n  toString(opts = {}) {\n    let replacer = opts.replacer || 0;\n    let space = opts.space || 2;\n    let lb = opts?.linebreak;\n    let res = this.toJSON(replacer, space);\n    if (lb) res = res.replace(/\\n/g, lb);\n    return res;\n  }\n\n  static fromJSON(str, opts) {\n    return new RiGrammar(JSON.parse(str), opts);\n  }\n\n  /* \n    Convert grammar to inline rules;\n    rules are dynamic, unless otherwise specified with leading #\n  */\n  _toScript(opts) {\n    let script = '',\n      start = opts.start || 'start';\n    let { Symbols } = this.scripting;\n\n    if (start.startsWith(Symbols.DYNAMIC)) {\n      start = start.substring(Symbols.DYNAMIC.length);\n    }\n\n    if (start.startsWith(Symbols.STATIC)) {\n      start = start.substring(Symbols.STATIC.length);\n    }\n\n    if (!(start in this.rules || Symbols.STATIC + start in this.rules)) {\n      throw Error('Rule: \"' + start + '\" not found in grammar');\n    }\n\n    Object.entries(this.rules).forEach(([name, rule], i) => {\n      while (name.startsWith(Symbols.DYNAMIC)) {\n        name = name.substring(1);\n      }\n      if (!name.startsWith(Symbols.STATIC)) {\n        name = Symbols.DYNAMIC + name;\n      }\n      // console.log(i,name);\n      if (!this.scripting.ChoiceWrapRE.test(rule)) {\n        // let orig = rule;\n        rule = Symbols.OPEN_CHOICE + rule + Symbols.CLOSE_CHOICE;\n        // console.log('WRAPPING: ' + orig + '->' + rule);\n      }\n      script += `${name}=${rule}\\n`;\n    });\n\n    if (opts.trace) console.log('Grammar:\\n' + script.replace(/^\\$/gm, '  $'));\n\n    script += `${Symbols.DYNAMIC}${start}`;\n    return script;\n  }\n\n  _validateRule(name, def) {\n    if (typeof name !== 'string' || name.length === 0) {\n      throw Error('expected [string] name');\n    }\n\n    if (typeof def === 'undefined') {\n      throw Error('undefined rule def: ' + name);\n    }\n    let { Symbols } = this.scripting;\n\n    if (name.startsWith(Symbols.DYNAMIC)) {\n      name = name.substring(Symbols.DYNAMIC.length);\n      throw Error(\n        'Grammar rules are dynamic by default;' +\n          \" if you need a static rule, use '\" +\n          Symbols.STATIC +\n          name +\n          \"', otherwise just use '\" +\n          name +\n          \"'.\"\n      );\n    }\n  }\n}\n\nfunction parseJSON(json) {\n  if (typeof json === 'string') {\n    try {\n      return JSON.parse(json);\n    } catch (e) {\n      throw Error(\n        'RiGrammar appears to be invalid JSON,' +\n          ' please check it at http://jsonlint.com/\\n' +\n          json\n      );\n    }\n  }\n}\n\nexport { RiGrammar };\n","import { RiScript } from './riscript.js';\nimport { RiGrammar } from './grammar.js';\nimport { RiScriptVisitor } from './visitor.js';\n\nRiScript.Grammar = RiGrammar;\nRiScript.Visitor = RiScriptVisitor;\n\nexport default RiScript\n"]}