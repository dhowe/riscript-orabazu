{"version":3,"sources":["../src/riscript.js","../src/tokens.js","../src/parser.js","../src/visitor.js"],"sourcesContent":["import he from 'he';\nimport { Query } from 'mingo';\nimport { Lexer } from 'chevrotain';\n\nimport { getTokens } from './tokens.js';\nimport { RiScriptParser } from './parser.js';\nimport { RiScriptVisitor } from './visitor.js';\n\n/*\n  Specification:\n    script: expr+\n    expr: (atom)+\n    wexpr: (atom)+ weight\n    symbol: SYM transform*\n    assign: SYM EQ expr transform*\n    gate: @mingo@\n    silent: { gate? expr }\n    atom: (choice | symbol | text | silent) weight?\n    choice: [ gate? ( expr | wexpr ) (OR  (expr | wexpr ) )* else? ] transform*\n    else: ELSE expr\n    raw: Raw\n*/\n\n// TODO: integrate with rita, test node-packages, linting, coverage?\n\nconst { decode } = he;\nconst VowelRE = /[aeiou]/;\nconst RegexEscape = '_RE_';\nconst HtmlEntities = /&([a-z0-9]+|#[0-9]{1,6}|#x[0-9a-fA-F]{1,6});/gi;\n\nclass RiQuery extends Query {\n  constructor(scripting, condition, options) {\n    if (typeof condition === 'string') {\n      let raw = condition; // eslint-disable-line\n      condition = scripting.parseJSOL(condition);\n      // console.log('RAW: ', raw, 'parsed', condition);\n    }\n    super(condition, options);\n  }\n\n  test(obj) {\n    for (let i = 0, len = this.compiled.length; i < len; i++) {\n      if (!this.compiled[i](obj)) return false;\n    }\n    return true;\n  }\n\n  operands() {\n    const stack = [this.condition];\n    const keys = new Set();\n    while (stack?.length > 0) {\n      const currentObj = stack.pop();\n      Object.keys(currentObj).forEach((key) => {\n        const value = currentObj[key];\n        // console.log(`key: ${ key }, value: ${ value } `);\n        if (!key.startsWith('$')) keys.add(key);\n        if (typeof value === 'object' && value !== null) {\n          const eles = Array.isArray(value) ? value : [value];\n          eles.forEach((ele) => stack.push(ele));\n        }\n      });\n    }\n    return Array.from(keys);\n  }\n}\n\nclass RiScript {\n  static Query = RiQuery;\n\n  static VERSION = '[VI]{version}[/VI]';\n\n  static RiTaWarnings = { plurals: false, phones: false };\n\n  static evaluate(script, context, opts = {}) {\n    return new RiScript().evaluate(script, context, opts);\n  }\n\n  constructor(opts = {}) { // private ?\n    this.visitor = 0; // created in evaluate() or passed in here\n    this.v2Compatible = opts.compatibility === 2;\n    const { Constants, tokens } = getTokens(this.v2Compatible);\n    this.Escaped = Constants.Escaped;\n    this.Symbols = Constants.Symbols;\n\n    const anysym = Constants.Escaped.STATIC + Constants.Escaped.DYNAMIC;\n    const open = Constants.Escaped.OPEN_CHOICE;\n    const close = Constants.Escaped.CLOSE_CHOICE;\n\n    this.JSOLIdentRE = new RegExp(`([${anysym}]?[A-Za-z_0-9][A-Za-z_0-9]*)\\\\s*:`, 'g');\n    this.RawAssignRE = new RegExp(`^[${anysym}][A-Za-z_0-9][A-Za-z_0-9]*\\\\s*=`);\n    this.ChoiceWrapRE = new RegExp('^' + open + '[^' + open + close + ']*' + close + '$');\n\n    this.SpecialRE = new RegExp(`[${this.Escaped.SPECIAL.replace('&', '')}]`);\n    this.ContinueRE = new RegExp(this.Escaped.CONTINUATION + '\\\\r?\\\\n', 'g');\n    this.WhitespaceRE = /[\\u00a0\\u2000-\\u200b\\u2028-\\u2029\\u3000]+/g;\n    this.AnySymbolRE = new RegExp(`[${anysym}]`); // added\n\n    this.silent = false;\n    this.lexer = new Lexer(tokens);\n    this.parser = new RiScriptParser(tokens);\n    this.RiTa = opts.RiTa || {\n      VERSION: 0,\n      randi: (k) => Math.floor(Math.random() * k),\n    }\n  }\n\n  lex(opts) {\n    if (!opts.input) throw Error('no input');\n    const lexResult = this.lexer.tokenize(opts.input);\n    if (lexResult.errors.length) {\n      console.error('Input: ' + opts.input + '\\n', lexResult.errors[0].message);\n      throw Error('[LEXING] ' + lexResult.errors[0].message);\n    }\n    if (opts.trace) this.printTokens(lexResult.tokens);\n    opts.tokens = lexResult.tokens;\n    // return lexResult;\n  }\n\n  parse(opts) {\n    opts.cst = this.parser.parse(opts);\n  }\n\n  visit(opts) {\n    return this.visitor.start(opts);\n  }\n\n  lexParseVisit(opts = {}) {\n    this.lex(opts);\n    this.parse(opts);\n    return this.visit(opts);\n  }\n\n  evaluate(script, context, opts = {}) {\n    if (typeof script !== 'string') {\n      throw Error('RiScript.evaluate() expects a string, got ' + typeof script);\n    }\n    opts.input = script;\n    opts.visitor = new RiScriptVisitor(this, context);\n    return this._evaluate(opts);\n  }\n\n  _evaluate(opts) {\n    const { input } = opts;\n\n    // opts.onepass = true; // TMP\n\n    let last, endingBreak = /\\r?\\n$/.test(input); // keep\n\n    let expr = this.preParse(input, opts);\n    if (!expr) return '';\n\n    if (opts.trace) console.log(`\\nInput:  '${RiScript._escapeText(input)}'`);\n    if (opts.trace && input !== expr) {\n      console.log(`Parsed: '${RiScript._escapeText(expr)}'`);\n    }\n\n    if (!opts.visitor) throw Error('no visitor');\n    this.visitor = opts.visitor;\n    delete opts.visitor; // remind me why\n\n    for (let i = 1; expr !== last && i <= 10; i++) {\n      last = expr;\n\n      if (opts.trace) console.log('-'.repeat(20) + ' Pass#' + i + ' ' + '-'.repeat(20));\n\n      opts.input = expr;\n      expr = this.lexParseVisit(opts); // do it\n\n      if (opts.trace) {\n        console.log(`Result(${i}) -> \"` + `${RiScript._escapeText(expr)}\"`\n          + ` ctx=${this.visitor.lookupsToString()}`);\n      }\n\n      // end if no more riscript\n      if (opts.onepass || !this.isParseable(expr)) break;\n    }\n\n    // check for unresolved symbols ([$#]) after removing HTML entities\n    if (!this.silent && !this.RiTa.SILENT) {\n      if (this.AnySymbolRE.test(expr.replace(HtmlEntities, ''))) {\n        console.warn('[WARN] Unresolved symbol(s) in \"' + expr.replace(/\\n/g, '\\\\n') + '\" ');\n      }\n    }\n\n    return this.postParse(expr, opts) + (endingBreak ? '\\n' : '');\n  }\n\n  _query(rawQuery, opts) {\n    return new RiQuery(this, rawQuery, opts);\n  }\n\n  printTokens(tokens) {\n    let s = tokens.reduce((str, t) => {\n      let { name } = t.tokenType;\n      let tag = name;\n      if (tag === 'TEXT') tag = RiScript._escapeText(t.image, 1);\n      if (tag === 'SYM') tag = 'sym(' + t.image + ')';\n      if (tag === 'TX') tag = 'tx(' + t.image + ')';\n      return str + tag + ', ';\n    }, '')\n      .slice(0, -2);\n    console.log('\\nTokens: [ ' + s + ' ]  Context:',\n      this.visitor.lookupsToString());\n  }\n\n  postParse(input, opts) {\n    if (typeof input !== 'string') return '';\n\n    // replace html entities\n    let decoded = decode(input);\n\n    // clean up whitespace, linebreaks\n    let result = decoded.replace(this.WhitespaceRE, ' ').replace(/\\r?\\n$/, '');\n\n    // handle unresolved gates\n    let gates = [...result.matchAll(this.Symbols.PENDING_GATE_RE)];\n    gates.forEach((g) => {\n      if (!g || !g[0] || !g[1]) throw Error('bad gate: ' + g);\n      let deferredGate = this.visitor.pendingGates[g[1]];\n      let { deferredContext, operands } = deferredGate;\n      if (!operands.length) throw Error('no operands');\n      let reject = this.visitor.choice(deferredContext, { forceReject: true });\n\n      result = result.replace(g[0], reject);\n      if (opts.trace) console.log('  ' + g[0] + '-> ' + reject);\n    });\n\n    if (opts.trace) console.log(`\\nFinal: '${result}'`);\n\n    if (!opts.preserveLookups) {\n      // reset lookups unless preserveLookups=true (for testing only)\n      this.visitor.statics = undefined;\n      this.visitor.dynamics = undefined;\n    }\n\n    return result;\n  }\n\n  preParse(script, opts) {\n    if (typeof script !== 'string') return '';\n\n    const $ = this.Symbols;\n\n    let input = script;\n    if (!this.v2Compatible) {\n      // handle parenthesized weights ??\n      input = input.replace(/\\((\\s*\\d+\\s*)\\)/g, '^$1^');\n    }\n\n    input = input.replace(/\\/\\*[^]*?(\\r?\\n)?\\//g, ''); // multi-line comments\n    input = input.replace(/\\/\\/[^\\n]+(\\r?\\n|$)/g, ''); // single-line comments\n    input = input.replace(this.ContinueRE, ''); // line continuations\n    input = slashEscapesToEntities(input); // double-backslashed escapes\n\n    let result = '';\n    let lines = input.split(/\\r?\\n/);\n    for (let i = 0; i < lines.length; i++) {\n      // special-case: handle assignments alone on a line\n      if (/*!opts.noAddedSilence && */ this.RawAssignRE.test(lines[i])) {\n        // a very convoluted way of preserving line-breaks inside groups\n        let eqIdx = lines[i].indexOf('=');\n        if (eqIdx < 0) throw Error('invalid state: no assigment: ' + lines[i]);\n        let lhs = lines[i].substring(0, eqIdx),\n          rhs = lines[i].substring(eqIdx + 1);\n        let opens = charCount(rhs, $.OPEN_CHOICE);\n        let closes = charCount(rhs, $.CLOSE_CHOICE);\n        while (opens > closes) {\n          let line = lines[++i];\n          rhs += '\\n' + line;\n          opens += charCount(line, $.OPEN_CHOICE);\n          closes += charCount(line, $.CLOSE_CHOICE);\n        }\n        result += $.OPEN_SILENT + (lhs + '=' + rhs) + $.CLOSE_SILENT;\n      } else {\n        result += lines[i];\n        if (i < lines.length - 1) result += '\\n';\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Parses a mingo query into JSON format\n   */\n  parseJSOL(text) {\n    const unescapeRegexProperty = (text) => {\n      // TODO: why do we need this?\n      let res = text;\n      if (\n        typeof text === 'string' &&\n        text.startsWith(RegexEscape) &&\n        text.endsWith(RegexEscape)\n      ) {\n        let parts = text.split(RegexEscape);\n        if (parts.length !== 4) throw Error('invalid regex in unescape');\n        res = new RegExp(parts[1], parts[2]);\n      }\n      return res;\n    };\n    let escaped = RiScript._escapeJSONRegex(text)\n      .replace(this.JSOLIdentRE, '\"$1\":')\n      .replace(/'/g, '\"');\n\n    // console.log(\"escaped: '\"+escaped+\"'\");\n\n    let result = JSON.parse(escaped),\n      urp = unescapeRegexProperty;\n    Object.keys(result).forEach((k) => (result[k] = urp(result[k])));\n    return result;\n  }\n\n  isParseable(s) {\n    // conservatively assume non-string/numbers are always parseable\n    let result = true;\n    let isStrOrNum = /(string|number)/.test(typeof s);\n    // if a string or num, test for special chars\n    if (isStrOrNum) result = this.SpecialRE.test(s.toString());\n    return result;\n  }\n\n  // ========================= statics ===============================\n\n\n  // Default transform that adds an article\n  static articlize(s) {\n    if (!s || !s.length) return '';\n\n    let first = s.split(/\\s+/)[0];\n\n    if (!RiScript.RiTa?.phones) {\n      if (!RiScript.RiTaWarnings.phones) {\n        console.warn('[WARN] Install RiTa for proper phonemes');\n        RiScript.RiTaWarnings.phones = true;\n      }\n      // first.startsWith('a') ? 'an ' : 'a ') + s;\n      return (/^[aeiou].*/i.test(first) ? 'an ' : 'a ') + s;\n    }\n\n    let phones = RiScript.RiTa.phones(first, { silent: true });\n\n    // could still be original word if no phones found\n    return (\n      (phones && phones.length && VowelRE.test(phones[0]) ? 'an ' : 'a ') + s\n    );\n  }\n\n  // Default transform that capitalizes the first character\n  static capitalize(s) {\n    return s ? s[0].toUpperCase() + s.substring(1) : '';\n  }\n\n  // Default transform that capitalizes the string\n  static uppercase(s) {\n    return s ? s.toUpperCase() : '';\n  }\n\n  // Default transform that wraps the string in (smart) quotes.\n  static quotify(s) {\n    return '&#8220;' + (s || '') + '&#8221;';\n  }\n\n  // Default transform that pluralizes a string (requires RiTa)\n  static pluralize(s) {\n    if (!RiScript.RiTa?.pluralize) {\n      if (!RiScript.RiTaWarnings.plurals) {\n        RiScript.RiTaWarnings.plurals = true;\n        console.warn('[WARN] Install RiTa for proper pluralization');\n      }\n      return s.endsWith('s') ? s : s + 's';\n    }\n    return RiScript.RiTa.pluralize(s);\n  }\n\n  // Default no-op transform\n  static identity(s) {\n    return s;\n  }\n\n  // static helpers\n\n  static _transformNames(txs) {\n    return txs && txs.length\n      ? txs.map((tx) => tx.image.replace(/(^\\.|\\(\\)$)/g, ''), [])\n      : [];\n  }\n\n  static _escapeText(s, quotify) {\n    if (typeof s !== 'string') return s;\n    let t = s.replace(/\\r?\\n/g, '\\\\n');\n    return quotify || !t.length ? \"'\" + t + \"'\" : t;\n  }\n\n  static _escapeJSONRegex(text) {\n    return text.replace(\n      /\\/([^/]+?)\\/([igmsuy]*)/g,\n      `\"${RegexEscape}$1${RegexEscape}$2${RegexEscape}\"`\n    );\n  }\n\n  static _stringHash(s) {\n    let chr,\n      hash = 0;\n    for (let i = 0; i < s.length; i++) {\n      chr = s.charCodeAt(i);\n      hash = (hash << 5) - hash + chr;\n      hash |= 0; // Convert to 32bit integer\n    }\n    let strHash = hash.toString();\n    return hash < 0 ? strHash.replace('-', '0') : strHash;\n  }\n}\n\n////////////////////// STATIC PROPS ///////////////////////\n\nRiScript.transforms = {\n  quotify: RiScript.quotify,\n  pluralize: RiScript.pluralize,\n  capitalize: RiScript.capitalize,\n  articlize: RiScript.articlize,\n  uppercase: RiScript.uppercase,\n\n  // sequences\n  norepeat: RiScript.identity,\n\n  // aliases\n  art: RiScript.articlize,\n  nr: RiScript.identity,\n  cap: RiScript.capitalize,\n  ucf: RiScript.capitalize, // deprecated?\n  uc: RiScript.uppercase,\n  qq: RiScript.quotify,\n  s: RiScript.pluralize,\n};\n\n///////////////////////// FUNCTIONS /////////////////////////\n\nfunction slashEscapesToEntities(s) {\n  s = replaceAll(s, '\\\\(', '&lpar;');\n  s = replaceAll(s, '\\\\)', '&rpar;');\n  s = replaceAll(s, '\\\\[', '&lsqb;');\n  s = replaceAll(s, '\\\\]', '&rsqb;');\n  s = replaceAll(s, '\\\\{', '&lcqb;');\n  s = replaceAll(s, '\\\\}', '&rcqb;');\n  s = replaceAll(s, '\\\\@', '&commat;');\n  s = replaceAll(s, '\\\\#', '&num;');\n  s = replaceAll(s, '\\\\|', ' &vert');\n  s = replaceAll(s, '\\\\=', ' &equals');\n  return s;\n}\nfunction escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\nfunction replaceAll(str, match, replacement) {\n  return str.replace(new RegExp(escapeRegExp(match), 'g'), () => replacement);\n}\nfunction charCount(str, c) {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === c) count++;\n  }\n  return count;\n}\n\nexport { RiScript };","import { createToken } from \"chevrotain\"\n\nfunction getTokens(v2Compatible) {\n\n  let Symbols = {\n    OR: '|',\n    ELSE: '||',\n    DYNAMIC: '$',\n    STATIC: '#',\n    ENTITY: '&',\n    OPEN_GATE: '@',\n    CLOSE_GATE: '@',\n    PENDING_GATE: '@@',\n    OPEN_SILENT: '{',\n    CLOSE_SILENT: '}',\n  };\n\n  let v2Symbols = {\n    OPEN_CHOICE: '(',\n    CLOSE_CHOICE: ')',\n    OPEN_WEIGHT: '[',\n    CLOSE_WEIGHT: ']',\n    CONTINUATION: '\\\\',\n  };\n\n  let v3Symbols = {\n    OPEN_CHOICE: '[',\n    CLOSE_CHOICE: ']',\n    OPEN_WEIGHT: '^', // also allows (int), eg. (3)\n    CLOSE_WEIGHT: '^',\n    CONTINUATION: '~',\n  };\n\n  Object.assign(Symbols, v2Compatible ? v2Symbols : v3Symbols);\n\n  const Escaped = {};\n  Object.entries(Symbols).forEach(([k, v]) => { Escaped[k] = escapeRegex(v) });\n\n  const PENDING_GATE_PATTERN = new RegExp(`${Escaped.PENDING_GATE}([0-9]{9,11})`)\n\n  Escaped.SPECIAL = Object.values(Escaped).join('').replace(/[<>]/g, ''); // allow <>& for html \n  Symbols.PENDING_GATE_RE = new RegExp(PENDING_GATE_PATTERN.source, 'g'); // for unresolved gates\n\n  const ExitGate = createToken({\n    name: \"ExitGate\",\n    pattern: new RegExp(`\\\\s*${Escaped.CLOSE_GATE}`),\n    pop_mode: true\n  });\n\n  const Gate = createToken({\n    name: \"Gate\",\n    pattern: new RegExp(`[^${Escaped.CLOSE_GATE}]+`)\n  });\n\n  const PendingGate = createToken({\n    name: \"PendingGate\",\n    pattern: PENDING_GATE_PATTERN\n  });\n\n  const EnterGate = createToken({\n    name: \"EnterGate\",\n    pattern: new RegExp(`${Escaped.OPEN_GATE}\\\\s*`),\n    push_mode: \"gate_mode\"\n  });\n\n  \n  const OC = createToken({ name: \"OC\", pattern: new RegExp(Escaped.OPEN_CHOICE + '\\\\s*') });\n  const CC = createToken({ name: \"CC\", pattern: new RegExp(`\\\\s*${Escaped.CLOSE_CHOICE}`) });\n  const OR = createToken({ name: \"OR\", pattern: /\\s*\\|\\s*/ });\n  const ELSE = createToken({ name: \"ELSE\", pattern: /\\s*\\|\\|\\s*/ });\n  const EQ = createToken({ name: \"EQ\", pattern: /\\s*=\\s*/ });\n  const TF = createToken({ name: \"TF\", pattern: /\\.[A-Za-z_0-9][A-Za-z_0-9]*(\\(\\))?/ });\n  const OS = createToken({ name: \"OS\", pattern: new RegExp(`${Escaped.OPEN_SILENT}\\\\s*`) });\n  const CS = createToken({ name: \"CS\", pattern: new RegExp(`\\\\s*${Escaped.CLOSE_SILENT}`) });\n  const SYM = createToken({ name: \"SYM\", pattern: new RegExp(`[${Escaped.DYNAMIC}${Escaped.STATIC}][A-Za-z_0-9]*`) });\n\n  const Entity = createToken({ name: \"Entity\", pattern: /&([a-z0-9]+|#[0-9]{1,6}|#x[0-9a-fA-F]{1,6});/i });\n  const Weight = createToken({ name: \"Weight\", pattern: new RegExp(`\\\\s*${Escaped.OPEN_WEIGHT}.+${Escaped.CLOSE_WEIGHT}\\\\s*`) });\n  const Raw = createToken({ name: \"Raw\", pattern: new RegExp(`[^${Escaped.SPECIAL}]+`) });\n\n  const normalMode = [Entity, Weight, ELSE, OC, CC, OR, EQ, SYM, TF, OS, CS, PendingGate, Raw, EnterGate];\n  const gateMode = [Gate, ExitGate];\n\n  const multiMode = {\n    modes: {\n      normal: normalMode,\n      gate_mode: gateMode\n    },\n    defaultMode: 'normal'\n  };\n\n  return { tokens: multiMode, Constants: { Symbols, Escaped } };\n}\n\nfunction escapeRegex(s) {\n  return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n}\n\n// console.log(getTokens().tokens.modes.normal.map(t => t.name));\n\nexport { getTokens };","\nimport { CstParser } from \"chevrotain\"\n\nclass RiScriptParser extends CstParser {\n\n  constructor(allTokens) {\n    super(allTokens, { nodeLocationTracking: \"full\" });\n    this.atomTypes = ['silent', 'assign', 'symbol', 'choice', 'pgate', 'text', 'entity'];\n    this.buildRules();\n  }\n\n  parse(opts) {\n    this.input = opts.tokens; // superclass member (do not change)\n    \n    let cst = this.script();\n    if (this.errors.length > 0) throw Error\n      (\"[PARSING]\\n\" + this.errors[0].message);\n    return cst;\n  }\n\n  buildRules() {\n\n    const $ = this, Tokens = this.tokensMap;\n\n    $.RULE(\"script\", () => {\n      $.MANY(() => $.SUBRULE($.expr));\n    });\n\n    $.RULE(\"pgate\", () => {\n      $.CONSUME(Tokens.PendingGate);\n      $.MANY(() => $.CONSUME(Tokens.TF));\n    });\n\n    $.RULE(\"entity\", () => {\n      $.CONSUME(Tokens.Entity);\n    });\n\n    $.RULE(\"gate\", () => {\n      $.CONSUME(Tokens.EnterGate);\n      $.MANY(() => $.CONSUME(Tokens.Gate));\n      $.CONSUME(Tokens.ExitGate);\n    });\n\n    $.RULE(\"silent\", () => {\n      $.CONSUME(Tokens.OS);\n      $.OPTION1(() => $.SUBRULE($.gate));\n      $.CONSUME(Tokens.SYM);\n      $.OPTION2(() => {\n        $.CONSUME(Tokens.EQ);\n        $.SUBRULE($.expr);\n      });\n      $.CONSUME(Tokens.CS);\n    });\n\n    $.RULE(\"assign\", () => {\n      $.CONSUME(Tokens.SYM);\n      $.CONSUME(Tokens.EQ);\n      $.SUBRULE($.expr);\n    });\n\n    $.RULE(\"symbol\", () => {\n      $.CONSUME(Tokens.SYM);\n      $.MANY(() => $.CONSUME(Tokens.TF));\n    });\n\n    $.RULE(\"accept\", () => {\n      $.SUBRULE($.or_expr);\n    });\n\n    $.RULE(\"reject\", () => {\n      $.SUBRULE($.or_expr);\n    });\n\n    $.RULE(\"or_expr\", () => {\n      $.MANY_SEP({\n        SEP: Tokens.OR,\n        DEF: () => $.SUBRULE($.wexpr)\n      });\n    });\n\n    // choice: (LP (wexpr OR)* wexpr RP) transform*;\n    $.RULE(\"choice\", () => {\n      $.CONSUME(Tokens.OC)\n      $.OPTION1(() => $.SUBRULE($.gate));\n      $.SUBRULE($.accept)\n      // $.MANY_SEP({\n      //   SEP: Tokens.OR,\n      //   DEF: () => $.SUBRULE($.wexpr)\n      // });\n      $.OPTION2(() => {\n        $.CONSUME(Tokens.ELSE);\n        $.SUBRULE($.reject)\n      });\n      $.CONSUME(Tokens.CC);\n      $.MANY(() => $.CONSUME(Tokens.TF));\n    });\n\n    $.RULE(\"wexpr\", () => {\n      $.MANY(() => {\n        $.OR([\n          { ALT: () => $.SUBRULE($.expr) },\n          { ALT: () => $.CONSUME(Tokens.Weight) },\n        ])\n      });\n    });\n\n    $.RULE(\"expr\", () => {\n      $.AT_LEAST_ONE(() => $.SUBRULE($.atom));\n    });\n\n    $.RULE(\"atom\", () => {\n      $.OR(this.atomTypes.map(t => ({ ALT: () => $.SUBRULE($[t]) })));\n    });\n\n    $.RULE(\"text\", () => {\n      $.CONSUME(Tokens.Raw);\n    });\n\n    this.performSelfAnalysis(); // keep\n  }\n}\n\nexport { RiScriptParser };","\nclass BaseVisitor {\n  constructor(riScript) {\n    this.input = 0;\n\n    this.path = '';\n    this.tracePath = true;\n    this.scripting = riScript;\n    this.warnOnInvalidGates = false;\n    this.RiScript = this.scripting.constructor; // class hack\n  }\n\n  isCstNode(o) {\n    return (typeof o === 'object' &&\n      ('accept' in o || ('name' in o && 'location' in o && 'children' in o)));\n  }\n\n  visit(cstNode, param) {\n    if (Array.isArray(cstNode)) {\n      cstNode = cstNode[0];\n    }\n    if (typeof cstNode === 'undefined') {\n      return undefined;\n    }\n    if (!this.isCstNode(cstNode)) {\n      throw Error('Non-cstNode passed to visit: ' + JSON.stringify(cstNode));\n    }\n\n    const { name, location } = cstNode;\n\n    this.nodeText = this.input.substring(\n      location.startOffset,\n      location.endOffset + 1\n    );\n\n    if (typeof this[name] !== 'function') {\n      throw Error('BaseVisitor.visit: expecting function for this[' +\n        `${name}], found ${typeof this[name]}: ${JSON.stringify(this[name])}`);\n    }\n\n    if (this.tracePath && !/(expr|atom|silent)/.test(name)) {\n      this.path += name + '.';\n    }\n    return this[name](cstNode.children, param);\n  }\n\n  validateVisitor() {\n    /* no-op */\n  }\n}\n\nclass RiScriptVisitor extends BaseVisitor {\n  constructor(riScript, context = {}) {\n    super(riScript); // stored as global RiScript (TODO)\n    this.context = context;\n\n    this.trace = 0;\n    this.choices = {};\n    this.isNoRepeat = false;\n    this.symbols = this.scripting.Symbols;\n    this.escaped = this.scripting.Escaped;\n\n    // lookups\n    this.statics = {};\n    this.dynamics = {};\n    this.pendingGates = {};\n    this.pendingSymbols = new Set();\n\n    this.validateVisitor(); // keep\n  }\n\n  start(opts = {}) {\n    this.input = opts.input;\n    this.trace = opts.trace;\n    this.traceTx = opts.traceTx;\n    if (!opts.cst) throw Error('no cst');\n    return super.visit(opts.cst);\n  }\n\n  script(ctx) {\n    this.order = 0;\n    const count = ctx.expr ? ctx.expr.length : 0;\n    this.print('script', \"'\" + this.RiScript._escapeText(this.input)\n      + \"' :: \" + count + ' expression(s)');\n    if (!count) return '';\n    if (Object.keys(ctx).length !== 1) throw Error('script: invalid expr');\n    return this.visit(ctx.expr);\n  }\n\n  expr(ctx) {\n    // this.print('expr', ctx);\n    const types = Object.keys(ctx);\n    if (types.length !== 1) throw Error('invalid expr: ' + types.length);\n    const exprs = ctx.atom.map((c) => this.visit(c));\n    // handle special cases of the form: \"not [quite|] far enough\"\n    for (let i = 1; i < exprs.length - 1; i++) {\n      if (\n        exprs[i].length === 0 &&\n        exprs[i - 1].endsWith(' ') &&\n        exprs[i + 1].startsWith(' ')\n      ) {\n        exprs[i + 1] = exprs[i + 1].substring(1);\n      }\n    }\n    return exprs.join('');\n  }\n\n  wexpr(ctx) {\n    this.print('wexpr');\n  }\n\n  gate(ctx) {\n    // returns { decision: [accept | reject] } or { decision: 'defer', operands: [] }\n\n    if (ctx.Gate.length !== 1) throw Error('Invalid gate: ' + ctx.Gate);\n\n    let mingoQuery;\n    const raw = ctx.Gate[0].image;\n    try {\n      mingoQuery = this.scripting._query(raw);\n    } catch (e) {\n      if (!this.warnOnInvalidGates) {\n        throw Error(`Invalid gate[2]: \"@${raw}@\"\\n\\nRootCause -> ${e}`);\n      }\n      if (!this.scripting.RiTa.SILENT && !this.scripting.silent) {\n        console.warn(`[WARN] Ignoring invalid gate: @${raw}@\\n`, e);\n      }\n      return { decision: 'accept' };\n    }\n\n    const resolvedOps = {};\n    const unresolvedOps = [];\n    const operands = mingoQuery.operands();\n    operands.forEach((sym) => {\n      let { result, resolved, isStatic, isUser } = this.checkContext(sym);\n\n      if (typeof result === 'function') {\n        // while {} ?\n        result = result.call(); // call it\n        resolved = !this.scripting.isParseable(result);\n      }\n      if (typeof result === 'undefined' || !resolved) {\n        unresolvedOps.push(sym);\n      } else {\n        // add to appropriate context\n        if (isStatic) {\n          this.statics[sym] = result;\n        } else if (isUser) {\n          this.context[sym] = result;\n        } else {\n          this.dynamics[sym] = result;\n        }\n        // store resolved result\n        resolvedOps[sym] = result;\n      }\n    });\n\n    if (\n      Object.keys(resolvedOps).length + unresolvedOps.length !==\n      operands.length\n    ) { throw Error('invalid operands'); }\n\n    // if we have unresolved operands, return them (and defer)\n    if (unresolvedOps.length) { return { decision: 'defer', operands: unresolvedOps }; }\n\n    let result = mingoQuery.test(resolvedOps); // do test\n    if (!result && this.castValues(resolvedOps)) {\n      result = mingoQuery.test(resolvedOps); // redo test after casting\n    }\n\n    return { decision: result ? 'accept' : 'reject' };\n  }\n\n  assign(ctx, opts) {\n    const sym = ctx.SYM[0].image;\n    let value;\n    let info;\n    const ident = sym.replace(this.scripting.AnySymbolRE, '');\n    const isStatic = sym.startsWith(this.symbols.STATIC);\n\n    if (isStatic) {\n      value = this.visit(ctx.expr);\n      if (this.scripting.isParseable(value)) {\n        this.statics[ident] = value; // store in lookup table ??\n        value = this.inlineAssignment(ident, ctx.TF, value);\n      } else {\n        this.statics[ident] = value; // store in lookup table\n        this.pendingSymbols.delete(ident); // no longer pending\n        this.trace &&\n          console.log('  [pending.delete]', sym,\n            this.pendingSymbols.length\n              ? JSON.stringify(this.pendingSymbols)\n              : ''\n          );\n      }\n      info = `${sym} = ${this.RiScript._escapeText(value)}` +\n        ` [#static] ${opts?.silent ? '{silent}' : ''}`;\n    } else {\n      const $ = this;\n\n      // dynamic: store as func to be resolved later, perhaps many times\n      value = () => $.visit(ctx.expr);\n      info = `${sym} = <f*:pending>` + (opts?.silent ? '{silent}' : '');\n\n      // NOTE: this function may contain a choice, which needs to be handled\n      // when called from a symbol with a norepeat transform (??) TODO: test\n\n      this.dynamics[ident] = value; // store in lookup table\n    }\n    this.print('assign', info);\n\n    return value;\n  }\n\n  silent(ctx) {\n    if (ctx.EQ) {\n      this.assign(ctx, { silent: true });\n    } else {\n      this.symbol(ctx, { silent: true });\n    }\n    return '';\n  }\n\n  atom(ctx) {\n    let result;\n    const types = Object.keys(ctx);\n    if (types.length !== 1) throw Error('invalid atom: ' + types);\n    this.scripting.parser.atomTypes.forEach((type) => {\n      const context = ctx[type];\n      if (context) {\n        if (context.length !== 1) {\n          throw Error(type + ': bad length -> ' + ctx[type].length);\n        }\n        // console.log(type + ':', context[0]);\n        result = this.visit(context[0]);\n      }\n    });\n\n    // pending function, call it\n    if (typeof result === 'function') {\n      result = result.call();\n    }\n    return result;\n  }\n\n  text(ctx) {\n    if (ctx.Raw.length !== 1) throw Error('[1] invalid text');\n    if (Object.keys(ctx).length !== 1) throw Error('[2] invalid text');\n    const image = ctx.Raw[0].image;\n    this.print('text', this.RiScript._escapeText(\"'\" + image + \"'\"));\n    return image;\n  }\n\n  entity(ctx) {\n    return this.nodeText;\n  }\n\n  symbol(ctx, opts) {\n    if (ctx.SYM.length !== 1) throw Error('[1] invalid symbol');\n\n    const original = this.nodeText;\n    const symbol = ctx.SYM[0].image;\n    const ident = symbol.replace(this.scripting.AnySymbolRE, '');\n\n    this.isNoRepeat = this.hasNoRepeat(ctx.TF);\n\n    if (this.pendingSymbols.has(ident)) {\n      this.print('symbol', `${symbol} [is-pending]`);\n      return original;\n    }\n\n    // lookup: result is either a value, a function, or undef\n    let { result, isStatic, isUser, resolved } = this.checkContext(ident);\n\n    if (!isStatic && symbol.startsWith(this.symbols.STATIC)) {\n      if (!this.scripting.EntityRE.test(symbol)) {\n        throw Error(`Attempt to refer to dynamic symbol '${ident}' as` +\n          ` ${this.symbols.STATIC}${ident}, did you mean $${ident}?`);\n      }\n    }\n\n    if (typeof result === 'function') {\n      // while {} ?\n      result = result.call(); // call it\n      resolved = !this.scripting.isParseable(result);\n    }\n\n    if (this.isNoRepeat && (isStatic || isUser)) {\n      this.isNoRepeat = false;\n      const msg = 'Attempt to call norepeat() on ' + (isStatic\n        ? \"static symbol '\" + symbol + \"'. Did you mean to use '\" +\n        this.symbols.DYNAMIC + ident + \"' ?\"\n        : \"non-dynamic symbol '\" + ident + \"'. Did you mean to define '\" +\n        this.symbols.DYNAMIC + ident + \"' in riscript?\");\n      throw Error(msg);\n    }\n\n    if (typeof result === 'undefined') {\n      // nothing found, defer\n      this.print('symbol', symbol + \" -> '\" + original + \"' ctx=\" +\n        this.lookupsToString(), '[deferred]', opts?.silent ? '{silent}' : '');\n      return original;\n    }\n\n    let info = original + \" -> '\" + result + \"'\" + (opts?.silent ? ' {silent}' : '');\n\n    // defer if we still have unresolved riscript\n    if (typeof result === 'string' && !resolved) {\n      if (isStatic) {\n        this.pendingSymbols.add(ident);\n        result = this.inlineAssignment(ident, ctx.TF, result);\n        this.print('symbol*', `${original} -> ${result} :: pending.add(${ident})`);\n      } else {\n        if (ctx.TF) result = this.restoreTransforms(result, ctx.TF);\n        this.print('symbol', info);\n      }\n      return result;\n    }\n\n    if (isStatic) {\n      // store !untransformed! result in static context\n      this.statics[ident] = result; // ADDED 8/18/23 - FIXED 10/8/23\n    }\n\n    if (ctx.TF) {\n      result = this.applyTransforms(result, ctx.TF);\n      info += \" -> '\" + result + \"'\";\n      // info += \" -> \" + ctx.TF.map(tf => ` ${tf.image} -> `) + '\\'' + result + \"'\";\n      // console.log(\"INFO: \" + info);\n      if (this.isNoRepeat) info += ' (norepeat)';\n    }\n\n    this.print('symbol', info);\n\n    // resolved, so remove from pending\n    if (this.pendingSymbols.has(ident)) {\n      this.trace && console.log('  [$pending.delete]', (isStatic ? '#' : '$') + ident,\n        this.pendingSymbols.length ? JSON.stringify(this.pendingSymbols) : '');\n      this.pendingSymbols.delete(ident);\n    }\n    this.isNoRepeat = false; // reset\n\n    return result;\n  }\n\n  pgate(ctx) {\n    this.print('pgate', this.nodeText);\n    // new RegExp(`^${this.symbols.PENDING_GATE}`\n    const original = this.nodeText;\n    const ident = original.replace(this.symbols.PENDING_GATE, '');\n    const lookup = this.pendingGates[ident];\n\n    if (!lookup) {\n      throw Error('no pending gate=\"' + original + '\" pgates=' +\n        JSON.stringify(Object.keys(this.pendingGates)));\n    }\n\n    const stillUnresolved = lookup.operands.some((o) => {\n      let { result, resolved } = this.checkContext(o);\n      if (typeof result === 'function') {\n        // while {} ?\n        result = result.call(); // call it\n        resolved = !this.scripting.isParseable(result);\n      }\n      return typeof result === 'undefined' || !resolved;\n    });\n\n    if (stillUnresolved) return original; // still deferred\n\n    const result = this.choice(lookup.deferredContext); // execute the gate\n    return result;\n  }\n\n  else(ctx) {\n    // this.print('else', this.nodeText);\n    return this.visit(ctx.expr).trim();\n  }\n\n  choice(ctx, opts) {\n    const $ = this.symbols;\n    let rawGate, gateResult;\n    const original = this.nodeText;\n    let info = original;\n    const choiceKey = this.RiScript._stringHash(original + ' #' + this.choiceId(ctx));\n\n    if (!this.isNoRepeat && this.hasNoRepeat(ctx.TF)) {\n      throw Error('noRepeat() not allowed on choice (use a $variable instead): ' + original);\n    }\n\n    let decision = 'accept';\n    if (opts?.forceReject) {\n      decision = 'reject';\n    } else {\n      if (ctx.gate) {\n        // do we have a gate\n        rawGate = ctx.gate[0].children.Gate[0].image;\n        gateResult = this.visit(ctx.gate);\n        decision = gateResult.decision;\n        info += `\\n  [gate] ${rawGate} -> ${decision !== 'defer'\n          ? decision.toUpperCase()\n          : `DEFER ${$.PENDING_GATE}${choiceKey}`\n          }  ${this.lookupsToString()}`;\n      }\n\n      if (gateResult) {\n        if (gateResult.decision === 'defer') {\n          this.pendingGates[choiceKey] = {\n            deferredContext: ctx,\n            operands: gateResult.operands\n          };\n          return `${$.PENDING_GATE}${choiceKey}`; // gate defers\n        }\n      }\n    }\n\n    if (decision === 'reject' && !('reject' in ctx)) {\n      return ''; // rejected without reject expr, return ''\n    }\n\n    const orExpr = ctx[decision]?.[0]?.children?.or_expr?.[0]; // yuck\n    const options = this.parseOptions(orExpr); // get options\n    if (!options) throw Error('No options in choice: ' + original);\n\n    let value = null;\n    const excluded = [];\n    let restored = false;\n    while (value === null) {\n      value = this.choose(options, excluded).value;\n\n      // if we still have script, defer until its resolved\n      if (this.scripting.isParseable(value)) {\n        if (ctx.TF) value = this.restoreTransforms(value, ctx.TF);\n        restored = true;\n        break;\n      }\n\n      // apply any remaining transforms\n      if (ctx.TF) value = this.applyTransforms(value, ctx.TF);\n\n      // we have 'norepeat' but value was already used, try again\n      if (this.isNoRepeat && value === this.choices[choiceKey]) {\n        this.print('choice.reject', value + ' [norepeat]');\n        excluded.push(value);\n        value = null;\n        continue;\n      }\n    }\n\n    if (!restored) this.choices[choiceKey] = value; // put in choice cache\n\n    return value;\n  }\n\n  // Helpers ================================================\n\n  hasNoRepeat(tfs) {\n    const transforms = this.RiScript._transformNames(tfs);\n    if (transforms.length) {\n      return transforms.includes('nr') || transforms.includes('norepeat');\n    }\n    return false;\n  }\n\n  checkContext(ident) {\n    let isStatic = false;\n    let isUser = false;\n    let result;\n\n    if (ident.length === 0) {\n      return { result: '', resolved: true, isStatic, isUser };\n    }\n\n    // check for dynamic symbol: $var\n    result = this.dynamics[ident];\n    if (typeof result === 'undefined') {\n      // no dynamic\n\n      // check for static symbol: #var\n      result = this.statics[ident];\n      if (typeof result !== 'undefined') {\n        isStatic = true; // found static\n      }\n    }\n\n    if (typeof result === 'undefined') {\n      // no static\n      // check for user-defined symbol: context[var]\n      result = this.context[ident];\n      if (typeof result !== 'undefined') {\n        isUser = true; // found user symbol\n      } else {\n        // check for user-defined dynamic? context[$var]\n        result = this.context[this.symbols.DYNAMIC + ident];\n        if (typeof result !== 'undefined') {\n          // no static\n          // note: treat as normal dynamic, isUser = false\n        }\n      }\n    }\n\n    // do we have more script to deal with ?\n    const resolved = !this.scripting.isParseable(result);\n\n    return { result, isStatic, isUser, resolved }; // TODO: replace with 'type'\n  }\n\n  inlineAssignment(ident, tfs, result) {\n    const $ = this.symbols;\n    const lhs = $.STATIC + ident;\n    const rhs = this.restoreTransforms(result, tfs);\n    result = $.OPEN_CHOICE + (lhs + '=' + rhs) + $.CLOSE_CHOICE;\n    return result;\n  }\n\n  choiceId(ctx) {\n    if (!ctx.OC || !ctx.OC.length) throw Error('invalid choice');\n    return ctx.OC[0].startOffset + '.' + ctx.OC[0].endOffset;\n  }\n\n  parseOptions(ctx) {\n    const options = [];\n    if (ctx && ctx?.children?.wexpr) {\n      const wexprs = ctx.children.wexpr;\n      for (let i = 0; i < wexprs.length; i++) {\n        const wexpr = wexprs[i];\n        const expr = wexpr.children.expr;\n        if (expr && expr.length != 1) { throw Error('invalid choice-expr: ' + expr.length); }\n\n        const weight = wexpr.children.Weight;\n        if (weight) {\n          if (weight.length != 1) { throw Error('invalid weight: ' + weight.length); }\n          let mult = 1;\n          try {\n            mult = parseInt(\n              this.symbols.CLOSE_WEIGHT.length\n                ? weight[0].image.trim().slice(1, -1)\n                : weight[0].image.trim().slice(1)\n            );\n          } catch (e) {\n            console.log('EX: ' + mult);\n          }\n          Array.from({ length: mult }, () => options.push(expr));\n        } else {\n          options.push(expr || '');\n        }\n      }\n    }\n    return options;\n  }\n\n  chooseUnique(options, choiceKey) {\n    // not used\n\n    const isUnique = false;\n    while (options.length && !isUnique) {\n      const { index, value } = this.choose(options);\n      if (value !== this.choices[choiceKey]) return value;\n      // console.log(`Skipping ${index}: '${value}'`);\n      options.splice(index, 1);\n    }\n    throw Error('No remaining options');\n  }\n\n  choose(options, excludes = []) {\n    if (!options || !options.length) {\n      throw Error('Invalid choice: no options');\n    }\n\n    const valid = options.filter((x) => !excludes.includes(x));\n    if (!valid.length) {\n      throw Error('Invalid choice: no valid options');\n    }\n\n    const index = this.scripting.RiTa.randi(valid.length);\n\n    let value = ''; const selected = valid[index];\n\n    if (typeof selected === 'string') {\n      this.print('choice.text', \"''\");\n    } else {\n      // if (typeof selected === 'object') {\n      this.path = 'choice.' + this.path;\n      value = this.visit(selected); // cstNode\n    }\n\n    if (typeof value === 'string') value = value.trim();\n\n    return { index, value };\n  }\n\n  applyTransforms(value, txs) {\n    if (this.traceTx) { console.log('applyTransforms', this.formatTxs(...arguments)); }\n    for (let i = 0; i < txs.length; i++) {\n      value = this.applyTransform(value, txs[i]);\n    }\n    return value;\n  }\n\n  // value is not yet resolved, so store with transform for later\n  restoreTransforms(value, txs) {\n    if (typeof value === 'string') {\n      const patt = new RegExp(\n        '^' + this.escaped.OPEN_CHOICE + '.*' + this.escaped.CLOSE_CHOICE + '$'\n      );\n      if (!patt.test(value)) {\n        // wrap in choice to preserve\n        value = this.symbols.OPEN_CHOICE + value + this.symbols.CLOSE_CHOICE;\n      }\n      if (txs) {\n        txs.forEach((tx) => (value += tx.image)); // append transform strings\n      }\n      if (this.traceTx) console.log('restoreTransforms:', value);\n    }\n    return value;\n  }\n\n  castValues(obj) {\n    let madeCast = false;\n    Object.entries(obj).forEach(([k, v]) => {\n      const num = parseFloat(v);\n      if (!isNaN(num)) {\n        madeCast = true;\n        obj[k] = num; // update object with casted value\n      }\n    });\n    return madeCast;\n  }\n\n  contextIsResolved(table) {\n    let allResolved = true;\n    Object.entries(table).forEach(([key, val]) => {\n      if (!this.scripting.isParseable(val)) {\n        allResolved = false;\n      }\n    });\n    return allResolved;\n  }\n\n  applyTransform(target, transform) {\n    const image = transform.image;\n    let result;\n    const raw = target + image;\n    const tx = image.substring(1).replace(/\\(\\)$/, '');\n\n    // function in dynamics\n    if (typeof this.dynamics[tx] === 'function') {\n      result = this.dynamics[tx](target);\n    }\n    // function in statics\n    else if (typeof this.statics[tx] === 'function') {\n      result = this.statics[tx](target);\n    }\n    // function in context\n    else if (typeof this.context[tx] === 'function') {\n      result = this.context[tx](target);\n    }\n\n    // function in transforms\n    else if (typeof this.RiScript.transforms[tx] === 'function') {\n      result = this.RiScript.transforms[tx](target);\n    }\n    // member functions (usually on String)\n    else if (typeof target[tx] === 'function') {\n      result = target[tx]();\n    } else {\n      // check for property\n      if (target.hasOwnProperty(tx)) {\n        result = target[tx];\n      } else {\n        if (!this.scripting.RiTa.SILENT && !this.scripting.silent) {\n          console.warn('[WARN] Unresolved transform: ' + raw);\n        }\n\n        /* Replace transform parens so as not to trigger\n           RiScript.isParseable (for example, in v2) 0 */\n        result = raw.replace(/\\(\\)$/, '&lpar;&rpar;');\n      }\n    }\n\n    if (this.trace) { console.log(`${this.tindent()}[transform] ${raw} -> '${result}'`); }\n\n    return result;\n  }\n\n  lookupsToString() {\n    const dyns = {};\n    const stats = {};\n    Object.entries(this.dynamics || {}).forEach(\n      ([k, v]) => (dyns[`$${k} `] = v)\n    );\n    Object.entries(this.statics || {}).forEach(\n      ([k, v]) => (stats[`#${k} `] = v)\n    );\n    return JSON.stringify({ ...this.context, ...stats, ...dyns }, (k, v) =>\n      typeof v === 'function' ? '<f*:pending>' : v\n    ).replace(/\"/g, '');\n  }\n\n  formatTxs(value, txs) {\n    return value + txs.map((tx) => tx.image.replace(/()/, '') + '()').join('');\n  }\n\n  print(s, ...args) {\n    if (this.trace) {\n      if (this.path && s !== 'script') {\n        s = this.path.replace(/\\.$/, '');\n      }\n      console.log(++this.order, `[${s}]`, ...args);\n      this.path = '';\n    }\n  }\n\n  tindent() {\n    return ' '.repeat((this.order + '').length + 1);\n  }\n}\n\nexport { RiScriptVisitor };\n\n// console.log('&#33; -> '+decode('&#33;'));\n// console.log('&amp; -> '+decode('&amp;'));\n"],"mappings":"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","names":["he","Query","Lexer","createToken","getTokens","v2Compatible","Symbols","Escaped","k","v","escapeRegex","PENDING_GATE_PATTERN","ExitGate","Gate","PendingGate","EnterGate","OC","CC","OR","ELSE","EQ","TF","OS","CS","SYM","Entity","Weight","Raw","s","CstParser","RiScriptParser","allTokens","opts","cst","$","Tokens","t","BaseVisitor","riScript","o","cstNode","param","name","location","RiScriptVisitor","context","opts","ctx","count","types","exprs","c","mingoQuery","raw","e","resolvedOps","unresolvedOps","operands","sym","result","resolved","isStatic","isUser","value","info","ident","$","type","image","original","symbol","msg","lookup","rawGate","gateResult","choiceKey","decision","orExpr","options","excluded","restored","tfs","transforms","lhs","rhs","wexprs","wexpr","expr","weight","mult","index","excludes","valid","x","selected","txs","i","tx","obj","madeCast","k","v","num","table","allResolved","key","val","target","transform","dyns","stats","s","args","decode","he","VowelRE","RegexEscape","HtmlEntities","RiQuery","Query","scripting","condition","options","raw","obj","i","len","stack","keys","currentObj","key","value","ele","_RiScript","script","context","opts","Constants","tokens","getTokens","anysym","open","close","Lexer","RiScriptParser","k","lexResult","RiScriptVisitor","input","last","endingBreak","expr","rawQuery","s","str","t","name","tag","result","g","deferredGate","deferredContext","operands","reject","$","slashEscapesToEntities","lines","eqIdx","lhs","rhs","opens","charCount","closes","line","text","unescapeRegexProperty","res","parts","escaped","urp","first","phones","txs","tx","quotify","chr","hash","strHash","RiScript","__publicField","replaceAll","escapeRegExp","string","match","replacement","c","count"]}